\hypertarget{classShapeBase}{}\section{Shape\+Base Class Reference}
\label{classShapeBase}\index{Shape\+Base@{Shape\+Base}}
Inheritance diagram for Shape\+Base\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{classShapeBase}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual \hyperlink{classShapeBase_af919db3ff5e6a6d4a137cf4625189c23}{$\sim$\+Shape\+Base} ()
\item 
\hypertarget{classShapeBase_ab55ac0089ea8e37649b0d85409c008ac}{}int \hyperlink{classShapeBase_ab55ac0089ea8e37649b0d85409c008ac}{get\+Id} ()\label{classShapeBase_ab55ac0089ea8e37649b0d85409c008ac}

\begin{DoxyCompactList}\small\item\em The function returns the unique I\+D of the element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a0adf2bb9b59c68adc9dfdab8b9a67a5a}{}std\+::string \hyperlink{classShapeBase_a0adf2bb9b59c68adc9dfdab8b9a67a5a}{get\+Name} ()\label{classShapeBase_a0adf2bb9b59c68adc9dfdab8b9a67a5a}

\begin{DoxyCompactList}\small\item\em The function returns the name of the element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a7ae6deee4256eb19c6e99b52a40847cb}{}int \hyperlink{classShapeBase_a7ae6deee4256eb19c6e99b52a40847cb}{get\+Shape\+Type} ()\label{classShapeBase_a7ae6deee4256eb19c6e99b52a40847cb}

\begin{DoxyCompactList}\small\item\em The function returns the shape type of the element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a578a8062720c07fc8e1ad526422c96b8}{}size\+\_\+t \hyperlink{classShapeBase_a578a8062720c07fc8e1ad526422c96b8}{get\+Node\+Number} ()\label{classShapeBase_a578a8062720c07fc8e1ad526422c96b8}

\begin{DoxyCompactList}\small\item\em The function returns the number of nodes o the element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ab0f803aa2f7587251d746706cc478b71}{}const std\+::vector$<$ int $>$ \& \hyperlink{classShapeBase_ab0f803aa2f7587251d746706cc478b71}{get\+Node\+Ids} ()\label{classShapeBase_ab0f803aa2f7587251d746706cc478b71}

\begin{DoxyCompactList}\small\item\em The function returns the vector of node I\+Ds. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a586ebd517ab4b08eab7685b3c004b800}{}int \hyperlink{classShapeBase_a586ebd517ab4b08eab7685b3c004b800}{get\+Node\+Id} (int i)\label{classShapeBase_a586ebd517ab4b08eab7685b3c004b800}

\begin{DoxyCompactList}\small\item\em The function returns the input i$^\wedge$\{th\} node\textquotesingle{}s I\+D. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_aaf9bc340db8e5add7974be8c36e64802}{}size\+\_\+t \hyperlink{classShapeBase_aaf9bc340db8e5add7974be8c36e64802}{get\+Dim} ()\label{classShapeBase_aaf9bc340db8e5add7974be8c36e64802}

\begin{DoxyCompactList}\small\item\em The function returns the dimensions of the node, Shape\+Base\+::\+Dim. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a787774fa435981eaba73d4137686783d}{}std\+::array$<$ int, 3 $>$ \hyperlink{classShapeBase_a787774fa435981eaba73d4137686783d}{get\+Identifier\+Colour} ()\label{classShapeBase_a787774fa435981eaba73d4137686783d}

\begin{DoxyCompactList}\small\item\em The unique \mbox{[}r,g,b\mbox{]} identifier colour of the element, utilised in picking in the user interface. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_aaeddd04a53a677417d8577f031b1ca25}{}std\+::array$<$ double, 3 $>$ \hyperlink{classShapeBase_aaeddd04a53a677417d8577f031b1ca25}{get\+Centre} ()\label{classShapeBase_aaeddd04a53a677417d8577f031b1ca25}

\begin{DoxyCompactList}\small\item\em This function returns the centre of the element in world spave. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a90d1eaa5a49262418cee28284da14c16}{}double \hyperlink{classShapeBase_a90d1eaa5a49262418cee28284da14c16}{get\+Peripodialness} ()\label{classShapeBase_a90d1eaa5a49262418cee28284da14c16}

\begin{DoxyCompactList}\small\item\em This function returns the relative influence of the peripodial physical characteristics to this element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a44c758ac93865a1e51e63212ebfe2787}{}double \hyperlink{classShapeBase_a44c758ac93865a1e51e63212ebfe2787}{get\+Columnarness} ()\label{classShapeBase_a44c758ac93865a1e51e63212ebfe2787}

\begin{DoxyCompactList}\small\item\em This function returns the relative influence of the columnar physical characteristics ot this element. \end{DoxyCompactList}\item 
void \hyperlink{classShapeBase_a13cf955dcc9db425c762053468578d72}{get\+Relative\+Position\+In\+Tissue\+In\+Grid\+Index} (int n\+Grid\+X, int n\+Grid\+Y, int \&Index\+X, int \&Index\+Y, double \&Frac\+X, double \&Frac\+Y)
\begin{DoxyCompactList}\small\item\em Provides the relative position within the bounding box of the tissue, and calculates which point on the growth maps should be read. \end{DoxyCompactList}\item 
void \hyperlink{classShapeBase_a2e91ece1ff8f6cfa8d8c495a3afc59c5}{get\+Initial\+Relative\+Position\+In\+Tissue\+In\+Grid\+Index} (int n\+Grid\+X, int n\+Grid\+Y, int \&Index\+X, int \&Index\+Y, double \&Frac\+X, double \&Frac\+Y)
\begin{DoxyCompactList}\small\item\em The relative positions of the iitial configuration of the element within the bounding box of the tissue. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_aedf8b080646ee417af28e94f5857aa17}{}double \hyperlink{classShapeBase_aedf8b080646ee417af28e94f5857aa17}{get\+Stiffness\+Multiplier} ()\label{classShapeBase_aedf8b080646ee417af28e94f5857aa17}

\begin{DoxyCompactList}\small\item\em This function returns the current stiffness multiplier as a result of perturbations to physical properties. \end{DoxyCompactList}\item 
double \hyperlink{classShapeBase_a438155adad0f124efa714b349830437b}{get\+Current\+Volume} ()
\begin{DoxyCompactList}\small\item\em This function returns the current volume of the element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_adf6c972d40af4b6709481f63903c4342}{}double \hyperlink{classShapeBase_adf6c972d40af4b6709481f63903c4342}{get\+Elemental\+Elastic\+Force} (int node\+Index, int dim\+Index)\label{classShapeBase_adf6c972d40af4b6709481f63903c4342}

\begin{DoxyCompactList}\small\item\em This function returns the calculated elastic force for the node node\+Index, in coordinate dim\+Index. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ae4d82f91854fff8473dcd722ab423e10}{}void \hyperlink{classShapeBase_ae4d82f91854fff8473dcd722ab423e10}{set\+Elemental\+Elastic\+Force} (int node\+Index, int dim\+Index, double value)\label{classShapeBase_ae4d82f91854fff8473dcd722ab423e10}

\begin{DoxyCompactList}\small\item\em This functions sets the calculated elastic force for the node node\+Index, dimension dim\+Index, to the input value. \end{DoxyCompactList}\item 
gsl\+\_\+matrix $\ast$ \hyperlink{classShapeBase_abb8aa4fb16ea7b545e6b8e13b95d6b6e}{get\+Current\+Fe} ()
\begin{DoxyCompactList}\small\item\em This function returns the current elastic part of the deformation gradient. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a5b8f0f737818ca01e15b7652c38d4900}{}double \hyperlink{classShapeBase_a5b8f0f737818ca01e15b7652c38d4900}{get\+Apical\+Area} ()\label{classShapeBase_a5b8f0f737818ca01e15b7652c38d4900}

\begin{DoxyCompactList}\small\item\em This function returns the current apical area of the element. \end{DoxyCompactList}\item 
void \hyperlink{classShapeBase_a40a3c680c1b96ae81d6bfe21a0127655}{relax\+Elastic\+Forces} ()
\begin{DoxyCompactList}\small\item\em This function relaxes all teh accumulated elastic forces in the system. \end{DoxyCompactList}\item 
bool \hyperlink{classShapeBase_aa0f0cc5b33f3e12d91a246cc591c346c}{is\+Growth\+Rate\+Applicable} (int source\+Tissue, double \&weight, double zmin, double zmax)
\begin{DoxyCompactList}\small\item\em The function checks if the element if affected by the current growth functions. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a605f5ce36b0d86330fbc535f553ae140}{}void \hyperlink{classShapeBase_a605f5ce36b0d86330fbc535f553ae140}{update\+Growth\+Will\+Be\+Scaled\+Due\+To\+Apikobasal\+Redistribution} (bool this\+Function\+Shrinks\+Apical, std\+::vector$<$ int $>$ \&ellipse\+Band\+Ids\+For\+Growth\+Redistribution)\label{classShapeBase_a605f5ce36b0d86330fbc535f553ae140}

\begin{DoxyCompactList}\small\item\em This function decide if the growth will be redistirbuted in the height of the tissue. \end{DoxyCompactList}\item 
void \hyperlink{classShapeBase_aace7f6727db271b84db82d0560d26b86}{scale\+Growth\+For\+Z\+Redistribution} (double \&x, double \&y, double \&z)
\begin{DoxyCompactList}\small\item\em This function will modify the incremental growth deformation gradient of the element to reflect the volume redistribution in the height of the tissue. \end{DoxyCompactList}\item 
void \hyperlink{classShapeBase_a45508a35016a845b9c3b2d8f7d51479a}{calculate\+Fg\+From\+Rates} (double dt, double x, double y, double z, gsl\+\_\+matrix $\ast$rot\+Mat, gsl\+\_\+matrix $\ast$increment, int source\+Tissue, double z\+Min, double z\+Max)
\begin{DoxyCompactList}\small\item\em This fucntion will calculate the incremental growth deformation gradient change for the current time step, from input growth rates. \end{DoxyCompactList}\item 
void \hyperlink{classShapeBase_a23ed61e92393b0d7364a4a99ac0f77f9}{calculate\+Fg\+From\+Grid\+Corners} (int grid\+Growths\+Interpolation\+Type, double dt, \hyperlink{classGrowthFunctionBase}{Growth\+Function\+Base} $\ast$curr\+G\+F, gsl\+\_\+matrix $\ast$increment, int source\+Tissue, int Index\+X, int Index\+Y, double Frac\+X, double d\+Frac\+Y)
\begin{DoxyCompactList}\small\item\em This fucntion will calculate the incremental growth deformation gradient change for the current time step by reading it from the grid, and interpolating on 4 corners. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_acfee9abf0c9b00e278762688525ef333}{}gsl\+\_\+matrix $\ast$ \hyperlink{classShapeBase_acfee9abf0c9b00e278762688525ef333}{get\+Growth\+Increment} ()\label{classShapeBase_acfee9abf0c9b00e278762688525ef333}

\begin{DoxyCompactList}\small\item\em This function will return the current growth deformation gradient increment. \end{DoxyCompactList}\item 
void \hyperlink{classShapeBase_a009b5aed1c546db5e517f9f33f67b066}{update\+Growth\+Increment} (gsl\+\_\+matrix $\ast$columnar, gsl\+\_\+matrix $\ast$peripodial)
\begin{DoxyCompactList}\small\item\em This function will update the elemental growth deformation gradient from the current growth deformation gradient increment. \end{DoxyCompactList}\item 
void \hyperlink{classShapeBase_a466480b1e7de98250dd22c8cdb092d54}{update\+Growth\+By\+Mutation} (double dt)
\begin{DoxyCompactList}\small\item\em This function will update the growth growth deformaton gradient increment of the element due to a mutation. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a33c8d69e858be0ad6414f4f5f64eeb3b}{}void \hyperlink{classShapeBase_a33c8d69e858be0ad6414f4f5f64eeb3b}{scale\+Growth\+Increment} (double multiuplier)\label{classShapeBase_a33c8d69e858be0ad6414f4f5f64eeb3b}

\begin{DoxyCompactList}\small\item\em This function will scale the growth growth deformaton gradient increment by input double. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a2423a7dd85ab25b7eb38b5a954d732ab}{}void \hyperlink{classShapeBase_a2423a7dd85ab25b7eb38b5a954d732ab}{calculate\+Shape\+Change\+Increment\+From\+Rates} (double dt, double rx, double ry, double rz, gsl\+\_\+matrix $\ast$increment)\label{classShapeBase_a2423a7dd85ab25b7eb38b5a954d732ab}

\begin{DoxyCompactList}\small\item\em This function will calculate the current shape change deformation gradient increment due to elemental active shape change, from input rates. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ab057fa6a1189b6bed5ac9201fc6ca620}{}void \hyperlink{classShapeBase_ab057fa6a1189b6bed5ac9201fc6ca620}{update\+Shape\+Change\+Increment} (gsl\+\_\+matrix $\ast$columnar\+Shape\+Change\+Increment)\label{classShapeBase_ab057fa6a1189b6bed5ac9201fc6ca620}

\begin{DoxyCompactList}\small\item\em This function updates the growth increment of the element with the current shape change increment. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a04278729ad9cc3238b1966ade0685a3d}{}void \hyperlink{classShapeBase_a04278729ad9cc3238b1966ade0685a3d}{calculate\+Relative\+Pos\+In\+Bounding\+Box} (double bounding\+Box\+X\+Min, double bounding\+Box\+Y\+Min, double bounding\+Box\+Length, double bounding\+Box\+Width)\label{classShapeBase_a04278729ad9cc3238b1966ade0685a3d}

\begin{DoxyCompactList}\small\item\em This function will calculate the relative positions of the element in the xy-\/plane bounding box of the tissue. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_af39a584fa424f92b219d0ad903439ae7}{}void \hyperlink{classShapeBase_af39a584fa424f92b219d0ad903439ae7}{mutate\+Element} (double growth\+Fold, double growth\+Rate\+Per\+Hour)\label{classShapeBase_af39a584fa424f92b219d0ad903439ae7}

\begin{DoxyCompactList}\small\item\em This function will set the element as a mutant, the mutant growth rates will be set. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_acf601cf9b007a1e001b01fb5ed84399a}{}void \hyperlink{classShapeBase_acf601cf9b007a1e001b01fb5ed84399a}{update\+Reference\+Position\+Matrix\+From\+Input} (double $\ast$$\ast$input)\label{classShapeBase_acf601cf9b007a1e001b01fb5ed84399a}

\begin{DoxyCompactList}\small\item\em This function will update the reference position matrix. Not used under healthy, continuous simulations, to preserve continuity of the mesh. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ae5e17514271f121498ed12cebae3aebe}{}void \hyperlink{classShapeBase_ae5e17514271f121498ed12cebae3aebe}{display\+Relative\+Pos\+In\+Bounding\+Box} ()\label{classShapeBase_ae5e17514271f121498ed12cebae3aebe}

\begin{DoxyCompactList}\small\item\em Helper function to display the relative position of the element in the bounding box of the tissue. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ad50e45399c54ae205ae1adabbc485ff1}{}std\+::array$<$ double, 2 $>$ \hyperlink{classShapeBase_ad50e45399c54ae205ae1adabbc485ff1}{get\+Relative\+Pos\+In\+Bounding\+Box} ()\label{classShapeBase_ad50e45399c54ae205ae1adabbc485ff1}

\begin{DoxyCompactList}\small\item\em This function will return the relative position of the element in the xy bounding box of the tissue. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a71d8a64fec5591d51c6d54ea76711e0d}{}void \hyperlink{classShapeBase_a71d8a64fec5591d51c6d54ea76711e0d}{set\+Relative\+Pos\+In\+Bounding\+Box} (double x, double y)\label{classShapeBase_a71d8a64fec5591d51c6d54ea76711e0d}

\begin{DoxyCompactList}\small\item\em This functoin will set the relative position of the element in the bounding box of the tissue to the input coordinates. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a8c7a7578407be503531bf14af6d004d1}{}void \hyperlink{classShapeBase_a8c7a7578407be503531bf14af6d004d1}{set\+Initial\+Relative\+Pos\+In\+Bounding\+Box} ()\label{classShapeBase_a8c7a7578407be503531bf14af6d004d1}

\begin{DoxyCompactList}\small\item\em This function sets the initial relative position in bounding box of the tissue to current reference position. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a3e054f84b56303812eee5b3abeec9b2f}{}void \hyperlink{classShapeBase_a3e054f84b56303812eee5b3abeec9b2f}{set\+Initial\+Z\+Position} (double z\+Max, double Tissue\+Height)\label{classShapeBase_a3e054f84b56303812eee5b3abeec9b2f}

\begin{DoxyCompactList}\small\item\em This fucntion sets the initial relative z position of the tissue in tissue height. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a775b57d5074679c6fd4d3f57885e86d8}{}std\+::array$<$ double, 2 $>$ \hyperlink{classShapeBase_a775b57d5074679c6fd4d3f57885e86d8}{get\+Initial\+Relative\+Pos\+In\+Bounding\+Box} ()\label{classShapeBase_a775b57d5074679c6fd4d3f57885e86d8}

\begin{DoxyCompactList}\small\item\em This function will return the initial relative position of the element in the xy bounding box of the tissue. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_acde567878e8335d5f3b82042bcf23e5b}{}void \hyperlink{classShapeBase_acde567878e8335d5f3b82042bcf23e5b}{convert\+Relative\+Pos\+To\+Grid\+Index} (std\+::array$<$ double, 2 $>$ relpos, int \&index\+X, int \&index\+Y, double \&frac\+X, double \&frac\+Y, int n\+Grid\+X, int n\+Grid\+Y)\label{classShapeBase_acde567878e8335d5f3b82042bcf23e5b}

\begin{DoxyCompactList}\small\item\em This function will convert the relative position of the tissue in xy plane bounding box to growth map grid indices. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_aecf99016ea7c36e0bff43a40e6a89df3}{}void \hyperlink{classShapeBase_aecf99016ea7c36e0bff43a40e6a89df3}{get\+Strain} (int type, float \&Strain\+Mag)\label{classShapeBase_aecf99016ea7c36e0bff43a40e6a89df3}

\begin{DoxyCompactList}\small\item\em This function will return the selected strain component of the element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a6971273ad49bfe9a49b2ddf09e426291}{}void \hyperlink{classShapeBase_a6971273ad49bfe9a49b2ddf09e426291}{get\+Node\+Based\+Pys\+Prop} (int type, int Node\+No, const std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \hyperlink{classNode}{Node} $>$$>$ \&Nodes, float \&Pys\+Prop\+Mag)\label{classShapeBase_a6971273ad49bfe9a49b2ddf09e426291}

\begin{DoxyCompactList}\small\item\em This function will return the selected physical properties of the element on a nodal basis. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_abff91451c3465778ed89624d6196f7f6}{}void \hyperlink{classShapeBase_abff91451c3465778ed89624d6196f7f6}{get\+Pys\+Prop} (int type, float \&Pys\+Prop\+Mag, double dt)\label{classShapeBase_abff91451c3465778ed89624d6196f7f6}

\begin{DoxyCompactList}\small\item\em This function will return the selected physical properties of the element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a51bc2c7303dfaae0687d1d785b077e81}{}double \hyperlink{classShapeBase_a51bc2c7303dfaae0687d1d785b077e81}{get\+Internal\+Viscosity} ()\label{classShapeBase_a51bc2c7303dfaae0687d1d785b077e81}

\begin{DoxyCompactList}\small\item\em This function will return the internal viscosity of the element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ac0651f685642cfddf6cefa3542ece51a}{}double \hyperlink{classShapeBase_ac0651f685642cfddf6cefa3542ece51a}{get\+Original\+Internal\+Viscosity} ()\label{classShapeBase_ac0651f685642cfddf6cefa3542ece51a}

\begin{DoxyCompactList}\small\item\em This function will return the internal viscosity of the element prior to any perturbations. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ade96ff86461eaabce716e83fa68bfa19}{}double \hyperlink{classShapeBase_ade96ff86461eaabce716e83fa68bfa19}{get\+Young\+Modulus} ()\label{classShapeBase_ade96ff86461eaabce716e83fa68bfa19}

\begin{DoxyCompactList}\small\item\em This function will return the Young\textquotesingle{}s modulus of the element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a01140f17779cd2e990c9f28e3c86b77e}{}double \hyperlink{classShapeBase_a01140f17779cd2e990c9f28e3c86b77e}{get\+Poisson\+Ratio} ()\label{classShapeBase_a01140f17779cd2e990c9f28e3c86b77e}

\begin{DoxyCompactList}\small\item\em This function will return the Poissons\textquotesingle{}s ratio of the element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a348086a2524d9f12ca7748757d6ce645}{}const std\+::array$<$ double, 3 $>$ \& \hyperlink{classShapeBase_a348086a2524d9f12ca7748757d6ce645}{get\+Growth\+Rate} ()\label{classShapeBase_a348086a2524d9f12ca7748757d6ce645}

\begin{DoxyCompactList}\small\item\em This function will return the current growth rate of the element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ac5ca43e5283df3a948ab6e56f71fd3c6}{}const std\+::array$<$ double, 6 $>$ \& \hyperlink{classShapeBase_ac5ca43e5283df3a948ab6e56f71fd3c6}{get\+Shape\+Change\+Rate} ()\label{classShapeBase_ac5ca43e5283df3a948ab6e56f71fd3c6}

\begin{DoxyCompactList}\small\item\em This function will return the current shape change rate of the element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a8362daf177d7d30d0b02aca95a185b25}{}const std\+::vector$<$ std\+::array$<$ double, 3 $>$ $>$ \& \hyperlink{classShapeBase_a8362daf177d7d30d0b02aca95a185b25}{get\+Reference\+Pos} ()\label{classShapeBase_a8362daf177d7d30d0b02aca95a185b25}

\begin{DoxyCompactList}\small\item\em This function will return the reference positions of the element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ab1906a5afda8fcbeef23010759f2538c}{}void \hyperlink{classShapeBase_ab1906a5afda8fcbeef23010759f2538c}{get\+Pos} (gsl\+\_\+matrix $\ast$Pos)\label{classShapeBase_ab1906a5afda8fcbeef23010759f2538c}

\begin{DoxyCompactList}\small\item\em This function will write the position of the element into input matrix. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a79889ef9cb7831a50e5391cb1cc19793}{}gsl\+\_\+matrix $\ast$ \hyperlink{classShapeBase_a79889ef9cb7831a50e5391cb1cc19793}{get\+Fg} ()\label{classShapeBase_a79889ef9cb7831a50e5391cb1cc19793}

\begin{DoxyCompactList}\small\item\em This function will return the growth component of the deformation gradient. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_aa79110e674e80a1e429669ccb5c3e4cb}{}gsl\+\_\+matrix $\ast$ \hyperlink{classShapeBase_aa79110e674e80a1e429669ccb5c3e4cb}{get\+Inv\+Fg} ()\label{classShapeBase_aa79110e674e80a1e429669ccb5c3e4cb}

\begin{DoxyCompactList}\small\item\em This function calculates the inverse of the growth deformation gradient matrix. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ab261573ddd6829df0ee104260352c7ae}{}gsl\+\_\+matrix $\ast$ \hyperlink{classShapeBase_ab261573ddd6829df0ee104260352c7ae}{get\+Fsc} ()\label{classShapeBase_ab261573ddd6829df0ee104260352c7ae}

\begin{DoxyCompactList}\small\item\em This function will return the shape change component of the deformation gradient. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a884da8f201986aaef5c27efdd4a5b7d4}{}gsl\+\_\+matrix $\ast$ \hyperlink{classShapeBase_a884da8f201986aaef5c27efdd4a5b7d4}{get\+Inv\+Fsc} ()\label{classShapeBase_a884da8f201986aaef5c27efdd4a5b7d4}

\begin{DoxyCompactList}\small\item\em This function calculates the inverse of the shape change deformation gradient matrix. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a26de227e5135a355667be3a2a86d1431}{}gsl\+\_\+matrix $\ast$ \hyperlink{classShapeBase_a26de227e5135a355667be3a2a86d1431}{get\+Fe} ()\label{classShapeBase_a26de227e5135a355667be3a2a86d1431}

\begin{DoxyCompactList}\small\item\em This function will return the elastic component of the deformation gradient. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a4916a23d305f1258ec83b7e53adabea1}{}double \hyperlink{classShapeBase_a4916a23d305f1258ec83b7e53adabea1}{get\+Z\+Remodelling\+So\+Far} ()\label{classShapeBase_a4916a23d305f1258ec83b7e53adabea1}

\begin{DoxyCompactList}\small\item\em This function will return the z remodelling applied to the element so far, to cap the z remodelling. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ad225c2235e531e5ee239a127bbf92def}{}void \hyperlink{classShapeBase_ad225c2235e531e5ee239a127bbf92def}{set\+Z\+Remodelling\+So\+Far} (double \hyperlink{classShapeBase_a0dc566eb70e64da9fc3fa222b16999da}{z\+Remodelling\+So\+Far})\label{classShapeBase_ad225c2235e531e5ee239a127bbf92def}

\begin{DoxyCompactList}\small\item\em This function will set the z remodelling applied to the element so far to input value. This is needed during saved input reading. \end{DoxyCompactList}\item 
void \hyperlink{classShapeBase_ab8a7323c50767ecdc82d8d8ce411b264}{display\+Name} ()
\begin{DoxyCompactList}\small\item\em Helper function, display the name of the element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a324f8fd5dd90c14b621b2f2ee3ec98db}{}void \hyperlink{classShapeBase_a324f8fd5dd90c14b621b2f2ee3ec98db}{display\+Node\+Ids} ()\label{classShapeBase_a324f8fd5dd90c14b621b2f2ee3ec98db}

\begin{DoxyCompactList}\small\item\em Helper function, display the Ids of the nodes of the element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_aca4d0f70caf459dc93f914ef7fc2a053}{}void \hyperlink{classShapeBase_aca4d0f70caf459dc93f914ef7fc2a053}{display\+Positions} ()\label{classShapeBase_aca4d0f70caf459dc93f914ef7fc2a053}

\begin{DoxyCompactList}\small\item\em Helper function, display the nodal positions of the element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_af2d221cf63220dad3ecf139ffa164698}{}void \hyperlink{classShapeBase_af2d221cf63220dad3ecf139ffa164698}{display\+Reference\+Positions} ()\label{classShapeBase_af2d221cf63220dad3ecf139ffa164698}

\begin{DoxyCompactList}\small\item\em Helper function, display the nodal positions of the reference element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_aba6bb76d8adffaeb7ad36cce8a3f17ab}{}void \hyperlink{classShapeBase_aba6bb76d8adffaeb7ad36cce8a3f17ab}{display\+Identifier\+Colour} ()\label{classShapeBase_aba6bb76d8adffaeb7ad36cce8a3f17ab}

\begin{DoxyCompactList}\small\item\em Helper function, display the unique identifier colour, for picking in user interface. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ad39c3f3a555a89e106c4afaaf81c72f6}{}void \hyperlink{classShapeBase_ad39c3f3a555a89e106c4afaaf81c72f6}{set\+Fg} (gsl\+\_\+matrix $\ast$curr\+Fg)\label{classShapeBase_ad39c3f3a555a89e106c4afaaf81c72f6}

\begin{DoxyCompactList}\small\item\em This function sets the current grwoth deformation gradient matrix equal to input matrix. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a38a100fb162232636bf666eb1603f023}{}void \hyperlink{classShapeBase_a38a100fb162232636bf666eb1603f023}{set\+Growth\+Weights\+Via\+Tissue\+Placement} (double peri\+Weight)\label{classShapeBase_a38a100fb162232636bf666eb1603f023}

\begin{DoxyCompactList}\small\item\em This function sets the weight for growth rate scaling depending on tissue type. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a27bc09051d65ebc27e31b67462950070}{}void \hyperlink{classShapeBase_a27bc09051d65ebc27e31b67462950070}{set\+Youngs\+Modulus} (double \hyperlink{classShapeBase_a6c1a3a0173841d6072a5268978463ff2}{E})\label{classShapeBase_a27bc09051d65ebc27e31b67462950070}

\begin{DoxyCompactList}\small\item\em This function sets the Young\textquotesingle{}s modulus of the shape to inout double. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_aac3988352864bd06d7509b74977320d8}{}virtual void \hyperlink{classShapeBase_aac3988352864bd06d7509b74977320d8}{set\+Elastic\+Properties} (double, double, double, double, double)\label{classShapeBase_aac3988352864bd06d7509b74977320d8}

\begin{DoxyCompactList}\small\item\em This is the parent virtual function for setting up the elasticity properties of the shape depending on its tissue type placement. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ab277fb6868925516b675821add019cef}{}virtual void \hyperlink{classShapeBase_ab277fb6868925516b675821add019cef}{check\+Edge\+Lenghts\+For\+Binding} (std\+::vector$<$ int $>$ \&, std\+::vector$<$ int $>$ \&)\label{classShapeBase_ab277fb6868925516b675821add019cef}

\begin{DoxyCompactList}\small\item\em The virt. \end{DoxyCompactList}\item 
void \hyperlink{classShapeBase_ac4e051a82edb9b987edfbd783076e348}{set\+Viscosity} (double viscosity\+Apical, double viscosity\+Basal, double viscosity\+Mid)
\begin{DoxyCompactList}\small\item\em This function sets the viscosity of the element depending on its placement in the tissue. \end{DoxyCompactList}\item 
void \hyperlink{classShapeBase_a8b6ffc8d699795e4efb867efd065a679}{set\+Viscosity} (double viscosity\+Apical, double viscosity\+Basal)
\begin{DoxyCompactList}\small\item\em This function sets the viscosity of the element depending on its placement in the tissue. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ae17e8a052b0a2bf5b11f6d5498d61923}{}void \hyperlink{classShapeBase_ae17e8a052b0a2bf5b11f6d5498d61923}{set\+Viscosity} (double viscosity)\label{classShapeBase_ae17e8a052b0a2bf5b11f6d5498d61923}

\begin{DoxyCompactList}\small\item\em This function sets the viscosity of the element depending on its placement in the tissue. \end{DoxyCompactList}\item 
double \hyperlink{classShapeBase_a3eecbff8db98871f4b5f1ee0992f3d6d}{calculate\+Emergent\+Shape\+Orientation} ()
\begin{DoxyCompactList}\small\item\em This fucntion calculates the orientation of the emergent shape of an element in the xy plane of the tissue. \end{DoxyCompactList}\item 
bool \hyperlink{classShapeBase_ae9cfd1ae56e018477dd3642d4d769d90}{is\+Actin\+Stiffness\+Change\+Applied\+To\+Element} (bool There\+Is\+Whole\+Tissue\+Stiffness\+Perturbation, bool There\+Is\+Apical\+Stiffness\+Perturbation, bool There\+Is\+Basal\+Stiffness\+Perturbation, bool There\+Is\+Basolateral\+With\+Apical\+Relaxation\+Stiffness\+Perturbation, bool There\+Is\+Basolateral\+Stiffness\+Perturbation, std\+::vector$<$ int $>$ \&stiffness\+Perturbation\+Ellipse\+Band\+Ids, int number\+Of\+Stiffness\+Perturbation\+Applies\+Ellipse\+Bands)
\begin{DoxyCompactList}\small\item\em This function decides if the actin stiffness perturbation is applied to this element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ab1572ddb1f68178e0607873a432f227c}{}bool \hyperlink{classShapeBase_ab1572ddb1f68178e0607873a432f227c}{is\+E\+C\+M\+Change\+Applied\+To\+Element} (bool change\+Apical\+E\+C\+M, bool change\+Basal\+E\+C\+M, std\+::vector$<$ int $>$ \&E\+C\+M\+Change\+Ellipse\+Band\+Ids, int number\+Of\+E\+C\+M\+Change\+Ellipse\+Bands)\label{classShapeBase_ab1572ddb1f68178e0607873a432f227c}

\begin{DoxyCompactList}\small\item\em This function decides if the E\+C\+M perturbation is applied to this element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_aff9e4c602276e9aec411d7a05e83a118}{}bool \hyperlink{classShapeBase_aff9e4c602276e9aec411d7a05e83a118}{is\+Shape\+Change\+Applied\+To\+Element} (std\+::vector$<$ int $>$ \&ellipse\+Band\+Ids, bool apply\+Basal\+E\+C\+M, bool apply\+To\+Lateral\+E\+C\+M, bool apply\+Apically, bool apply\+Basally, bool apply\+Mid\+Layer)\label{classShapeBase_aff9e4c602276e9aec411d7a05e83a118}

\begin{DoxyCompactList}\small\item\em This function decides if the shape change perturbation is applied to this element. \end{DoxyCompactList}\item 
void \hyperlink{classShapeBase_aef460b84dc469f89742af7c19411454f}{calculate\+Stiffness\+Perturbation\+Rate} (bool There\+Is\+Basolateral\+With\+Apical\+Relaxation\+Stiffness\+Perturbation, double stiffness\+Perturbation\+Begin\+Time\+In\+Sec, double stiffness\+Perturbation\+End\+Time\+In\+Sec, double stiffness\+Changed\+To\+Fraction\+Of\+Original)
\begin{DoxyCompactList}\small\item\em This function will calciulate the stiffness perturbation rate. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a4eb97c0c1a988e77126809745b191c02}{}void \hyperlink{classShapeBase_a4eb97c0c1a988e77126809745b191c02}{update\+Stiffness\+Multiplier} (double dt)\label{classShapeBase_a4eb97c0c1a988e77126809745b191c02}

\begin{DoxyCompactList}\small\item\em The function will update the actin multiplier as a result of stiffness perturbations. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a12eb565639695764997f8cb81e801055}{}virtual std\+::array$<$ double, 3 $>$ \hyperlink{classShapeBase_a12eb565639695764997f8cb81e801055}{calculate\+Basal\+Normal} ()\label{classShapeBase_a12eb565639695764997f8cb81e801055}

\begin{DoxyCompactList}\small\item\em The virtual function of the parent for basal normal calculation. The value is dependent on node topology of the element and defined for eac individual child class. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a82400cae7963721655c867547caf6a76}{}virtual void \hyperlink{classShapeBase_a82400cae7963721655c867547caf6a76}{calculate\+Apical\+Normal\+Current\+Shape} ()\label{classShapeBase_a82400cae7963721655c867547caf6a76}

\begin{DoxyCompactList}\small\item\em The virtual function of the parent for apical normal calculation. The value is dependent on node topology of the element and defined for eac individual child class. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ac2c05f660fb3d68482c8ba751b68b2ed}{}void \hyperlink{classShapeBase_ac2c05f660fb3d68482c8ba751b68b2ed}{calculate\+Current\+Growth\+Increment} (gsl\+\_\+matrix $\ast$resulting\+Growth\+Increment, double dt, double growthx, double growthy, double growthz, gsl\+\_\+matrix $\ast$Shear\+Angle\+Rotation\+Matrix)\label{classShapeBase_ac2c05f660fb3d68482c8ba751b68b2ed}

\begin{DoxyCompactList}\small\item\em The function calculates the current growth increment from the input of growth rate and the orientation rotation matrix. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a227d409b04d95e3110db851a9cb3ed8c}{}void {\bfseries update\+Shape\+Change\+Rate} (double x, double y, double z, double xy, double yz, double xz)\label{classShapeBase_a227d409b04d95e3110db851a9cb3ed8c}

\item 
\hypertarget{classShapeBase_ab86b6c4eef2ea6232dd1d0c300ae5602}{}virtual void \hyperlink{classShapeBase_ab86b6c4eef2ea6232dd1d0c300ae5602}{calculate\+Element\+Shape\+Function\+Derivatives} ()\label{classShapeBase_ab86b6c4eef2ea6232dd1d0c300ae5602}

\begin{DoxyCompactList}\small\item\em The virtual function of the parent for calculation of shape function derivatives. This is topology dependent and implemented in each child shape type. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_acca6ea9484bbc995d941f1a7bb25e1db}{}virtual void \hyperlink{classShapeBase_acca6ea9484bbc995d941f1a7bb25e1db}{calculate\+Curr\+Nodal\+Forces} (gsl\+\_\+matrix $\ast$, gsl\+\_\+matrix $\ast$, gsl\+\_\+matrix $\ast$, gsl\+\_\+matrix $\ast$, int)\label{classShapeBase_acca6ea9484bbc995d941f1a7bb25e1db}

\begin{DoxyCompactList}\small\item\em The virtual function to calculate nodal force. This is topology dependent and implemented in each child shape type. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a9c1dc3dcba4b76026ce83fb7b78c0831}{}virtual void {\bfseries calculate\+Curr\+Tri\+Point\+F\+For\+Rotation} (gsl\+\_\+matrix $\ast$, int)\label{classShapeBase_a9c1dc3dcba4b76026ce83fb7b78c0831}

\item 
\hypertarget{classShapeBase_a010092ac7af5667facbbb8fb6bd98976}{}virtual void \hyperlink{classShapeBase_a010092ac7af5667facbbb8fb6bd98976}{calculate\+Apical\+Area} ()\label{classShapeBase_a010092ac7af5667facbbb8fb6bd98976}

\begin{DoxyCompactList}\small\item\em The virtual function to calculate apical area of element. This is topology dependent and implemented in each child shape type. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a0bc80947335afbc181fca326e9a6b7fb}{}virtual void \hyperlink{classShapeBase_a0bc80947335afbc181fca326e9a6b7fb}{calculate\+Basal\+Area} ()\label{classShapeBase_a0bc80947335afbc181fca326e9a6b7fb}

\begin{DoxyCompactList}\small\item\em The virtual function to calculate basal area of element. This is topology dependent and implemented in each child shape type. \end{DoxyCompactList}\item 
double \hyperlink{classShapeBase_a58ffd31ed76797d558b085fe754cc4b3}{calculate\+Current\+Grown\+And\+Emergent\+Volumes} ()
\begin{DoxyCompactList}\small\item\em This is the function to calculate hte current ideal volume of the element and its current apparent volume. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a018cc92b513ff64b919c374b0767cc1b}{}virtual void \hyperlink{classShapeBase_a018cc92b513ff64b919c374b0767cc1b}{update\+Elastic\+Properties} ()\label{classShapeBase_a018cc92b513ff64b919c374b0767cc1b}

\begin{DoxyCompactList}\small\item\em This functions updates elastic propertiesand their dependent tensors upon alteration of a physical property. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a5e7d2fb83a97d57922c145dcc9be2f09}{}void \hyperlink{classShapeBase_a5e7d2fb83a97d57922c145dcc9be2f09}{write\+Internal\+Forces\+Toge\+Andgv} (gsl\+\_\+matrix $\ast$ge, gsl\+\_\+matrix $\ast$gv\+Internal, std\+::vector$<$ std\+::array$<$ double, 3 $>$$>$ \&System\+Forces, const std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \hyperlink{classNode}{Node} $>$$>$ \&Nodes)\label{classShapeBase_a5e7d2fb83a97d57922c145dcc9be2f09}

\begin{DoxyCompactList}\small\item\em This function writes the elemental elastic and viscous forces to the system scale force vector. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a7e69d4ab492428c657941fa3b9423cef}{}void {\bfseries calculate\+Forces} (const std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \hyperlink{classNode}{Node} $>$$>$ \&Nodes, gsl\+\_\+matrix $\ast$displacement\+Per\+Dt)\label{classShapeBase_a7e69d4ab492428c657941fa3b9423cef}

\item 
\hypertarget{classShapeBase_a14199858399bf70d6cc1b33cfdd6bf01}{}void \hyperlink{classShapeBase_a14199858399bf70d6cc1b33cfdd6bf01}{update\+Positions} (const std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \hyperlink{classNode}{Node} $>$$>$ \&Nodes)\label{classShapeBase_a14199858399bf70d6cc1b33cfdd6bf01}

\begin{DoxyCompactList}\small\item\em This function updates the position array of the element from the updated nodal posiitons. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ac06c53088788e3c1461233623f506dbb}{}void \hyperlink{classShapeBase_ac06c53088788e3c1461233623f506dbb}{set\+Growth\+Rate} (double dt, double rx, double ry, double rz)\label{classShapeBase_ac06c53088788e3c1461233623f506dbb}

\begin{DoxyCompactList}\small\item\em This function sets the growth of the element from the tome step and the input rates. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a9572e9a52675224dfada4f4de366f05d}{}void \hyperlink{classShapeBase_a9572e9a52675224dfada4f4de366f05d}{set\+Growth\+Rate\+Via\+Input\+Time\+Multiplied\+Magnitude} (double x, double y, double z)\label{classShapeBase_a9572e9a52675224dfada4f4de366f05d}

\begin{DoxyCompactList}\small\item\em This function sets the growht rate to pre-\/calculated rates given as input. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ad7d7957431a1ae402347efb03ad94d0e}{}void \hyperlink{classShapeBase_ad7d7957431a1ae402347efb03ad94d0e}{update\+Growth\+Increment\+From\+Rate} ()\label{classShapeBase_ad7d7957431a1ae402347efb03ad94d0e}

\begin{DoxyCompactList}\small\item\em This function fills th egrowht increment matirx from the current growth rate matrix. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_aeda828c652c3253076530000226a5dbb}{}double \hyperlink{classShapeBase_aeda828c652c3253076530000226a5dbb}{calculate\+Volume\+For\+Input\+Shape\+Structure} (std\+::vector$<$ std\+::array$<$ double, 3 $>$$>$ shape\+Positions, size\+\_\+t n\+Triangular\+Faces, std\+::vector$<$ std\+::array$<$ int, 3 $>$$>$ triangular\+Faces, std\+::array$<$ double, 3 $>$ mid\+Point)\label{classShapeBase_aeda828c652c3253076530000226a5dbb}

\begin{DoxyCompactList}\small\item\em This function calculates the volume of the shape, it is generalised such that the shape is defined as an array of triengles forming a convex hull. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a3cde54fe712bac297fa73949d07c1bd4}{}void \hyperlink{classShapeBase_a3cde54fe712bac297fa73949d07c1bd4}{calculate\+Principal\+Strains3\+D} (double \&e1, double \&e2, double \&e3, gsl\+\_\+matrix $\ast$eigen\+Vec)\label{classShapeBase_a3cde54fe712bac297fa73949d07c1bd4}

\begin{DoxyCompactList}\small\item\em This function calculates the principal components of the strains through eigen values and eigen vectors in 3\+D. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a6fe833f9684db5cc1847761b6bbd9aa9}{}void \hyperlink{classShapeBase_a6fe833f9684db5cc1847761b6bbd9aa9}{calculate\+Principal\+Strains2\+D} (double \&e1, double \&e2, double \&e3, gsl\+\_\+matrix $\ast$eigen\+Vec)\label{classShapeBase_a6fe833f9684db5cc1847761b6bbd9aa9}

\begin{DoxyCompactList}\small\item\em This function calculates the principal components of the strains through eigen values and eigen vectors in 2\+D. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a8a9f91384133d8953dbb38d71cc29d51}{}void \hyperlink{classShapeBase_a8a9f91384133d8953dbb38d71cc29d51}{set\+Shape\+Change\+Rate} (double x, double y, double z, double xy, double yz, double xz)\label{classShapeBase_a8a9f91384133d8953dbb38d71cc29d51}

\begin{DoxyCompactList}\small\item\em This function sets the shape change rate to pre-\/calculated rates given as input. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_adacee19f788f056fe794bde14b934063}{}void \hyperlink{classShapeBase_adacee19f788f056fe794bde14b934063}{set\+Shape\+Change\+Inrement\+To\+Identity} ()\label{classShapeBase_adacee19f788f056fe794bde14b934063}

\begin{DoxyCompactList}\small\item\em This function sets the shape change deformation gradient increment to identity. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a3292b2b5d9fd3430a21914031614ccdd}{}void \hyperlink{classShapeBase_a3292b2b5d9fd3430a21914031614ccdd}{update\+Element\+Volumes\+And\+Tissue\+Placements\+For\+Save} (const std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \hyperlink{classNode}{Node} $>$$>$ \&Nodes)\label{classShapeBase_a3292b2b5d9fd3430a21914031614ccdd}

\begin{DoxyCompactList}\small\item\em This function calculates the reference volume, tissue placement and tissue type from nodal information. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a4fba51323da7719de06fba53077eebc4}{}bool \hyperlink{classShapeBase_a4fba51323da7719de06fba53077eebc4}{read\+Node\+Id\+Data} (std\+::ifstream \&file)\label{classShapeBase_a4fba51323da7719de06fba53077eebc4}

\begin{DoxyCompactList}\small\item\em This function reads in the node Ids for the element from save file. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a123de76dba6d7d9242c2931d79e47e37}{}bool \hyperlink{classShapeBase_a123de76dba6d7d9242c2931d79e47e37}{read\+Reference\+Position\+Data} (std\+::ifstream \&file)\label{classShapeBase_a123de76dba6d7d9242c2931d79e47e37}

\begin{DoxyCompactList}\small\item\em This function reads the reference element positions from save file. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a4aeacce216911def0e0c54b1bb4286bd}{}bool \hyperlink{classShapeBase_a4aeacce216911def0e0c54b1bb4286bd}{areany\+Of\+My\+Nodes\+At\+Circumference} (const std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \hyperlink{classNode}{Node} $>$ $>$ \&Nodes)\label{classShapeBase_a4aeacce216911def0e0c54b1bb4286bd}

\begin{DoxyCompactList}\small\item\em This function check if the element owns any node at tissue circumference. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_adb6927dd05e3f6aa1c5ac5d32a30b5da}{}virtual void \hyperlink{classShapeBase_adb6927dd05e3f6aa1c5ac5d32a30b5da}{check\+Health} ()\label{classShapeBase_adb6927dd05e3f6aa1c5ac5d32a30b5da}

\begin{DoxyCompactList}\small\item\em The virtual function in parent to check if element is flipped, implemented for each child as it is node topology dependent. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a2bfdde187477364a5a0e2220ea6b2e0e}{}void \hyperlink{classShapeBase_a2bfdde187477364a5a0e2220ea6b2e0e}{write\+Kelastic\+To\+Main\+Katrix} (gsl\+\_\+matrix $\ast$K)\label{classShapeBase_a2bfdde187477364a5a0e2220ea6b2e0e}

\begin{DoxyCompactList}\small\item\em This function writes the elemental elastic component of the Jacobian to system Jacobian. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a388d38c2d6588c7ddf622f1deed53853}{}void \hyperlink{classShapeBase_a388d38c2d6588c7ddf622f1deed53853}{write\+Kviscous\+To\+Main\+Katrix} (gsl\+\_\+matrix $\ast$K)\label{classShapeBase_a388d38c2d6588c7ddf622f1deed53853}

\begin{DoxyCompactList}\small\item\em This function writes the elemental viscous component of the Jacobian to system Jacobian. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a922c41864d4826725cc72089046f818c}{}void \hyperlink{classShapeBase_a922c41864d4826725cc72089046f818c}{calculate\+Implicit\+K\+Elastic} ()\label{classShapeBase_a922c41864d4826725cc72089046f818c}

\begin{DoxyCompactList}\small\item\em This function calculates the elemental elastic component of the Jacobian for implicit N\+R itaration. \end{DoxyCompactList}\item 
void \hyperlink{classShapeBase_a20c23d30b7f9f3bc7ed2fde542401aeb}{calculate\+Implicit\+K\+Viscous} (gsl\+\_\+matrix $\ast$displacement\+Per\+Dt, double dt)
\begin{DoxyCompactList}\small\item\em This function calculates the elemental viscous component of the Jacobian for implicit N\+R itaration. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a6a9f16ddb320974584323d78ca4aec9c}{}void \hyperlink{classShapeBase_a6a9f16ddb320974584323d78ca4aec9c}{calculate\+Force\+From\+Stress} (int node\+Id, gsl\+\_\+matrix $\ast$Externalstress, gsl\+\_\+matrix $\ast$External\+Nodal\+Forces)\label{classShapeBase_a6a9f16ddb320974584323d78ca4aec9c}

\begin{DoxyCompactList}\small\item\em This function calculates the elemental nodal forces from an input external stress matrix. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a570d553851b58e0c12f45f2d70344eea}{}void \hyperlink{classShapeBase_a570d553851b58e0c12f45f2d70344eea}{update\+Shape\+From\+Save} (std\+::ifstream \&file)\label{classShapeBase_a570d553851b58e0c12f45f2d70344eea}

\begin{DoxyCompactList}\small\item\em This function updates the element geometric poroerties from save file. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_aef1912b0fe9cfe98ed4b377774c2f0c7}{}void \hyperlink{classShapeBase_aef1912b0fe9cfe98ed4b377774c2f0c7}{display\+Matrix} (boost\+::numeric\+::ublas\+::matrix$<$ double $>$ \&mat, std\+::string matname)\label{classShapeBase_aef1912b0fe9cfe98ed4b377774c2f0c7}

\begin{DoxyCompactList}\small\item\em Helper function, displays the input blas (double) matrix with the input name. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a2b74c35e2d5a2abed9c521c735f1954a}{}void \hyperlink{classShapeBase_a2b74c35e2d5a2abed9c521c735f1954a}{display\+Matrix} (boost\+::numeric\+::ublas\+::matrix$<$ int $>$ \&mat, std\+::string matname)\label{classShapeBase_a2b74c35e2d5a2abed9c521c735f1954a}

\begin{DoxyCompactList}\small\item\em Helper function, displays the input blas (int) matrix with the input name. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a662efa15155aa6e90ccc1102563dada8}{}void \hyperlink{classShapeBase_a662efa15155aa6e90ccc1102563dada8}{display\+Matrix} (boost\+::numeric\+::ublas\+::vector$<$ double $>$ \&vec, std\+::string matname)\label{classShapeBase_a662efa15155aa6e90ccc1102563dada8}

\begin{DoxyCompactList}\small\item\em Helper function, displays the input blas (double) vector with the input name. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_abb781fb01957dfb519eb1863bb64d7ab}{}void \hyperlink{classShapeBase_abb781fb01957dfb519eb1863bb64d7ab}{display\+Matrix} (gsl\+\_\+matrix $\ast$mat, std\+::string matname)\label{classShapeBase_abb781fb01957dfb519eb1863bb64d7ab}

\begin{DoxyCompactList}\small\item\em Helper function, displays the input gsl matrix with the input name. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a0283ac144e865859f4e7bb455e06bee9}{}void \hyperlink{classShapeBase_a0283ac144e865859f4e7bb455e06bee9}{display\+Matrix} (gsl\+\_\+vector $\ast$mat, std\+::string matname)\label{classShapeBase_a0283ac144e865859f4e7bb455e06bee9}

\begin{DoxyCompactList}\small\item\em Helper function, displays the input gsl vector with the input name. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a4b37ec963a6078a7e03512d23470c257}{}void \hyperlink{classShapeBase_a4b37ec963a6078a7e03512d23470c257}{create\+Matrix\+Copy} (gsl\+\_\+matrix $\ast$dest, gsl\+\_\+matrix $\ast$src)\label{classShapeBase_a4b37ec963a6078a7e03512d23470c257}

\begin{DoxyCompactList}\small\item\em Helper function, creates a copy of the gsl matrix on new memory locaiton. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a31f6cfbda8b021fd4e55ca1e3676f7c6}{}double \hyperlink{classShapeBase_a31f6cfbda8b021fd4e55ca1e3676f7c6}{calculate\+Magnitude\+Vector3\+D} (std\+::array$<$ double, 3 $>$ \hyperlink{classShapeBase_a8b4c2d3bfbc6c9785c5181a56f929151}{v})\label{classShapeBase_a31f6cfbda8b021fd4e55ca1e3676f7c6}

\begin{DoxyCompactList}\small\item\em Helper algebraic function, calculates norm of the vector defined in the array$<$double,3$>$;. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a9e7ca6bbc30107ed82e73694f9c34717}{}void \hyperlink{classShapeBase_a9e7ca6bbc30107ed82e73694f9c34717}{normalise\+Vector3\+D} (gsl\+\_\+vector $\ast$\hyperlink{classShapeBase_a8b4c2d3bfbc6c9785c5181a56f929151}{v})\label{classShapeBase_a9e7ca6bbc30107ed82e73694f9c34717}

\begin{DoxyCompactList}\small\item\em Helper algebraic function, normalises the input gsl vector (the input vector is modified) \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_acefffe34f00f3e65c0894dacdc5f5bf5}{}double \hyperlink{classShapeBase_acefffe34f00f3e65c0894dacdc5f5bf5}{normalise\+Vector3\+D} (std\+::array$<$ double, 3 $>$ \&\hyperlink{classShapeBase_a8b4c2d3bfbc6c9785c5181a56f929151}{v})\label{classShapeBase_acefffe34f00f3e65c0894dacdc5f5bf5}

\begin{DoxyCompactList}\small\item\em Helper algebraic function, normalises the input array$<$double,3$>$ (the input vector is modified) \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a38c436dca2006e445f7949bc34f08e3c}{}double \hyperlink{classShapeBase_a38c436dca2006e445f7949bc34f08e3c}{get\+Norm\+Vector3\+D} (gsl\+\_\+vector $\ast$\hyperlink{classShapeBase_a8b4c2d3bfbc6c9785c5181a56f929151}{v})\label{classShapeBase_a38c436dca2006e445f7949bc34f08e3c}

\begin{DoxyCompactList}\small\item\em Helper algebraic function, calculates norm of the vector defined in the gsl vector, the vector is not modified. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ad86161effaf1c7c607aba51609a99e70}{}double \hyperlink{classShapeBase_ad86161effaf1c7c607aba51609a99e70}{determinant3by3\+Matrix} (boost\+::numeric\+::ublas\+::matrix$<$ double $>$ \&Mat)\label{classShapeBase_ad86161effaf1c7c607aba51609a99e70}

\begin{DoxyCompactList}\small\item\em Helper algebraic function, calculates determinant of 3by3 boost matrix. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_af52dce091d2e8369f546df9adeb1e6c0}{}double \hyperlink{classShapeBase_af52dce091d2e8369f546df9adeb1e6c0}{determinant3by3\+Matrix} (gsl\+\_\+matrix $\ast$Mat)\label{classShapeBase_af52dce091d2e8369f546df9adeb1e6c0}

\begin{DoxyCompactList}\small\item\em Helper algebraic function, calculates determinant of 3by3 gsl matrix. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a32f1a594c4be91e71f567cc04290a7f5}{}double \hyperlink{classShapeBase_a32f1a594c4be91e71f567cc04290a7f5}{determinant2by2\+Matrix} (boost\+::numeric\+::ublas\+::matrix$<$ double $>$ \&Mat)\label{classShapeBase_a32f1a594c4be91e71f567cc04290a7f5}

\begin{DoxyCompactList}\small\item\em Helper algebraic function, calculates determinant of 2by2 boost matrix. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a8334f4c3c865792f57ffb456ea61212b}{}void {\bfseries calculate\+Rotation\+Angle\+Sin\+Cos} (std\+::array$<$ double, 3 $>$ \&u, std\+::array$<$ double, 3 $>$ \&\hyperlink{classShapeBase_a8b4c2d3bfbc6c9785c5181a56f929151}{v}, double \&c, double \&s)\label{classShapeBase_a8334f4c3c865792f57ffb456ea61212b}

\item 
\hypertarget{classShapeBase_a06df78e90e5d7bcb9898c2844ecf2e60}{}void \hyperlink{classShapeBase_a06df78e90e5d7bcb9898c2844ecf2e60}{calculate\+Rotation\+Axis} (const std\+::array$<$ double, 3 $>$ \&u, const std\+::array$<$ double, 3 $>$ \&\hyperlink{classShapeBase_a8b4c2d3bfbc6c9785c5181a56f929151}{v}, std\+::array$<$ double, 3 $>$ \&rot\+Ax, double c)\label{classShapeBase_a06df78e90e5d7bcb9898c2844ecf2e60}

\begin{DoxyCompactList}\small\item\em Helper algebraic function calculates the sine and cosine of the rotation angle needed to align vector u onto v. \end{DoxyCompactList}\item 
void \hyperlink{classShapeBase_ac5ea30d81c19c9f7c904af66310c750b}{construct\+Rotation\+Matrix} (double c, double s, double $\ast$rot\+Ax, double $\ast$rot\+Mat)
\begin{DoxyCompactList}\small\item\em Helper algebraic function calculates the rotation axis needed to align vector u onto v. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a4c9e11497d04d084fdfe72654bbfb174}{}void \hyperlink{classShapeBase_a4c9e11497d04d084fdfe72654bbfb174}{construct\+Rotation\+Matrix} (double c, double s, std\+::array$<$ double, 3 $>$ \&rot\+Ax, std\+::array$<$ double, 9 $>$ \&rot\+Mat)\label{classShapeBase_a4c9e11497d04d084fdfe72654bbfb174}

\begin{DoxyCompactList}\small\item\em Helper algebraic functio calculates the rotation matrix from input sine, cosine of the rotation angle and the rotation axis. Writes the matrix into the input rot\+Mat. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ad803a237b7e7c06d419a308625a599e0}{}void \hyperlink{classShapeBase_ad803a237b7e7c06d419a308625a599e0}{rotate\+Vector\+By\+Rotation\+Matrix} (double $\ast$u, double $\ast$rot\+Mat)\label{classShapeBase_ad803a237b7e7c06d419a308625a599e0}

\begin{DoxyCompactList}\small\item\em Helper algebraic function rotates the input vector v by rotation matrix rot\+Mat. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a14a573072213ea91314c8f1101f106bb}{}void \hyperlink{classShapeBase_a14a573072213ea91314c8f1101f106bb}{rotate\+Vector\+By\+Rotation\+Matrix} (double $\ast$u, gsl\+\_\+matrix $\ast$rot\+Mat)\label{classShapeBase_a14a573072213ea91314c8f1101f106bb}

\begin{DoxyCompactList}\small\item\em Helper algebraic function rotates the input vector v by rotation matrix rot\+Mat. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_adb9c0192df7d4de8232b52e7e3009ec5}{}void \hyperlink{classShapeBase_adb9c0192df7d4de8232b52e7e3009ec5}{rotate\+Vector\+By\+Rotation\+Matrix} (std\+::array$<$ double, 3 $>$ \&u, std\+::array$<$ double, 9 $>$ rot\+Mat)\label{classShapeBase_adb9c0192df7d4de8232b52e7e3009ec5}

\begin{DoxyCompactList}\small\item\em Helper algebraic function rotates the input vector v by rotation matrix rot\+Mat. \end{DoxyCompactList}\item 
void \hyperlink{classShapeBase_a9ae4c5fc8817528493502e3f75c9a984}{Calculate\+Growth\+Rotation\+By\+F} ()
\begin{DoxyCompactList}\small\item\em This function calculates the rigid body rotation of the element around the z axis of the tissue from hte fecormation gradient. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a5f5e95f38f271d28f2856109b0256aa0}{}void \hyperlink{classShapeBase_a5f5e95f38f271d28f2856109b0256aa0}{calculate\+Tri\+Point\+F\+For\+Ratation} ()\label{classShapeBase_a5f5e95f38f271d28f2856109b0256aa0}

\begin{DoxyCompactList}\small\item\em This function calculates the current deformaiton gradient as averaged at all Gauss points, for rigid body rotation extraction. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_aa36cea09cbf418a9e37454016c5b3f30}{}void \hyperlink{classShapeBase_aa36cea09cbf418a9e37454016c5b3f30}{set\+Plastic\+Deformation\+Increment} (double xx, double yy, double zz)\label{classShapeBase_aa36cea09cbf418a9e37454016c5b3f30}

\begin{DoxyCompactList}\small\item\em This function sets diagonal of the plastic deformation gradient increment from input values. \end{DoxyCompactList}\item 
void \hyperlink{classShapeBase_a29ee0eeca30fdd381d294b383c3baf0c}{grow\+Shape\+By\+Fg} ()
\begin{DoxyCompactList}\small\item\em This function updates the current growth deformaiton gradient with the growt/shape change/plastic deformation increments and their respective rotations. \end{DoxyCompactList}\item 
void \hyperlink{classShapeBase_a5409de18ee9e47af0bb977f4a1e608fb}{change\+Shape\+By\+Fsc} (double dt)
\begin{DoxyCompactList}\small\item\em This function calculates the shape change increment from shape change rates. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_afff5db36385d757b38b7caa117686ec1}{}void \hyperlink{classShapeBase_afff5db36385d757b38b7caa117686ec1}{check\+If\+Inside\+Ellipse\+Bands} (int n\+Marker\+Ellipse\+Ranges, std\+::vector$<$ double $>$ marker\+Ellipse\+Band\+X\+Centres, std\+::vector$<$ double $>$ marker\+Ellipse\+Band\+R1\+Ranges, std\+::vector$<$ double $>$ marker\+Ellipse\+Band\+R2\+Ranges, const std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \hyperlink{classNode}{Node} $>$$>$ \&Nodes)\label{classShapeBase_afff5db36385d757b38b7caa117686ec1}

\begin{DoxyCompactList}\small\item\em This function checks if the element is inside any marker bands for perturbatins. \end{DoxyCompactList}\item 
bool \hyperlink{classShapeBase_a2e7fdc8e749b8b709b6c80248dc2bc3f}{check\+Z\+Capping\+In\+Remodelling} (bool volume\+Conserved, double z\+Remodelling\+Lower\+Threshold, double z\+Remodelling\+Upper\+Threshold, gsl\+\_\+matrix $\ast$increment, gsl\+\_\+matrix $\ast$eigen\+Vec)
\begin{DoxyCompactList}\small\item\em This function checks if the remodelling of the element in z axis have reached the specified cap. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ade1370385074f4bdc2911b567b184308}{}void \hyperlink{classShapeBase_ade1370385074f4bdc2911b567b184308}{assign\+Soft\+Hinge} (double low\+Hinge\+Limit, double high\+Hinge\+Limit, double softness\+Level)\label{classShapeBase_ade1370385074f4bdc2911b567b184308}

\begin{DoxyCompactList}\small\item\em This function modulates the stiffness of the hinge domain of the tissue with the input level. The domain is defined in relative x position boundaries. \end{DoxyCompactList}\item 
void \hyperlink{classShapeBase_aa1c9eda4ef1eb0b23620235039bab921}{calculate\+Plastic\+Deformation3\+D} (bool volume\+Conserved, double dt, double plastic\+Deformation\+Half\+Life, double z\+Remodelling\+Lower\+Threshold, double z\+Remodelling\+Upper\+Threshold)
\begin{DoxyCompactList}\small\item\em This function calculates the plastic deformation (remodelling) from the current elastic deformation gradient. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ac9a9f16148650a7acce1ec74aa693930}{}void \hyperlink{classShapeBase_ac9a9f16148650a7acce1ec74aa693930}{display\+Debugging\+Matrices} ()\label{classShapeBase_ac9a9f16148650a7acce1ec74aa693930}

\begin{DoxyCompactList}\small\item\em This function displays a selected set of matricex for debugging purposes. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a6d8088a8bb897d79a796a253c06d954f}{}virtual double \hyperlink{classShapeBase_a6d8088a8bb897d79a796a253c06d954f}{get\+Apical\+Side\+Length\+Average} ()\label{classShapeBase_a6d8088a8bb897d79a796a253c06d954f}

\begin{DoxyCompactList}\small\item\em The virtual function of the parent to calculate average apical side length, dependent on nodal topology, defined in each child. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a050c5dc5cd30c29e79533a367723b936}{}virtual double \hyperlink{classShapeBase_a050c5dc5cd30c29e79533a367723b936}{get\+Basal\+Side\+Length\+Average} ()\label{classShapeBase_a050c5dc5cd30c29e79533a367723b936}

\begin{DoxyCompactList}\small\item\em The virtual function of the parent to calculate average basal side length, dependent on nodal topology, defined in each child. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_af50dc1099b17b67a2e196724b74eab4e}{}virtual int \hyperlink{classShapeBase_af50dc1099b17b67a2e196724b74eab4e}{get\+Correcponding\+Apical} (int)\label{classShapeBase_af50dc1099b17b67a2e196724b74eab4e}

\begin{DoxyCompactList}\small\item\em The virtual function of the parent to obtain the corresponding apical node of a basal node, dependent on nodal topology, defined in each child. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_aeeaf86469ce03277c978e0fd739e3751}{}virtual bool \hyperlink{classShapeBase_aeeaf86469ce03277c978e0fd739e3751}{Is\+This\+Node\+My\+Basal} (int)\label{classShapeBase_aeeaf86469ce03277c978e0fd739e3751}

\begin{DoxyCompactList}\small\item\em The virtual function of the parent to check if the input node I\+D is a basal node of the element, dependent on nodal topology, defined in each child. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_acede81712d5205c96fcd6acdaa574368}{}virtual bool \hyperlink{classShapeBase_acede81712d5205c96fcd6acdaa574368}{Is\+This\+Node\+My\+Apical} (int)\label{classShapeBase_acede81712d5205c96fcd6acdaa574368}

\begin{DoxyCompactList}\small\item\em The virtual function of the parent to check if the input node I\+D is an apical node of the element, dependent on nodal topology, defined in each child. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a995a5e6a553ed0cdaadf74dab4f88822}{}virtual double \hyperlink{classShapeBase_a995a5e6a553ed0cdaadf74dab4f88822}{get\+Element\+Height} ()\label{classShapeBase_a995a5e6a553ed0cdaadf74dab4f88822}

\begin{DoxyCompactList}\small\item\em //$<$ The virtual function of the parent to calculate z height of the element, dependent on nodal topology, defined in each child. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a5b73c76574b69c1d02ff75f76a8ccbb6}{}virtual void {\bfseries construct\+Element\+Stack\+List} (const int, const std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \hyperlink{classShapeBase}{Shape\+Base} $>$$>$ \&)\label{classShapeBase_a5b73c76574b69c1d02ff75f76a8ccbb6}

\item 
\hypertarget{classShapeBase_a4e33b4fea2d126f59ca0bcf73e07a253}{}virtual void \hyperlink{classShapeBase_a4e33b4fea2d126f59ca0bcf73e07a253}{check\+Rotation\+Consistency3\+D} ()\label{classShapeBase_a4e33b4fea2d126f59ca0bcf73e07a253}

\begin{DoxyCompactList}\small\item\em The virtual function of the parent to check if the two input nodes of the element are directly connected on one of the elemental surfaces, dependent on nodal topology, defined in each child. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_aae5ef32d56aa383108f2d6912469138f}{}virtual bool \hyperlink{classShapeBase_aae5ef32d56aa383108f2d6912469138f}{are\+Nodes\+Directly\+Connected} (int, int)\label{classShapeBase_aae5ef32d56aa383108f2d6912469138f}

\begin{DoxyCompactList}\small\item\em The virtual function of the parent to check if the rotation of the nodes of the element are consistent, dependent on nodal topology, defined in each child. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_aed4c893952a6afad718a2037e0635296}{}bool \hyperlink{classShapeBase_aed4c893952a6afad718a2037e0635296}{Does\+Point\+Belog\+To\+Me} (int Id\+Node)\label{classShapeBase_aed4c893952a6afad718a2037e0635296}

\begin{DoxyCompactList}\small\item\em This function checks if the input node belogs to the element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a4348dcb67c58e31020346cdc0a5e7cc7}{}void \hyperlink{classShapeBase_a4348dcb67c58e31020346cdc0a5e7cc7}{assign\+Volumes\+To\+Nodes} (const std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \hyperlink{classNode}{Node} $>$$>$ \&Nodes)\label{classShapeBase_a4348dcb67c58e31020346cdc0a5e7cc7}

\begin{DoxyCompactList}\small\item\em This function distributes element\textquotesingle{}s total volume among its owner nodes. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a4bc9c0bb828f73c105321fd5a25be8cc}{}void \hyperlink{classShapeBase_a4bc9c0bb828f73c105321fd5a25be8cc}{calculate\+Z\+Projected\+Areas} ()\label{classShapeBase_a4bc9c0bb828f73c105321fd5a25be8cc}

\begin{DoxyCompactList}\small\item\em This function calculated the z-\/projected (to world xy plane) apical and basal areas of the element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a6cb53c1b619993aa5b7afd840771cfb0}{}void \hyperlink{classShapeBase_a6cb53c1b619993aa5b7afd840771cfb0}{assign\+Z\+Projected\+Areas} (const std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \hyperlink{classNode}{Node} $>$$>$ \&Nodes)\label{classShapeBase_a6cb53c1b619993aa5b7afd840771cfb0}

\begin{DoxyCompactList}\small\item\em This function distributes element\textquotesingle{}s z-\/projected areas among its owner nodes. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a4bc759e8bef0a7b02e8153d6bfb4272c}{}void \hyperlink{classShapeBase_a4bc759e8bef0a7b02e8153d6bfb4272c}{assign\+Element\+To\+Connected\+Nodes} (const std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \hyperlink{classNode}{Node} $>$$>$ \&Nodes)\label{classShapeBase_a4bc759e8bef0a7b02e8153d6bfb4272c}

\begin{DoxyCompactList}\small\item\em This function assigns the element to the nodes it owns, necessary to construc the owner and connectivity list of nodes. \end{DoxyCompactList}\item 
void \hyperlink{classShapeBase_a48f114984fe31a847a9b5485d4622ca1}{set\+E\+C\+M\+Mimicing} (bool Is\+E\+C\+M\+Mimicing)
\begin{DoxyCompactList}\small\item\em This funciton sets the element as an E\+C\+M mimicking element (distinct domain in terms of physical characteristics). \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ac42c9ed461be059e0558740ed965a8d6}{}void \hyperlink{classShapeBase_ac42c9ed461be059e0558740ed965a8d6}{set\+Actin\+Mimicing} (bool \hyperlink{classShapeBase_a892e478508ed8a375f0816b330e36ac1}{is\+Actin\+Mimicing})\label{classShapeBase_ac42c9ed461be059e0558740ed965a8d6}

\begin{DoxyCompactList}\small\item\em This funciton sets the element as an actin mimicking element (distinct domain in terms of physical characteristics). \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a0fc635fbfb4e127eed1e449a91c19d13}{}virtual void \hyperlink{classShapeBase_a0fc635fbfb4e127eed1e449a91c19d13}{assign\+Exposed\+Surface\+Area\+Indices} (const std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \hyperlink{classNode}{Node} $>$$>$ \&)\label{classShapeBase_a0fc635fbfb4e127eed1e449a91c19d13}

\begin{DoxyCompactList}\small\item\em The virtual function on parent assigns the nodes of the surfaces that are exposed to external world, dependent on topology, defined for each child. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a384ff1314700f9c7157e702c277d2819}{}void \hyperlink{classShapeBase_a384ff1314700f9c7157e702c277d2819}{calculate\+Viscosity\+Surfaces} ()\label{classShapeBase_a384ff1314700f9c7157e702c277d2819}

\begin{DoxyCompactList}\small\item\em This function calls for the assignment of exposed surfaces if the element has viscosity. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_aa91f3d3cddf8cc01ce06562185c291ba}{}void \hyperlink{classShapeBase_aa91f3d3cddf8cc01ce06562185c291ba}{assign\+Viscosity\+Surface\+Area\+To\+Nodes} (const std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \hyperlink{classNode}{Node} $>$$>$ \&Nodes)\label{classShapeBase_aa91f3d3cddf8cc01ce06562185c291ba}

\begin{DoxyCompactList}\small\item\em This function distributes elemenbt\textquotesingle{}s exposed surfaces to nodes. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_af616bee3616ec9d1f99628745f330ad7}{}void \hyperlink{classShapeBase_af616bee3616ec9d1f99628745f330ad7}{calculate\+Emergent\+Rotation\+Angles} ()\label{classShapeBase_af616bee3616ec9d1f99628745f330ad7}

\begin{DoxyCompactList}\small\item\em This function calculates the emergent rotation of the element in xy plane for display purposes. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a2e339624fd36c39f22a0ef8a40b56329}{}void \hyperlink{classShapeBase_a2e339624fd36c39f22a0ef8a40b56329}{update\+Reference\+Position\+Matrix\+From\+Mesh\+Input} (std\+::ifstream \&file)\label{classShapeBase_a2e339624fd36c39f22a0ef8a40b56329}

\begin{DoxyCompactList}\small\item\em This function updates the reference position of the element from save file. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_aea16f414d8c6318719badfef575a090d}{}void \hyperlink{classShapeBase_aea16f414d8c6318719badfef575a090d}{fill\+Node\+Neighbourhood} (const std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \hyperlink{classNode}{Node} $>$$>$ \&Nodes)\label{classShapeBase_aea16f414d8c6318719badfef575a090d}

\begin{DoxyCompactList}\small\item\em This function fills in the node neightbourhood, needed for constrction of the connectivity of nodes. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a6fe3c0f97f5ea130d95cc74be439c0d1}{}double \hyperlink{classShapeBase_a6fe3c0f97f5ea130d95cc74be439c0d1}{dot\+Product3\+D} (std\+::array$<$ double, 3 $>$ \&u, std\+::array$<$ double, 3 $>$ \&\hyperlink{classShapeBase_a8b4c2d3bfbc6c9785c5181a56f929151}{v})\label{classShapeBase_a6fe3c0f97f5ea130d95cc74be439c0d1}

\begin{DoxyCompactList}\small\item\em Helper algebraic function, calculates dot product of two arrays $<$double,3$>$ \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a334a6cec6a698ac49006d8216a93ced9}{}void \hyperlink{classShapeBase_a334a6cec6a698ac49006d8216a93ced9}{cross\+Product3\+D} (gsl\+\_\+vector $\ast$u, gsl\+\_\+vector $\ast$\hyperlink{classShapeBase_a8b4c2d3bfbc6c9785c5181a56f929151}{v}, gsl\+\_\+vector $\ast$cross)\label{classShapeBase_a334a6cec6a698ac49006d8216a93ced9}

\begin{DoxyCompactList}\small\item\em Helper algebraic function, calculates cross product of two gsl\+\_\+vectors, writes into the third input gls vector. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a52860af5f883c90296e52ddb194568ff}{}std\+::array$<$ double, 3 $>$ \hyperlink{classShapeBase_a52860af5f883c90296e52ddb194568ff}{cross\+Product3\+D} (std\+::array$<$ double, 3 $>$ u, std\+::array$<$ double, 3 $>$ \hyperlink{classShapeBase_a8b4c2d3bfbc6c9785c5181a56f929151}{v})\label{classShapeBase_a52860af5f883c90296e52ddb194568ff}

\begin{DoxyCompactList}\small\item\em Helper algebraic function, calculates cross product of two arrays $<$double,3$>$ \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a4c1d85430abf35169eb5b53ef71768ad}{}virtual void {\bfseries set\+Basal\+Neig\+Element\+Id} (const std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \hyperlink{classShapeBase}{Shape\+Base} $>$$>$ \&)\label{classShapeBase_a4c1d85430abf35169eb5b53ef71768ad}

\item 
bool \hyperlink{classShapeBase_a8763ab46f90adb819ec776a5829573c5}{is\+Element\+Flipped\+In\+Potential\+New\+Shape} (int node\+Id, double new\+X, double new\+Y, double new\+Z)
\begin{DoxyCompactList}\small\item\em This function checks if the element will plip in the case that its node (node\+I\+D) is moved to the new x,y,z coordintes specified in the input. Necessary in node collapsing. \end{DoxyCompactList}\item 
void \hyperlink{classShapeBase_a346f4ec76554bea282a5cab7ea28dfa2}{check\+For\+Collapsed\+Nodes} (int Tissue\+Height\+Discretisation\+Layers, const std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \hyperlink{classNode}{Node} $>$$>$ \&Nodes, const std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \hyperlink{classShapeBase}{Shape\+Base} $>$$>$ \&Elements)
\begin{DoxyCompactList}\small\item\em This function checks if any of the edges of the element is shortened to the extent that it should be collapsed. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ae223927913b48f7044be8aa52a60575c}{}bool \hyperlink{classShapeBase_ae223927913b48f7044be8aa52a60575c}{has\+Enough\+Nodes\+On\+Curve} (const std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \hyperlink{classNode}{Node} $>$ $>$ \&Nodes)\label{classShapeBase_ae223927913b48f7044be8aa52a60575c}

\begin{DoxyCompactList}\small\item\em This function checks if the majority of the nodes of teh element reside in a curved region, to assign it to specific curvature dependent perturbations. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_abf53d1dd8f8707d05c6a252b94093282}{}void \hyperlink{classShapeBase_abf53d1dd8f8707d05c6a252b94093282}{assign\+Ellipse\+Band\+Id\+To\+Whole\+Tissue\+Column} (size\+\_\+t Tissue\+Height\+Discretisation\+Layers, const std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \hyperlink{classNode}{Node} $>$$>$ \&Nodes, const std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \hyperlink{classShapeBase}{Shape\+Base} $>$$>$ \&Elements)\label{classShapeBase_abf53d1dd8f8707d05c6a252b94093282}

\begin{DoxyCompactList}\small\item\em This function assigns the marker I\+D of the apical elemetn ot all its connected elements in the tissue hight (all column of the element). \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_afcdcb7ee31af4717efbd5b3c99698218}{}void \hyperlink{classShapeBase_afcdcb7ee31af4717efbd5b3c99698218}{assign\+Ellipse\+Band\+Id} (const std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \hyperlink{classNode}{Node} $>$$>$ \&Nodes, int selected\+Ellipse\+Band\+Id)\label{classShapeBase_afcdcb7ee31af4717efbd5b3c99698218}

\begin{DoxyCompactList}\small\item\em This function assigns the marking ellipse band I\+D of the element depending on the definition of nodes it is consturcted of. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_aa88977dbe166e6694ad6698b93abfa22}{}void \hyperlink{classShapeBase_aa88977dbe166e6694ad6698b93abfa22}{assign\+Ellipse\+Band\+Id\+To\+Nodes} (const std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \hyperlink{classNode}{Node} $>$$>$ \&Nodes)\label{classShapeBase_aa88977dbe166e6694ad6698b93abfa22}

\begin{DoxyCompactList}\small\item\em This function assigns the marker I\+D of the elemetn to all its nodes. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a677fceb50ab5626dbc9c4f8079829d59}{}void {\bfseries add\+To\+Elemental\+Elastic\+System\+Forces} (int i, int j, double value)\label{classShapeBase_a677fceb50ab5626dbc9c4f8079829d59}

\item 
void \hyperlink{classShapeBase_a2e8e11261fb35bc925259151218eebf3}{add\+To\+Tri\+Point\+Ke} (int i, int j, double value)
\begin{DoxyCompactList}\small\item\em This function is to add the input value, to the (i,j)th element of the Elemental\+Elastic\+System\+Forces. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classShapeBase_a9cff4a8549b3399fec12309d18b6db70}{}double \hyperlink{classShapeBase_a9cff4a8549b3399fec12309d18b6db70}{stiffness\+Multiplier}\label{classShapeBase_a9cff4a8549b3399fec12309d18b6db70}

\begin{DoxyCompactList}\small\item\em Current stiffness multiplier of the element, initially 1.\+0, modulated by stiffness perturbations ///$<$ The double for the multiplier that will define Young\textquotesingle{}s modulus stress stiffening. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a0e8b443e4b55479a9d2a7a7eacd62b69}{}gsl\+\_\+matrix $\ast$ \hyperlink{classShapeBase_a0e8b443e4b55479a9d2a7a7eacd62b69}{remodelling\+Plane\+Rotation\+Matrix}\label{classShapeBase_a0e8b443e4b55479a9d2a7a7eacd62b69}

\begin{DoxyCompactList}\small\item\em The rotation matrix converting the xyz coordinate system to the plane of remodelling for the lateral elements. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a4156d7c7f91f0b528214b74277279df0}{}gsl\+\_\+matrix $\ast$ \hyperlink{classShapeBase_a4156d7c7f91f0b528214b74277279df0}{Fg}\label{classShapeBase_a4156d7c7f91f0b528214b74277279df0}

\begin{DoxyCompactList}\small\item\em Growth deformation gradient. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ae097764dd4d607b54710d7ca0f7e12f8}{}int \hyperlink{classShapeBase_ae097764dd4d607b54710d7ca0f7e12f8}{Id}\label{classShapeBase_ae097764dd4d607b54710d7ca0f7e12f8}

\begin{DoxyCompactList}\small\item\em The unique I\+D of the element, without remodelling, equal to its indes on the \hyperlink{classSimulation_a96e0aaea7b40dbb5bc11329fc7d34559}{Simulation\+::\+Elements} vector. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a4d740b60433d7a9104c2d09b0d52703d}{}int \hyperlink{classShapeBase_a4d740b60433d7a9104c2d09b0d52703d}{Shape\+Dim}\label{classShapeBase_a4d740b60433d7a9104c2d09b0d52703d}

\begin{DoxyCompactList}\small\item\em The dimension of the shape in workd coordiantes (2\+D vs 3\+D). \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_af96e17fa9a23289fb743ff0722a7dc64}{}std\+::vector$<$ int $>$ \hyperlink{classShapeBase_af96e17fa9a23289fb743ff0722a7dc64}{Node\+Ids}\label{classShapeBase_af96e17fa9a23289fb743ff0722a7dc64}

\begin{DoxyCompactList}\small\item\em The vector storing the unique I\+Ds (\hyperlink{classNode_a1bd379569cc1a8b96432e61971aed4d9}{Node\+::\+Id}) of nodes constructing this element. Their order is consistent for a given shape type. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a6a6bd8c65e2a0bfea3a956604bc05cb9}{}std\+::vector$<$ std\+::array$<$ double, 3 $>$ $>$ \hyperlink{classShapeBase_a6a6bd8c65e2a0bfea3a956604bc05cb9}{Positions}\label{classShapeBase_a6a6bd8c65e2a0bfea3a956604bc05cb9}

\begin{DoxyCompactList}\small\item\em The vector storing the positions of the nodes constructing the element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a93270dee7f71d075c73d1720c8279a44}{}std\+::unique\+\_\+ptr$<$ \hyperlink{classReferenceShapeBase}{Reference\+Shape\+Base} $>$ \hyperlink{classShapeBase_a93270dee7f71d075c73d1720c8279a44}{Reference\+Shape}\label{classShapeBase_a93270dee7f71d075c73d1720c8279a44}

\begin{DoxyCompactList}\small\item\em The pointer to the reference shape object that defines th reference shape of this element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a4bda00f80968d836c647afe5f6d1fb36}{}gsl\+\_\+matrix $\ast$ \hyperlink{classShapeBase_a4bda00f80968d836c647afe5f6d1fb36}{Strain}\label{classShapeBase_a4bda00f80968d836c647afe5f6d1fb36}

\begin{DoxyCompactList}\small\item\em The gsl\+\_\+matrix pointer, storing the address of the current strains on the element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a3da6d64116b5d73e2bb27d378035df41}{}bool \hyperlink{classShapeBase_a3da6d64116b5d73e2bb27d378035df41}{is\+Flipped}\label{classShapeBase_a3da6d64116b5d73e2bb27d378035df41}

\begin{DoxyCompactList}\small\item\em Boolean stating if the element is flipped. The simulation will be stopped if there are flipped elements. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a994acea5e6f2cf92c94f485e7ba5afc9}{}bool {\bfseries Is\+Changing\+Shape}\label{classShapeBase_a994acea5e6f2cf92c94f485e7ba5afc9}

\item 
\hypertarget{classShapeBase_aff63b1fcb823bbfdb5b19fe78dea59b8}{}int \hyperlink{classShapeBase_aff63b1fcb823bbfdb5b19fe78dea59b8}{tissue\+Placement}\label{classShapeBase_aff63b1fcb823bbfdb5b19fe78dea59b8}

\begin{DoxyCompactList}\small\item\em 1 -\/$>$ apical, 0 -\/$>$ basal, 2-\/$>$middle, 3 -\/$>$ lateral \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a1d56f7eb3fed744adc268bc4da7a790f}{}int \hyperlink{classShapeBase_a1d56f7eb3fed744adc268bc4da7a790f}{tissue\+Type}\label{classShapeBase_a1d56f7eb3fed744adc268bc4da7a790f}

\begin{DoxyCompactList}\small\item\em The tissue type is 000 for columnar layer, 1 for peripodial membrane, and 2 for linker zone. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_adafe85bbee6173d2a321408cd8b63db3}{}bool \hyperlink{classShapeBase_adafe85bbee6173d2a321408cd8b63db3}{spans\+Whole\+Tissue}\label{classShapeBase_adafe85bbee6173d2a321408cd8b63db3}

\begin{DoxyCompactList}\small\item\em Boolean staing is the element spans the whole tissue. This is used to identify mid-\/layer tagged tissues (tissue\+Placement = 2), that should still have apical abd basal responses. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a47bfa280bf33fc0557e8d804aab3936c}{}int \hyperlink{classShapeBase_a47bfa280bf33fc0557e8d804aab3936c}{compartment\+Type}\label{classShapeBase_a47bfa280bf33fc0557e8d804aab3936c}

\begin{DoxyCompactList}\small\item\em integer identifying the compartment of the tissue in D\+V axis, 0 pouch, 1 hinge, 2 notum \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_aada8d021521dbe6815a887bc0cb28cc8}{}double \hyperlink{classShapeBase_aada8d021521dbe6815a887bc0cb28cc8}{compartment\+Identity\+Fraction}\label{classShapeBase_aada8d021521dbe6815a887bc0cb28cc8}

\begin{DoxyCompactList}\small\item\em The weight defining the constibution of each compartment to the physical identity of this element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a5e442b31d2341cbe477d7c33195a576c}{}bool \hyperlink{classShapeBase_a5e442b31d2341cbe477d7c33195a576c}{is\+E\+C\+M\+Mimicing}\label{classShapeBase_a5e442b31d2341cbe477d7c33195a576c}

\begin{DoxyCompactList}\small\item\em Boolean stating if the element is an E\+C\+M element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_aa25330a1d76d3ada08bd0dced22fb79b}{}bool \hyperlink{classShapeBase_aa25330a1d76d3ada08bd0dced22fb79b}{is\+E\+C\+M\+Mimimcing\+At\+Circumference}\label{classShapeBase_aa25330a1d76d3ada08bd0dced22fb79b}

\begin{DoxyCompactList}\small\item\em Boolean stating if the element is an E\+C\+M element at the circumference of the tissue. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_afcd1d4807f83e12b2df7606acb7518b3}{}bool \hyperlink{classShapeBase_afcd1d4807f83e12b2df7606acb7518b3}{at\+Basal\+Border\+Of\+E\+C\+M}\label{classShapeBase_afcd1d4807f83e12b2df7606acb7518b3}

\begin{DoxyCompactList}\small\item\em Boolean stating if the element is at the basal border of the cellular layer, linking to E\+C\+M elements. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a892e478508ed8a375f0816b330e36ac1}{}bool \hyperlink{classShapeBase_a892e478508ed8a375f0816b330e36ac1}{is\+Actin\+Mimicing}\label{classShapeBase_a892e478508ed8a375f0816b330e36ac1}

\begin{DoxyCompactList}\small\item\em Boolean stating if the element is forming the actin dense layer on the apical surface. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a95c9fe02c9c42e0617900c3282e4403a}{}bool \hyperlink{classShapeBase_a95c9fe02c9c42e0617900c3282e4403a}{at\+Apical\+Border\+Of\+Actin}\label{classShapeBase_a95c9fe02c9c42e0617900c3282e4403a}

\begin{DoxyCompactList}\small\item\em Boolean stating if the element is at the apical border of the soft cellular layer, linking to actin dense layer. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a4f09d39d079bfe95ea7c25f5d3de6c09}{}bool \hyperlink{classShapeBase_a4f09d39d079bfe95ea7c25f5d3de6c09}{Is\+Ablated}\label{classShapeBase_a4f09d39d079bfe95ea7c25f5d3de6c09}

\begin{DoxyCompactList}\small\item\em Boolean stating if the element is laser ablated, therefore dead. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a3d15f14d23230682242ed063872617af}{}bool \hyperlink{classShapeBase_a3d15f14d23230682242ed063872617af}{at\+Symetricity\+Boundary}\label{classShapeBase_a3d15f14d23230682242ed063872617af}

\begin{DoxyCompactList}\small\item\em Boolean stating if the element is at the symmetricity boundary. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a3d48903871978d77a77cb77f569975c0}{}double \hyperlink{classShapeBase_a3d48903871978d77a77cb77f569975c0}{Curr\+Shape\+Change\+To\+Add} \mbox{[}3\mbox{]}\label{classShapeBase_a3d48903871978d77a77cb77f569975c0}

\begin{DoxyCompactList}\small\item\em The current shape change to be applied to the element, in form of 3\+D rates. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a8a1bafcaf21f040dd137abfe434a75a9}{}double \hyperlink{classShapeBase_a8a1bafcaf21f040dd137abfe434a75a9}{Grown\+Volume}\label{classShapeBase_a8a1bafcaf21f040dd137abfe434a75a9}

\begin{DoxyCompactList}\small\item\em Current volume of the element after growth. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a59943ecb9f8ec139c0f564c1fb91d876}{}double \hyperlink{classShapeBase_a59943ecb9f8ec139c0f564c1fb91d876}{Volume\+Per\+Node}\label{classShapeBase_a59943ecb9f8ec139c0f564c1fb91d876}

\begin{DoxyCompactList}\small\item\em Volume per node of the element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a21420915ac7c8444e0e5b5f4e98d7322}{}bool \hyperlink{classShapeBase_a21420915ac7c8444e0e5b5f4e98d7322}{cap\+Element}\label{classShapeBase_a21420915ac7c8444e0e5b5f4e98d7322}

\begin{DoxyCompactList}\small\item\em Boolean stating if the element is capped at its remodelling due to restrictions in z remodelling (avoiding too thin ot too thick layers due to numerical error). \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a5ef483e9f69872329b0a6365803dc8ff}{}std\+::vector$<$ int $>$ \hyperlink{classShapeBase_a5ef483e9f69872329b0a6365803dc8ff}{elements\+Ids\+On\+Same\+Column}\label{classShapeBase_a5ef483e9f69872329b0a6365803dc8ff}

\begin{DoxyCompactList}\small\item\em The vector storing the unique element I\+Ds of each element that is on the same columnar region of the tissue, i.\+e. the elements share apical/basal surfaces. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a7515f99cadce806894a7c254186a85f7}{}int \hyperlink{classShapeBase_a7515f99cadce806894a7c254186a85f7}{basal\+Neig\+Element\+Id}\label{classShapeBase_a7515f99cadce806894a7c254186a85f7}

\begin{DoxyCompactList}\small\item\em This is recorded only for apical nodes of the columnar layer. If not recorded, id is -\/1. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a1571eea2fb8259868afa5814540fe61d}{}bool \hyperlink{classShapeBase_a1571eea2fb8259868afa5814540fe61d}{inside\+Ellipse\+Band}\label{classShapeBase_a1571eea2fb8259868afa5814540fe61d}

\begin{DoxyCompactList}\small\item\em Boolean stating if the element is marked by any identifier bands for physical perturbation. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a8d2b9ded0e51df7c23499ccc3f4da9fc}{}int \hyperlink{classShapeBase_a8d2b9ded0e51df7c23499ccc3f4da9fc}{covering\+Ellipse\+Band\+Id}\label{classShapeBase_a8d2b9ded0e51df7c23499ccc3f4da9fc}

\begin{DoxyCompactList}\small\item\em The unique I\+D of the covering perturbation band. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a1484f5942bbd147ce0e9e1d842919103}{}double \hyperlink{classShapeBase_a1484f5942bbd147ce0e9e1d842919103}{emergent\+Shape\+Long\+Axis} \mbox{[}2\mbox{]}\label{classShapeBase_a1484f5942bbd147ce0e9e1d842919103}

\begin{DoxyCompactList}\small\item\em The long axis of the emergent shape. This is necessary for analysis of emergent growth orientations. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a60c845ab5c6b7e8083faa1a9833765f7}{}double \hyperlink{classShapeBase_a60c845ab5c6b7e8083faa1a9833765f7}{emergent\+Shape\+Short\+Axis} \mbox{[}2\mbox{]}\label{classShapeBase_a60c845ab5c6b7e8083faa1a9833765f7}

\begin{DoxyCompactList}\small\item\em The short axis of the emergent shape. This is necessary for analysis of emergent growth orientations. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a30219b72a2e37fad6ad5dfbcb371a85e}{}double \hyperlink{classShapeBase_a30219b72a2e37fad6ad5dfbcb371a85e}{plastic\+Deformation\+Half\+Life\+Multiplier}\label{classShapeBase_a30219b72a2e37fad6ad5dfbcb371a85e}

\begin{DoxyCompactList}\small\item\em The multiplier to modify the remodelling half-\/life upon physical property perturbation. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a3633ac9356d82c0259770ace63ca3d3d}{}bool \hyperlink{classShapeBase_a3633ac9356d82c0259770ace63ca3d3d}{is\+Mutated}\label{classShapeBase_a3633ac9356d82c0259770ace63ca3d3d}

\begin{DoxyCompactList}\small\item\em Boolean stating if the element is mutated. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_afb4ab7a9dcb19f182cde416757397b7c}{}bool \hyperlink{classShapeBase_afb4ab7a9dcb19f182cde416757397b7c}{there\+Is\+Growth\+Redistribution}\label{classShapeBase_afb4ab7a9dcb19f182cde416757397b7c}

\begin{DoxyCompactList}\small\item\em Boolean stating if there is redistribution of growth among mesh elements. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a7112715f6a436f2500793f67991b612c}{}bool \hyperlink{classShapeBase_a7112715f6a436f2500793f67991b612c}{growth\+Redistribution\+Shrinks\+Element}\label{classShapeBase_a7112715f6a436f2500793f67991b612c}

\begin{DoxyCompactList}\small\item\em Boolean stating if the growth distribution is taking material out of thes element to redistribute ot others. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a0c7adb65c236a91a84acd9c1add5dc50}{}double \hyperlink{classShapeBase_a0c7adb65c236a91a84acd9c1add5dc50}{growth\+Redistribution\+Scale}\label{classShapeBase_a0c7adb65c236a91a84acd9c1add5dc50}

\begin{DoxyCompactList}\small\item\em The extent of the redistribution of volume. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_af64f900d51cec3e48a488fdd8a51eacf}{}bool \hyperlink{classShapeBase_af64f900d51cec3e48a488fdd8a51eacf}{Rotated\+Element}\label{classShapeBase_af64f900d51cec3e48a488fdd8a51eacf}

\begin{DoxyCompactList}\small\item\em The boolean stating if the elemetn has rigid body rotation. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_acc1408c3e89b91787fec7e913cac1f58}{}gsl\+\_\+matrix $\ast$ \hyperlink{classShapeBase_acc1408c3e89b91787fec7e913cac1f58}{Growth\+Strains\+Rot\+Mat}\label{classShapeBase_acc1408c3e89b91787fec7e913cac1f58}

\begin{DoxyCompactList}\small\item\em The rotation matrix needed to correct for the rigid body rotations of the element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a38e7fb504d13f5d98d75c766e39e0143}{}std\+::array$<$ double, 3 $>$ \hyperlink{classShapeBase_a38e7fb504d13f5d98d75c766e39e0143}{apical\+Normal\+Current\+Shape}\label{classShapeBase_a38e7fb504d13f5d98d75c766e39e0143}

\begin{DoxyCompactList}\small\item\em The apical normal of the current shape. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classShapeBase_a4cc6c721ed24f27baa71fe9398edd87a}{set\+Shape\+Type} (std\+::string Type\+Name)
\begin{DoxyCompactList}\small\item\em The function sets the type of the shape. \end{DoxyCompactList}\item 
void \hyperlink{classShapeBase_a96dae3d137adec217bb0bc6ed2cace97}{read\+Node\+Ids} (const std\+::vector$<$ int $>$ \&inp\+Node\+Ids)
\begin{DoxyCompactList}\small\item\em The function sets the \hyperlink{classNode_a1bd379569cc1a8b96432e61971aed4d9}{Node\+::\+Id} array that constructs the shape. \end{DoxyCompactList}\item 
void \hyperlink{classShapeBase_a474774dd9db4c42990de569b3d8cd52e}{set\+Position\+Matrix} (const std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \hyperlink{classNode}{Node} $>$$>$ \&Nodes)
\begin{DoxyCompactList}\small\item\em The function sets the \hyperlink{classShapeBase_a6a6bd8c65e2a0bfea3a956604bc05cb9}{Shape\+Base\+::\+Positions} matrix to define the locations of each constructing node. \end{DoxyCompactList}\item 
void \hyperlink{classShapeBase_a3777927e49e4b09bfb524b4f4ac889ad}{set\+Tissue\+Placement} (const std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \hyperlink{classNode}{Node} $>$$>$ \&Nodes)
\begin{DoxyCompactList}\small\item\em The function sets the placement of the element within the tissue. \end{DoxyCompactList}\item 
void \hyperlink{classShapeBase_ad5f0b9431be849133a4eab5484fbb1f8}{set\+Tissue\+Type} (const std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \hyperlink{classNode}{Node} $>$$>$ \&Nodes)
\begin{DoxyCompactList}\small\item\em The function sets the tissue type of the element. \end{DoxyCompactList}\item 
void \hyperlink{classShapeBase_aa260269fe9605765f5adb494d1a99737}{set\+Reference\+Position\+Matrix} ()
\begin{DoxyCompactList}\small\item\em The function sets the Referenece\+Shape\+Base\+::\+Positions matrix to define the reference positions of the element. \end{DoxyCompactList}\item 
void \hyperlink{classShapeBase_a8dafd8524fe5aa5326173aa49a8f78a0}{set\+Identification\+Colour} ()
\begin{DoxyCompactList}\small\item\em The function sets the unique \hyperlink{classShapeBase_a8c6daae25e30af2e55599b7d1ecfbddb}{Shape\+Base\+::\+Identifier\+Colour} colour for the element, which is used in element picking from the user interface. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_aeed871c8f50f35cf1e506528583804ad}{}void \hyperlink{classShapeBase_aeed871c8f50f35cf1e506528583804ad}{rotate\+Reference\+Element\+By\+Rotation\+Matrix} (std\+::array$<$ double, 9 $>$ rot\+Mat)\label{classShapeBase_aeed871c8f50f35cf1e506528583804ad}

\begin{DoxyCompactList}\small\item\em The function rotates the reference of the element (\hyperlink{classShapeBase_a93270dee7f71d075c73d1720c8279a44}{Shape\+Base\+::\+Reference\+Shape}) by input rotation matrix, provided as a double pointer of 9 doubles. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ab887eaa6a0be56e3b50f549326dbe87a}{}bool \hyperlink{classShapeBase_ab887eaa6a0be56e3b50f549326dbe87a}{Invert\+Matrix} (boost\+::numeric\+::ublas\+::matrix$<$ double $>$ \&input, boost\+::numeric\+::ublas\+::matrix$<$ double $>$ \&inverse)\label{classShapeBase_ab887eaa6a0be56e3b50f549326dbe87a}

\begin{DoxyCompactList}\small\item\em The function takes the first input matrix, and writes the inverse on the second input. False is returned if the matrix is not inverted. Input format is ublas matrices (slow). \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ab0a890c07a2fa8ac45fa50bdbfe6b0d9}{}bool \hyperlink{classShapeBase_ab0a890c07a2fa8ac45fa50bdbfe6b0d9}{Invert\+Matrix} (gsl\+\_\+matrix $\ast$input, gsl\+\_\+matrix $\ast$inverse)\label{classShapeBase_ab0a890c07a2fa8ac45fa50bdbfe6b0d9}

\begin{DoxyCompactList}\small\item\em The function takes the first input matrix, and writes the inverse on the second input. False is returned if the matrix is not inverted. Input format is gsl matrices (fast). \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a92927e610d4e389c32a023554d805fc7}{}void \hyperlink{classShapeBase_a92927e610d4e389c32a023554d805fc7}{update\+Node\+Ids\+From\+Save} (std\+::ifstream \&file)\label{classShapeBase_a92927e610d4e389c32a023554d805fc7}

\begin{DoxyCompactList}\small\item\em The function reads the \hyperlink{classShapeBase_af96e17fa9a23289fb743ff0722a7dc64}{Shape\+Base\+::\+Node\+Ids} of the current shape from save file provided as input. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a93a742964154a791aacdae8e783c19c4}{}void \hyperlink{classShapeBase_a93a742964154a791aacdae8e783c19c4}{update\+Reference\+Position\+Matrix\+From\+Save} (std\+::ifstream \&file)\label{classShapeBase_a93a742964154a791aacdae8e783c19c4}

\begin{DoxyCompactList}\small\item\em The function reads and updates the \hyperlink{classShapeBase_a93270dee7f71d075c73d1720c8279a44}{Shape\+Base\+::\+Reference\+Shape} positions (\hyperlink{classReferenceShapeBase_a6b20aebb733d845a8e2b7cd4f69722cb}{Reference\+Shape\+Base\+::\+Positions}) of the current shape from save file provided as input. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a39adc8589779388b57622489f370f445}{}virtual void \hyperlink{classShapeBase_a39adc8589779388b57622489f370f445}{calculate\+Reference\+Volume} ()\label{classShapeBase_a39adc8589779388b57622489f370f445}

\begin{DoxyCompactList}\small\item\em Virtual function of the \hyperlink{classShapeBase}{Shape\+Base} class to calculate volume of the \hyperlink{classShapeBase_a93270dee7f71d075c73d1720c8279a44}{Shape\+Base\+::\+Reference\+Shape}. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a8bf9c7c8ae6a3195ec9c6b6bdaf847ab}{}bool \hyperlink{classShapeBase_a8bf9c7c8ae6a3195ec9c6b6bdaf847ab}{calculate\+Growth\+Strains\+Rot\+Mat} (double $\ast$\hyperlink{classShapeBase_a8b4c2d3bfbc6c9785c5181a56f929151}{v})\label{classShapeBase_a8bf9c7c8ae6a3195ec9c6b6bdaf847ab}

\begin{DoxyCompactList}\small\item\em The function calculates the rotation matrix to apply on growth strains to align growth with the current x axis of the tissue. \end{DoxyCompactList}\item 
void \hyperlink{classShapeBase_a1afbb15d92215f337090262753eb24ab}{calculate\+Forces3\+D} (const std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \hyperlink{classNode}{Node} $>$$>$ \&Nodes, gsl\+\_\+matrix $\ast$displacement\+Per\+Dt)
\begin{DoxyCompactList}\small\item\em The function calculates the viscous and elastic forces generated by the element. \end{DoxyCompactList}\item 
gsl\+\_\+matrix $\ast$ \hyperlink{classShapeBase_a347fb2687678294a252a12820842cb0d}{calculate\+E\+For\+Nodal\+Forces\+Kirshoff} (gsl\+\_\+matrix $\ast$C)
\begin{DoxyCompactList}\small\item\em This function calculates the green strains for a Kirshoff material model. \end{DoxyCompactList}\item 
gsl\+\_\+matrix $\ast$ \hyperlink{classShapeBase_ae09cb91359e10677889c3f59c3f5d70a}{calculate\+Cauchy\+Green\+Deformation\+Tensor} (gsl\+\_\+matrix $\ast$Fe)
\begin{DoxyCompactList}\small\item\em This function calculates the Caucy-\/\+Green deformation tensor, from the elastic part of the deformation gradient. \end{DoxyCompactList}\item 
gsl\+\_\+matrix $\ast$ \hyperlink{classShapeBase_a9c79b3bced80eac8af18a0a81d3898ab}{calculate\+S\+For\+Nodal\+Forces\+Kirshoff} (gsl\+\_\+matrix $\ast$\hyperlink{classShapeBase_a6c1a3a0173841d6072a5268978463ff2}{E})
\begin{DoxyCompactList}\small\item\em This function calculates the Secons order Piola-\/\+Kirshoff stress tensor for Kirshoff material model. \end{DoxyCompactList}\item 
gsl\+\_\+matrix $\ast$ \hyperlink{classShapeBase_a697f24754441df216b4245e7eb467b13}{calculate\+S\+For\+Nodal\+Forces\+Neo\+Hookean} (gsl\+\_\+matrix $\ast$inv\+C, double ln\+J)
\begin{DoxyCompactList}\small\item\em This function calculates the Secons order Piola-\/\+Kirshoff stress tensor for Neo-\/\+Hookean material model.\+v. \end{DoxyCompactList}\item 
void \hyperlink{classShapeBase_a606ddc7f909062e9faae9f4a311ccd8a}{update\+Lagrangian\+Elasticity\+Tensor\+Neo\+Hookean} (gsl\+\_\+matrix $\ast$inv\+C, double ln\+J, int point\+No)
\begin{DoxyCompactList}\small\item\em This function calcualtes the Lagrangian elasticity tensor for Neo-\/\+Hookean material model. \end{DoxyCompactList}\item 
gsl\+\_\+matrix $\ast$ \hyperlink{classShapeBase_a56e588bb8d290158200c6e35826f7566}{calculate\+Compact\+Stress\+For\+Nodal\+Forces} (double det\+Fe, gsl\+\_\+matrix $\ast$Fe, gsl\+\_\+matrix $\ast$S, gsl\+\_\+matrix $\ast$Stress)
\begin{DoxyCompactList}\small\item\em This function calculates elemental stress in Voigt notation. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ac9eaa594e8955de91b2f4b0368c85bae}{}gsl\+\_\+matrix $\ast$ \hyperlink{classShapeBase_ac9eaa594e8955de91b2f4b0368c85bae}{calculate\+Inverse\+Jacobian\+Stack\+For\+Nodal\+Forces} (gsl\+\_\+matrix $\ast$Jacobian)\label{classShapeBase_ac9eaa594e8955de91b2f4b0368c85bae}

\begin{DoxyCompactList}\small\item\em This function calculates the stack matrix of inverse Jacobians, used to calculate the nodal forces. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ad67919694a1d780e31f6d539781377be}{}gsl\+\_\+matrix $\ast$ \hyperlink{classShapeBase_ad67919694a1d780e31f6d539781377be}{calculate\+B\+Tfor\+Nodal\+Forces} (gsl\+\_\+matrix $\ast$Inv\+Jacobian\+Stack, gsl\+\_\+matrix $\ast$Shape\+Func\+Der\+Stack, gsl\+\_\+matrix $\ast$B, gsl\+\_\+matrix $\ast$inv\+J\+Sh\+Func\+Der\+S)\label{classShapeBase_ad67919694a1d780e31f6d539781377be}

\begin{DoxyCompactList}\small\item\em This function calculates the B matrix, to calculate the nodal force. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a8d984ddba5bbeae91cb3180897a5a3e7}{}void \hyperlink{classShapeBase_a8d984ddba5bbeae91cb3180897a5a3e7}{calculate\+Inv\+J\+Sh\+Func\+Der\+S\+With\+Fe} (gsl\+\_\+matrix $\ast$curr\+Fe, gsl\+\_\+matrix $\ast$Inv\+D\+Xde, gsl\+\_\+matrix $\ast$Shape\+Func\+Der\+Stack, gsl\+\_\+matrix $\ast$inv\+J\+Sh\+Func\+Der\+S\+With\+F)\label{classShapeBase_a8d984ddba5bbeae91cb3180897a5a3e7}

\begin{DoxyCompactList}\small\item\em This function calculates the collated matrix from inverse jaconians and shape function derivatives. \end{DoxyCompactList}\item 
gsl\+\_\+matrix $\ast$ \hyperlink{classShapeBase_aafb0d14adc7ac116191bcff4a7837e98}{calculate\+Velocity\+Gradient\+Tensor} (gsl\+\_\+matrix $\ast$B, gsl\+\_\+matrix $\ast$displacement\+Per\+Dt)
\begin{DoxyCompactList}\small\item\em This function calculates the velocity gradient tensor. \end{DoxyCompactList}\item 
gsl\+\_\+matrix $\ast$ \hyperlink{classShapeBase_afcdbbe37a746ade52a1af70a9aa12b9f}{construct\+Elemental\+Displacement\+Matrix} (gsl\+\_\+matrix $\ast$displacement)
\begin{DoxyCompactList}\small\item\em This function will assemble elemental node displacement matrix from the input displacement matrix for the whole system. \end{DoxyCompactList}\item 
gsl\+\_\+matrix $\ast$ \hyperlink{classShapeBase_afbbf191777e8787a0e8307d30ce0aa9d}{calculate\+Rate\+Of\+Deformation\+Tensor} (gsl\+\_\+matrix $\ast$l)
\begin{DoxyCompactList}\small\item\em This function will calculate rate of deformation tensor from velocity gradient tensor. \end{DoxyCompactList}\item 
void \hyperlink{classShapeBase_a22ffae25fafb0fa584a3a4d0196af7aa}{calculate\+Viscous\+Stress} (gsl\+\_\+matrix $\ast$d, gsl\+\_\+matrix $\ast$\hyperlink{classShapeBase_a29f180dc41c5b6e12b9468dd557bb524}{viscous\+Stress})
\begin{DoxyCompactList}\small\item\em This function will calculate internal viscous stress of the element from rate of deformation matrix. \end{DoxyCompactList}\item 
void \hyperlink{classShapeBase_a4d10225f251fa1bd8a2e6ffc8feb5326}{calculate\+Viscous\+Forces} (gsl\+\_\+matrix $\ast$gv, gsl\+\_\+matrix $\ast$B\+Tdet\+Fdetd\+Xde, gsl\+\_\+matrix $\ast$\hyperlink{classShapeBase_a29f180dc41c5b6e12b9468dd557bb524}{viscous\+Stress})
\begin{DoxyCompactList}\small\item\em This function will calculate the elemental viscous forces from viscous stress. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a7ae9fb15fa6e3f99173841ea910710c1}{}void \hyperlink{classShapeBase_a7ae9fb15fa6e3f99173841ea910710c1}{consturct\+Ba\+T\+Bb} (gsl\+\_\+matrix $\ast$B, gsl\+\_\+matrix $\ast$Ba\+T, gsl\+\_\+matrix $\ast$Bb, int a, int b)\label{classShapeBase_a7ae9fb15fa6e3f99173841ea910710c1}

\begin{DoxyCompactList}\small\item\em This function constructs nodal subrange of B matrix for node couple a \& b. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_abb02278c3894e00fdbc0cd2e379111ce}{}void \hyperlink{classShapeBase_abb02278c3894e00fdbc0cd2e379111ce}{calculate\+Elastic\+K\+Integral1} (gsl\+\_\+matrix $\ast$curr\+Elemental\+K, int point\+No)\label{classShapeBase_abb02278c3894e00fdbc0cd2e379111ce}

\begin{DoxyCompactList}\small\item\em This function calcultes the first part of the integral for the stiffness matirx, the elastic part of the system Jacobian. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a74a5f7382e5d4038e4396d3f4a198105}{}void \hyperlink{classShapeBase_a74a5f7382e5d4038e4396d3f4a198105}{calculate\+Elastic\+K\+Integral2} (gsl\+\_\+matrix $\ast$curr\+Elemental\+K, int point\+No)\label{classShapeBase_a74a5f7382e5d4038e4396d3f4a198105}

\begin{DoxyCompactList}\small\item\em This function calcultes the second part of the integral for the stiffness matirx, the elastic part of the system Jacobian. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a5cdcb5b445291f28d3ed3d83c582f534}{}void \hyperlink{classShapeBase_a5cdcb5b445291f28d3ed3d83c582f534}{calculate\+Viscous\+K\+Integral1} (gsl\+\_\+matrix $\ast$curr\+Elemental\+K, gsl\+\_\+matrix $\ast$paranthesis\+Term\+For\+Kv1, int point\+No)\label{classShapeBase_a5cdcb5b445291f28d3ed3d83c582f534}

\begin{DoxyCompactList}\small\item\em This function calcultes the first part of the integral for the internal viscous part of the system Jacobian. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a9795e5aad1361070df5ecdd735d9361b}{}void \hyperlink{classShapeBase_a9795e5aad1361070df5ecdd735d9361b}{calculate\+Viscous\+K\+Integral2} (gsl\+\_\+matrix $\ast$curr\+Elemental\+K, int point\+No)\label{classShapeBase_a9795e5aad1361070df5ecdd735d9361b}

\begin{DoxyCompactList}\small\item\em This function calcultes the second part of the integral for the viscous part of the system Jacobian. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a858ee3ff9bc490dc6584741f786c9478}{}void \hyperlink{classShapeBase_a858ee3ff9bc490dc6584741f786c9478}{calculate\+Velocity\+Gradient} (gsl\+\_\+matrix $\ast$velocity\+Gradient, gsl\+\_\+matrix $\ast$displacement\+Per\+Dt, int point\+No)\label{classShapeBase_a858ee3ff9bc490dc6584741f786c9478}

\begin{DoxyCompactList}\small\item\em This function calculates the velocity gradient. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ac4a71f51dacb8bdf18e1a9914e763016}{}void \hyperlink{classShapeBase_ac4a71f51dacb8bdf18e1a9914e763016}{calculate\+Outer\+Product} (gsl\+\_\+matrix $\ast$a, gsl\+\_\+matrix $\ast$b, gsl\+\_\+matrix $\ast$outer\+Product)\label{classShapeBase_ac4a71f51dacb8bdf18e1a9914e763016}

\begin{DoxyCompactList}\small\item\em Calculates the outer product, maths helper function. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a2e5eefd4db5c7a4e8495a197f76446a8}{}gsl\+\_\+matrix $\ast$ \hyperlink{classShapeBase_a2e5eefd4db5c7a4e8495a197f76446a8}{calculate\+Symmetricised\+Tensor\+Product} (gsl\+\_\+matrix $\ast$a, gsl\+\_\+matrix $\ast$b)\label{classShapeBase_a2e5eefd4db5c7a4e8495a197f76446a8}

\begin{DoxyCompactList}\small\item\em Calculates the symetricised tensor product, maths helper function. \end{DoxyCompactList}\item 
bool \hyperlink{classShapeBase_a91a660608ede71c5bfdd1c4956843760}{disassemble\+Rotation\+Matrix\+For\+Z} (gsl\+\_\+matrix $\ast$rot\+Mat)
\begin{DoxyCompactList}\small\item\em This function extracts the z rotation from a rotation matrix. \end{DoxyCompactList}\item 
bool \hyperlink{classShapeBase_a9b249ac3da27e7eeb6e0604a76f15faf}{calculate3\+D\+Rot\+Mat\+From\+F} (gsl\+\_\+matrix $\ast$rot\+Mat)
\begin{DoxyCompactList}\small\item\em This function dissects the deformation gradient of the element into the rigid body rotation and deformation. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\hypertarget{classShapeBase_a36aedd41e8465a186a0b0c454b5b76f3}{}int \hyperlink{classShapeBase_a36aedd41e8465a186a0b0c454b5b76f3}{Shape\+Type}\label{classShapeBase_a36aedd41e8465a186a0b0c454b5b76f3}

\begin{DoxyCompactList}\small\item\em The integer defining the type of the shape, Prisms shape type = 1;. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a0daa5629b1335ca3e1be089a006fe897}{}size\+\_\+t \hyperlink{classShapeBase_a0daa5629b1335ca3e1be089a006fe897}{n\+Nodes}\label{classShapeBase_a0daa5629b1335ca3e1be089a006fe897}

\begin{DoxyCompactList}\small\item\em The number of nodes of the element, it is based on \hyperlink{classShapeBase_a36aedd41e8465a186a0b0c454b5b76f3}{Shape\+Base\+::\+Shape\+Type}. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a0ae4246d158f4d66b5bd1644df40f150}{}size\+\_\+t \hyperlink{classShapeBase_a0ae4246d158f4d66b5bd1644df40f150}{n\+Dim}\label{classShapeBase_a0ae4246d158f4d66b5bd1644df40f150}

\begin{DoxyCompactList}\small\item\em The number of dimensions for the positions of each of the nodes of the element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a8c6daae25e30af2e55599b7d1ecfbddb}{}std\+::array$<$ int, 3 $>$ \hyperlink{classShapeBase_a8c6daae25e30af2e55599b7d1ecfbddb}{Identifier\+Colour}\label{classShapeBase_a8c6daae25e30af2e55599b7d1ecfbddb}

\begin{DoxyCompactList}\small\item\em The unique identifier colour of the element, this is used for \char`\"{}picking\char`\"{} in the visual interface. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_af537b85b81aa4f0812508e7a95b8b67a}{}std\+::array$<$ double, 3 $>$ \hyperlink{classShapeBase_af537b85b81aa4f0812508e7a95b8b67a}{Growth\+Rate}\label{classShapeBase_af537b85b81aa4f0812508e7a95b8b67a}

\begin{DoxyCompactList}\small\item\em Growth rate recording for display purposes only. The recorded growth rate in x, y, and z coordinates, does not record shear deformation induced in growth. Recorded in exponential form through time step, converted to rate per hour for display within the visual interface. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_af553856335d7344ea67ab10f9cc3babf}{}gsl\+\_\+matrix $\ast$ \hyperlink{classShapeBase_af553856335d7344ea67ab10f9cc3babf}{growth\+Increment}\label{classShapeBase_af553856335d7344ea67ab10f9cc3babf}

\begin{DoxyCompactList}\small\item\em The matrix (3,3) representing the incremental growth in current time step. Reset to identity at the beginning of each time step, updated in growth functions, and utilised to update Fg. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ab61c4a1f4132f54c362ea6296389abf6}{}gsl\+\_\+matrix $\ast$ \hyperlink{classShapeBase_ab61c4a1f4132f54c362ea6296389abf6}{plastic\+Deformation\+Increment}\label{classShapeBase_ab61c4a1f4132f54c362ea6296389abf6}

\begin{DoxyCompactList}\small\item\em The matrix (3,3) representing the incremental plastic deformation (treated as growth) in current time step. Set in plastic deformation calculation at each step, and utilised to update Fg. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a2db4859942429aa4e3efc26a119a5aa3}{}gsl\+\_\+matrix $\ast$ \hyperlink{classShapeBase_a2db4859942429aa4e3efc26a119a5aa3}{shape\+Change\+Increment}\label{classShapeBase_a2db4859942429aa4e3efc26a119a5aa3}

\begin{DoxyCompactList}\small\item\em The matrix (3,3) representing the incremental shape change in current time step. Reset to identity at the beginning of each time step, updated in shape change functions, and utilised to update Fg. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a0dc566eb70e64da9fc3fa222b16999da}{}double \hyperlink{classShapeBase_a0dc566eb70e64da9fc3fa222b16999da}{z\+Remodelling\+So\+Far}\label{classShapeBase_a0dc566eb70e64da9fc3fa222b16999da}

\begin{DoxyCompactList}\small\item\em The z remodelling that have been applied to elemetn up to the current time step. This parameter is used to limit extreme thinning or elongation of elements. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a134d82ba500ef829b6aa3e3a83783c9a}{}double \hyperlink{classShapeBase_a134d82ba500ef829b6aa3e3a83783c9a}{columnar\+Growth\+Weight}\label{classShapeBase_a134d82ba500ef829b6aa3e3a83783c9a}

\begin{DoxyCompactList}\small\item\em The fraction defining how close to the columnar layer the element is. 1.\+0 for columnar layer, 0.\+0 for peripodial membrane elements, and scaled according to position in the elements surrounding the lumen. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a3663f3220016756b1bd5a92477325ec2}{}double \hyperlink{classShapeBase_a3663f3220016756b1bd5a92477325ec2}{peripodial\+Growth\+Weight}\label{classShapeBase_a3663f3220016756b1bd5a92477325ec2}

\begin{DoxyCompactList}\small\item\em The fraction defining how close to the peripodial membrane the element is. 0.\+0 for columnar layer, 1.\+0 for peripodial membrane elements, and scaled according to position in the elements surrounding the lumen. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_acb3b7ef81761fc22f3bad866570f3d13}{}std\+::array$<$ double, 6 $>$ \hyperlink{classShapeBase_acb3b7ef81761fc22f3bad866570f3d13}{Shape\+Change\+Rate}\label{classShapeBase_acb3b7ef81761fc22f3bad866570f3d13}

\begin{DoxyCompactList}\small\item\em Shape change rate of the elements, only orthagonal shape changes are allowed (x, y, z). Shape changes will be scaled to conserve volume, thus three values will not be independent. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_aee6a2cd267d49404f5442a48c867860f}{}bool \hyperlink{classShapeBase_aee6a2cd267d49404f5442a48c867860f}{rotated\+Growth}\label{classShapeBase_aee6a2cd267d49404f5442a48c867860f}

\begin{DoxyCompactList}\small\item\em The boolean stating if the element has rotated from the growth axis, hence the calculated growth requires further rotation to follow tissue axes. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_af1e2ed2804c9d949810f2b9288c1d6ba}{}std\+::array$<$ double, 3 $>$ \hyperlink{classShapeBase_af1e2ed2804c9d949810f2b9288c1d6ba}{relative\+Pos\+In\+Bounding\+Box}\label{classShapeBase_af1e2ed2804c9d949810f2b9288c1d6ba}

\begin{DoxyCompactList}\small\item\em The relative position on x-\/y plane, within the bounding box of the tissue(x,y). \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a37eecd113e033c1b5cd64c5a6fefedc1}{}std\+::array$<$ double, 3 $>$ \hyperlink{classShapeBase_a37eecd113e033c1b5cd64c5a6fefedc1}{initial\+Relative\+Pos\+In\+Bounding\+Box}\label{classShapeBase_a37eecd113e033c1b5cd64c5a6fefedc1}

\begin{DoxyCompactList}\small\item\em The relative position on x-\/y plane, within the bounding box of the tissue(x,y) at the beginning of simulation. This is used when growth rates are pinned to the initial structure of the tissue. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ab6847e4087010221acd07ad298c5c0bd}{}double \hyperlink{classShapeBase_ab6847e4087010221acd07ad298c5c0bd}{initial\+Relative\+Position\+In\+Z}\label{classShapeBase_ab6847e4087010221acd07ad298c5c0bd}

\begin{DoxyCompactList}\small\item\em The relative position on z-\/height of tissue, taken not in z direction but in tissue layers, 0 being on the apical surface and 1 being on the basal surface. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a5c80fec4188317146cb31b74c36c7640}{}size\+\_\+t \hyperlink{classShapeBase_a5c80fec4188317146cb31b74c36c7640}{number\+Of\+Gauss\+Points}\label{classShapeBase_a5c80fec4188317146cb31b74c36c7640}

\begin{DoxyCompactList}\small\item\em The number of Gauss points used in numerical deforamtion calculation. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ad9f6b579cace44139825e3105c101431}{}std\+::array$<$ std\+::array$<$ double, 3 $>$, 6 $>$ \hyperlink{classShapeBase_ad9f6b579cace44139825e3105c101431}{gauss\+Points}\label{classShapeBase_ad9f6b579cace44139825e3105c101431}

\begin{DoxyCompactList}\small\item\em The array contianing all the Gauss points for element. Set up is for 6, can work for any number as loops are kept indexed up to number\+Of\+Gauss\+Points. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a50ec0d74748313a30a280258bd1e1827}{}std\+::array$<$ double, 6 $>$ \hyperlink{classShapeBase_a50ec0d74748313a30a280258bd1e1827}{gauss\+Weights}\label{classShapeBase_a50ec0d74748313a30a280258bd1e1827}

\begin{DoxyCompactList}\small\item\em The array for storing the weights of each Gauss point for element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a9451400710c0458e286c9183b8014a71}{}std\+::vector$<$ gsl\+\_\+matrix $\ast$ $>$ \hyperlink{classShapeBase_a9451400710c0458e286c9183b8014a71}{Shape\+Func\+Derivatives}\label{classShapeBase_a9451400710c0458e286c9183b8014a71}

\begin{DoxyCompactList}\small\item\em The array of matrices for shape function derivatives. The array stores a \hyperlink{classShapeBase_a0ae4246d158f4d66b5bd1644df40f150}{Shape\+Base\+::n\+Dim} by \hyperlink{classShapeBase_a0daa5629b1335ca3e1be089a006fe897}{Shape\+Base\+::n\+Nodes} matrix for each gauss point (there are 3 Gauss points for prisms). \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a21657fc100e70eaec475616adf308f81}{}std\+::vector$<$ gsl\+\_\+matrix $\ast$ $>$ \hyperlink{classShapeBase_a21657fc100e70eaec475616adf308f81}{Shape\+Func\+Der\+Stacks}\label{classShapeBase_a21657fc100e70eaec475616adf308f81}

\begin{DoxyCompactList}\small\item\em The array of matrices of shape function derivatives in stacked format for ease of matrix operations. The array stores a (\hyperlink{classShapeBase_a0ae4246d158f4d66b5bd1644df40f150}{Shape\+Base\+::n\+Dim} $\ast$ \hyperlink{classShapeBase_a0ae4246d158f4d66b5bd1644df40f150}{Shape\+Base\+::n\+Dim}) by (\hyperlink{classShapeBase_a0ae4246d158f4d66b5bd1644df40f150}{Shape\+Base\+::n\+Dim} $\ast$ \hyperlink{classShapeBase_a0daa5629b1335ca3e1be089a006fe897}{Shape\+Base\+::n\+Nodes}) matrix for each gauss point (there are 3 Gauss points for prisms). \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_aad96a4f7ac584f37627a341f1c6a6156}{}std\+::vector$<$ gsl\+\_\+matrix $\ast$ $>$ \hyperlink{classShapeBase_aad96a4f7ac584f37627a341f1c6a6156}{Invd\+Xdes}\label{classShapeBase_aad96a4f7ac584f37627a341f1c6a6156}

\begin{DoxyCompactList}\small\item\em The array stores inverse of the matrix for derivatives of world coordinates with respect to barycentric coordinates (d\+X / de). The array stores an \hyperlink{classShapeBase_a0ae4246d158f4d66b5bd1644df40f150}{Shape\+Base\+::n\+Dim} by \hyperlink{classShapeBase_a0ae4246d158f4d66b5bd1644df40f150}{Shape\+Base\+::n\+Dim} matrix for each gauss point (there are 3 Gauss points for prisms). \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a37f25110de54965266cb29b66eaf5b81}{}std\+::array$<$ double, 6 $>$ \hyperlink{classShapeBase_a37f25110de54965266cb29b66eaf5b81}{detd\+Xdes}\label{classShapeBase_a37f25110de54965266cb29b66eaf5b81}

\begin{DoxyCompactList}\small\item\em The array stores the determinants of the matrices for derivatives of world coordinates with respect to barycentric coordinates (d\+X / de). The array stores a double value for each gauss point (there are 3 Gauss points for prisms). \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a04079b2f81481d44a9b3efb8916c8423}{}std\+::vector$<$ gsl\+\_\+matrix $\ast$ $>$ \hyperlink{classShapeBase_a04079b2f81481d44a9b3efb8916c8423}{Bmatrices}\label{classShapeBase_a04079b2f81481d44a9b3efb8916c8423}

\begin{DoxyCompactList}\small\item\em The array stores the B matrix for the calculation of stiffness matrix, see for \hyperlink{classShapeBase_ad67919694a1d780e31f6d539781377be}{Shape\+Base\+::calculate\+B\+Tfor\+Nodal\+Forces} calculation. The array stores an \hyperlink{classShapeBase_a0daa5629b1335ca3e1be089a006fe897}{Shape\+Base\+::n\+Nodes} by (\hyperlink{classShapeBase_a0ae4246d158f4d66b5bd1644df40f150}{Shape\+Base\+::n\+Dim}$\ast$\+Shape\+Base\hyperlink{classShapeBase_a0daa5629b1335ca3e1be089a006fe897}{n\+Nodes}) matrix for each Gauss point (there are 3 Gauss points for prisms). \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_aae6b0d0bc99f2c07986522fd866312ea}{}std\+::vector$<$ gsl\+\_\+matrix $\ast$ $>$ \hyperlink{classShapeBase_aae6b0d0bc99f2c07986522fd866312ea}{Fe\+Matrices}\label{classShapeBase_aae6b0d0bc99f2c07986522fd866312ea}

\begin{DoxyCompactList}\small\item\em The array stores the elastic part of the deformation matrix. The array stores an \hyperlink{classShapeBase_a0ae4246d158f4d66b5bd1644df40f150}{Shape\+Base\+::n\+Dim} by \hyperlink{classShapeBase_a0ae4246d158f4d66b5bd1644df40f150}{Shape\+Base\+::n\+Dim} matrix for each Gauss point (there are 6 Gauss points for prisms). \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a18ef46748c8632768c6be10987f1c0e3}{}std\+::vector$<$ gsl\+\_\+matrix $\ast$ $>$ \hyperlink{classShapeBase_a18ef46748c8632768c6be10987f1c0e3}{inv\+J\+Shape\+Func\+Der\+Stack}\label{classShapeBase_a18ef46748c8632768c6be10987f1c0e3}

\begin{DoxyCompactList}\small\item\em The array stores the shape function derivatives multiplied by the inverse Jacobian stack, for each Gauss point. See \hyperlink{classShapeBase_ad67919694a1d780e31f6d539781377be}{Shape\+Base\+::calculate\+B\+Tfor\+Nodal\+Forces} for calculation. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a90987ba8732360351b3994e6566c6093}{}std\+::vector$<$ gsl\+\_\+matrix $\ast$ $>$ \hyperlink{classShapeBase_a90987ba8732360351b3994e6566c6093}{inv\+J\+Shape\+Func\+Der\+Stackwith\+Fe}\label{classShapeBase_a90987ba8732360351b3994e6566c6093}

\begin{DoxyCompactList}\small\item\em See \hyperlink{classShapeBase_a8d984ddba5bbeae91cb3180897a5a3e7}{Shape\+Base\+::calculate\+Inv\+J\+Sh\+Func\+Der\+S\+With\+Fe} for calculation. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_adec28da3cbed6bf4aad8370bd5cdad81}{}std\+::vector$<$ gsl\+\_\+matrix $\ast$ $>$ \hyperlink{classShapeBase_adec28da3cbed6bf4aad8370bd5cdad81}{elastic\+Stress}\label{classShapeBase_adec28da3cbed6bf4aad8370bd5cdad81}

\begin{DoxyCompactList}\small\item\em The array of matrices for elastic stress of the element. The array stores a 6 by 6 matrix for each Gauss point (there are 6 Gauss points for prisms). \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a29f180dc41c5b6e12b9468dd557bb524}{}std\+::vector$<$ gsl\+\_\+matrix $\ast$ $>$ \hyperlink{classShapeBase_a29f180dc41c5b6e12b9468dd557bb524}{viscous\+Stress}\label{classShapeBase_a29f180dc41c5b6e12b9468dd557bb524}

\begin{DoxyCompactList}\small\item\em The array of matrices for internal viscous stress of the element. The array stores a 6 by 6 matrix for each Gauss point (there are 6 Gauss points for prisms). \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ab7ac8f14929ab37e8eae5fcaf93b18a8}{}gsl\+\_\+matrix $\ast$ \hyperlink{classShapeBase_ab7ac8f14929ab37e8eae5fcaf93b18a8}{Tri\+Point\+F}\label{classShapeBase_ab7ac8f14929ab37e8eae5fcaf93b18a8}

\begin{DoxyCompactList}\small\item\em The deformation matrix of the element resulting from iteration over all Gauss points. The dimensions of the matrix is \hyperlink{classShapeBase_a0ae4246d158f4d66b5bd1644df40f150}{Shape\+Base\+::n\+Dim} by \hyperlink{classShapeBase_a0ae4246d158f4d66b5bd1644df40f150}{Shape\+Base\+::n\+Dim}. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a94d201c88c73283f2e9711d1cc038e02}{}gsl\+\_\+matrix $\ast$ \hyperlink{classShapeBase_a94d201c88c73283f2e9711d1cc038e02}{Elemental\+Elastic\+System\+Forces}\label{classShapeBase_a94d201c88c73283f2e9711d1cc038e02}

\begin{DoxyCompactList}\small\item\em The matrix stores the elemental elastic forces. The dimensions of the matrix is \hyperlink{classShapeBase_a0daa5629b1335ca3e1be089a006fe897}{Shape\+Base\+::n\+Nodes} by \hyperlink{classShapeBase_a0ae4246d158f4d66b5bd1644df40f150}{Shape\+Base\+::n\+Dim}. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a54b5ebd33ad4ed5739c0431bf0d4346d}{}gsl\+\_\+matrix $\ast$ \hyperlink{classShapeBase_a54b5ebd33ad4ed5739c0431bf0d4346d}{Elemental\+Internal\+Viscous\+System\+Forces}\label{classShapeBase_a54b5ebd33ad4ed5739c0431bf0d4346d}

\begin{DoxyCompactList}\small\item\em The matrix stores the elemental internal viscous forces. The dimensions of the matrix is \hyperlink{classShapeBase_a0daa5629b1335ca3e1be089a006fe897}{Shape\+Base\+::n\+Nodes} by \hyperlink{classShapeBase_a0ae4246d158f4d66b5bd1644df40f150}{Shape\+Base\+::n\+Dim}. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a01d3d2738b44a003e08a6a6b96c0b91e}{}std\+::array$<$ double, 6 $>$ \hyperlink{classShapeBase_a01d3d2738b44a003e08a6a6b96c0b91e}{det\+Fs}\label{classShapeBase_a01d3d2738b44a003e08a6a6b96c0b91e}

\begin{DoxyCompactList}\small\item\em The array stores the determinant of the deformation matrix for each Gauss point. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a51a8101057e2771172a4716c128705d7}{}double \hyperlink{classShapeBase_a51a8101057e2771172a4716c128705d7}{Z\+Projected\+Basal\+Area}\label{classShapeBase_a51a8101057e2771172a4716c128705d7}

\begin{DoxyCompactList}\small\item\em The z-\/projected area of the basal surface of the element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_aa7043ddacbcd92480cb54467a2777627}{}double \hyperlink{classShapeBase_aa7043ddacbcd92480cb54467a2777627}{Z\+Projected\+Apical\+Area}\label{classShapeBase_aa7043ddacbcd92480cb54467a2777627}

\begin{DoxyCompactList}\small\item\em The z-\/projected area of the apical surface of the element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a2ae2b0b1dfd0672a39897e780d861254}{}double \hyperlink{classShapeBase_a2ae2b0b1dfd0672a39897e780d861254}{Basal\+Area}\label{classShapeBase_a2ae2b0b1dfd0672a39897e780d861254}

\begin{DoxyCompactList}\small\item\em The area of the basal surface of the element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_adb4227c13db7e34dd1af182d143af47b}{}double \hyperlink{classShapeBase_adb4227c13db7e34dd1af182d143af47b}{Apical\+Area}\label{classShapeBase_adb4227c13db7e34dd1af182d143af47b}

\begin{DoxyCompactList}\small\item\em The area of the apical surface of the element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ac29dcfc319798bd21b3bc2b50ac401c8}{}double \hyperlink{classShapeBase_ac29dcfc319798bd21b3bc2b50ac401c8}{exposed\+Lateral\+Area\+Apical\+Side}\label{classShapeBase_ac29dcfc319798bd21b3bc2b50ac401c8}

\begin{DoxyCompactList}\small\item\em The area of the element on a linker position, and has lateral sides exposed to outside of the tissue, on the apical side, therefore should feel external viscosity. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a3ba637ddf764ae673d616f7318270866}{}double \hyperlink{classShapeBase_a3ba637ddf764ae673d616f7318270866}{exposed\+Lateral\+Area\+Basal\+Side}\label{classShapeBase_a3ba637ddf764ae673d616f7318270866}

\begin{DoxyCompactList}\small\item\em The area of the element on a linker position, and has lateral sides exposed to outside of the tissue, on the basal side, therefore should feel external viscosity. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ab5dfa04e7a8c7f2c33bea431ca441674}{}bool \hyperlink{classShapeBase_ab5dfa04e7a8c7f2c33bea431ca441674}{element\+Has\+Exposed\+Apical\+Surface}\label{classShapeBase_ab5dfa04e7a8c7f2c33bea431ca441674}

\begin{DoxyCompactList}\small\item\em The boolean stating if the element has any apical surface exposed to the environment. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a194437fa296d9e12e58cc14fa8d66931}{}bool \hyperlink{classShapeBase_a194437fa296d9e12e58cc14fa8d66931}{element\+Has\+Exposed\+Basal\+Surface}\label{classShapeBase_a194437fa296d9e12e58cc14fa8d66931}

\begin{DoxyCompactList}\small\item\em The boolean stating if the element has any basal surface exposed to the environment. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a7987e6fc21a5035fc04558f1b366406a}{}int \hyperlink{classShapeBase_a7987e6fc21a5035fc04558f1b366406a}{exposed\+Apical\+Surface\+Node\+Ids} \mbox{[}3\mbox{]}\label{classShapeBase_a7987e6fc21a5035fc04558f1b366406a}

\begin{DoxyCompactList}\small\item\em The int array of size 3, listing the node I\+Ds of element that form the exposed apical surface. The I\+Ds are the node I\+Ds on the element (0-\/5 for prism), not the actual \hyperlink{classNode_a1bd379569cc1a8b96432e61971aed4d9}{Node\+::\+Id}. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a7bc7714f5622b21ec7fba51e1136803f}{}int \hyperlink{classShapeBase_a7bc7714f5622b21ec7fba51e1136803f}{exposed\+Basal\+Surface\+Node\+Ids} \mbox{[}3\mbox{]}\label{classShapeBase_a7bc7714f5622b21ec7fba51e1136803f}

\begin{DoxyCompactList}\small\item\em The int array of size 3, listing the node I\+Ds of element that form the exposed basal surface. The I\+Ds are the node I\+Ds on the element (0-\/5 for prism), not the actual \hyperlink{classNode_a1bd379569cc1a8b96432e61971aed4d9}{Node\+::\+Id}. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a2724f82bbf8c657c075826f953f0b7f2}{}int \hyperlink{classShapeBase_a2724f82bbf8c657c075826f953f0b7f2}{exposed\+Lateral\+Area\+Apical\+Side\+Node\+Ids} \mbox{[}4\mbox{]}\label{classShapeBase_a2724f82bbf8c657c075826f953f0b7f2}

\begin{DoxyCompactList}\small\item\em The int array of size 4, listing the node I\+Ds of element that form the lateral surface exposed apically. The I\+Ds are the node I\+Ds on the element (0-\/5 for prism), not the actual \hyperlink{classNode_a1bd379569cc1a8b96432e61971aed4d9}{Node\+::\+Id}. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a28b58f2840dd8ffd571c647534ad9f0b}{}int \hyperlink{classShapeBase_a28b58f2840dd8ffd571c647534ad9f0b}{exposed\+Lateral\+Area\+Basal\+Side\+Node\+Ids} \mbox{[}4\mbox{]}\label{classShapeBase_a28b58f2840dd8ffd571c647534ad9f0b}

\begin{DoxyCompactList}\small\item\em The int array of size 4, listing the node I\+Ds of element that form the lateral surface exposed basally. The I\+Ds are the node I\+Ds on the element (0-\/5 for prism), not the actual \hyperlink{classNode_a1bd379569cc1a8b96432e61971aed4d9}{Node\+::\+Id}. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a433035a8df676eec3fbac2e510d483b4}{}size\+\_\+t \hyperlink{classShapeBase_a433035a8df676eec3fbac2e510d483b4}{n\+Lateral\+Surface\+Area\+Node\+Number}\label{classShapeBase_a433035a8df676eec3fbac2e510d483b4}

\begin{DoxyCompactList}\small\item\em Number of nodes that form the lateral surfaces for the element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ad3795d719f61808a05327aa4e3cf0355}{}size\+\_\+t \hyperlink{classShapeBase_ad3795d719f61808a05327aa4e3cf0355}{n\+Surface\+Area\+Node\+Number}\label{classShapeBase_ad3795d719f61808a05327aa4e3cf0355}

\begin{DoxyCompactList}\small\item\em Number of nodes that form the apical/basal surfaces for the element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a525290b7f6921e964666d946b5d6774d}{}double \hyperlink{classShapeBase_a525290b7f6921e964666d946b5d6774d}{stiffness\+Perturbation\+Rate\+In\+Sec}\label{classShapeBase_a525290b7f6921e964666d946b5d6774d}

\begin{DoxyCompactList}\small\item\em The rate at which the stiffness of the element will be perturbed, used with the model inputs from \char`\"{}\+Stiffness\+\_\+\+Perturbation\+:\char`\"{} header in model input file. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a9988f025f39118d8d29696709e6660d6}{}double \hyperlink{classShapeBase_a9988f025f39118d8d29696709e6660d6}{minimum\+Value\+Of\+Stiffness\+Multiplier}\label{classShapeBase_a9988f025f39118d8d29696709e6660d6}

\begin{DoxyCompactList}\small\item\em The lower bound of stiffness modification multiplier, exists to prevent elements reaching unintended zero or negative stiffness values. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a915634dcedd74abf27fd746758bfe935}{}double \hyperlink{classShapeBase_a915634dcedd74abf27fd746758bfe935}{maximum\+Value\+Of\+Stiffness\+Multiplier}\label{classShapeBase_a915634dcedd74abf27fd746758bfe935}

\begin{DoxyCompactList}\small\item\em The upper bound of stiffness modification multiplier, exists to prevent elements reaching unrealistic hard stiffness values. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a35ee77fed372f7702889bebb67875136}{}double \hyperlink{classShapeBase_a35ee77fed372f7702889bebb67875136}{mutation\+Growth\+Rate\+Per\+Sec}\label{classShapeBase_a35ee77fed372f7702889bebb67875136}

\begin{DoxyCompactList}\small\item\em The growth rate set by a mutant clone covering this element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ac7b83cb76a8f4ec11a4a6292c2899ba2}{}double \hyperlink{classShapeBase_ac7b83cb76a8f4ec11a4a6292c2899ba2}{mutation\+Growth\+Fold}\label{classShapeBase_ac7b83cb76a8f4ec11a4a6292c2899ba2}

\begin{DoxyCompactList}\small\item\em The rate of fold change in growth rate set by a mutant clone covering this element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a1878efccfc629e53748e8907386825b0}{}gsl\+\_\+matrix $\ast$ \hyperlink{classShapeBase_a1878efccfc629e53748e8907386825b0}{D}\label{classShapeBase_a1878efccfc629e53748e8907386825b0}

\begin{DoxyCompactList}\small\item\em elasticity tensor for Kirshoff material \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a7266beef6c849298c3786a53259bd467}{}gsl\+\_\+matrix $\ast$ \hyperlink{classShapeBase_a7266beef6c849298c3786a53259bd467}{Coeff\+Mat}\label{classShapeBase_a7266beef6c849298c3786a53259bd467}

\begin{DoxyCompactList}\small\item\em The coefficient matrix relating the shape function derivative stack to the Voigt notation of elemental stress nad strain. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ad90cb382c78aa293d53bb027f84fe04b}{}std\+::vector$<$ std\+::array$<$ std\+::array$<$ std\+::array$<$ std\+::array$<$ double, 3 $>$, 3 $>$, 3 $>$, 3 $>$ $>$ \hyperlink{classShapeBase_ad90cb382c78aa293d53bb027f84fe04b}{D81}\label{classShapeBase_ad90cb382c78aa293d53bb027f84fe04b}

\begin{DoxyCompactList}\small\item\em Lagrangian elasticity tensor, vector for the number of Gauss points in simulaiton. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a6c1a3a0173841d6072a5268978463ff2}{}double \hyperlink{classShapeBase_a6c1a3a0173841d6072a5268978463ff2}{E}\label{classShapeBase_a6c1a3a0173841d6072a5268978463ff2}

\begin{DoxyCompactList}\small\item\em Young\textquotesingle{}s modulus of the element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a8b4c2d3bfbc6c9785c5181a56f929151}{}double \hyperlink{classShapeBase_a8b4c2d3bfbc6c9785c5181a56f929151}{v}\label{classShapeBase_a8b4c2d3bfbc6c9785c5181a56f929151}

\begin{DoxyCompactList}\small\item\em Poisson\textquotesingle{}s ratio of the element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a7fd0830ee5d4e64bb68e58aa77736757}{}double \hyperlink{classShapeBase_a7fd0830ee5d4e64bb68e58aa77736757}{internal\+Viscosity}\label{classShapeBase_a7fd0830ee5d4e64bb68e58aa77736757}

\begin{DoxyCompactList}\small\item\em Current internal viscosity of the element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a5abc42a65cd840e1c65a1a026aa3bb65}{}double \hyperlink{classShapeBase_a5abc42a65cd840e1c65a1a026aa3bb65}{original\+Internal\+Viscosity}\label{classShapeBase_a5abc42a65cd840e1c65a1a026aa3bb65}

\begin{DoxyCompactList}\small\item\em The internal viscosity of the element at the beginning of the simulation, prior to physical property perturbations. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_aa16b41d5791fc15531cbee067c502a5d}{}double \hyperlink{classShapeBase_aa16b41d5791fc15531cbee067c502a5d}{lambda}\label{classShapeBase_aa16b41d5791fc15531cbee067c502a5d}

\begin{DoxyCompactList}\small\item\em Lame\textquotesingle{}s second parameter, driven from Young\textquotesingle{}s modulus and Poisson\textquotesingle{}s ratio of the element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ac5819d0d117e5510611259177c477af8}{}double \hyperlink{classShapeBase_ac5819d0d117e5510611259177c477af8}{mu}\label{classShapeBase_ac5819d0d117e5510611259177c477af8}

\begin{DoxyCompactList}\small\item\em Sheer modulus of the element. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_afe7cb600a9316597a16512ab7b6fcd6f}{}gsl\+\_\+matrix $\ast$ \hyperlink{classShapeBase_afe7cb600a9316597a16512ab7b6fcd6f}{Inv\+Fg}\label{classShapeBase_afe7cb600a9316597a16512ab7b6fcd6f}

\begin{DoxyCompactList}\small\item\em Inverse of growth matrix. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a08d7f6e8f098a7b5985c615842062014}{}gsl\+\_\+matrix $\ast$ \hyperlink{classShapeBase_a08d7f6e8f098a7b5985c615842062014}{Fsc}\label{classShapeBase_a08d7f6e8f098a7b5985c615842062014}

\begin{DoxyCompactList}\small\item\em Shape change matrix. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ad72828aab0668c993f57727123aa96be}{}gsl\+\_\+matrix $\ast$ \hyperlink{classShapeBase_ad72828aab0668c993f57727123aa96be}{Inv\+Fsc}\label{classShapeBase_ad72828aab0668c993f57727123aa96be}

\begin{DoxyCompactList}\small\item\em Inverse of shape change matrix. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_ace20710f27099833509c474b221c25df}{}gsl\+\_\+matrix $\ast$ \hyperlink{classShapeBase_ace20710f27099833509c474b221c25df}{Tri\+Point\+Ke}\label{classShapeBase_ace20710f27099833509c474b221c25df}

\begin{DoxyCompactList}\small\item\em Current elastic part of the Jacobian (stiffness matrix) of the system, averaged over all Gauss Points. \end{DoxyCompactList}\item 
\hypertarget{classShapeBase_a7fa5b1338e405a2c75c8d010f4153b05}{}gsl\+\_\+matrix $\ast$ \hyperlink{classShapeBase_a7fa5b1338e405a2c75c8d010f4153b05}{Tri\+Point\+Kv}\label{classShapeBase_a7fa5b1338e405a2c75c8d010f4153b05}

\begin{DoxyCompactList}\small\item\em Current viscous part of the Jacobian of the system, averaged over all Gauss Points. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Constructor \& Destructor Documentation}
\hypertarget{classShapeBase_af919db3ff5e6a6d4a137cf4625189c23}{}\index{Shape\+Base@{Shape\+Base}!````~Shape\+Base@{$\sim$\+Shape\+Base}}
\index{````~Shape\+Base@{$\sim$\+Shape\+Base}!Shape\+Base@{Shape\+Base}}
\subsubsection[{$\sim$\+Shape\+Base}]{\setlength{\rightskip}{0pt plus 5cm}virtual Shape\+Base\+::$\sim$\+Shape\+Base (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classShapeBase_af919db3ff5e6a6d4a137cf4625189c23}
The \hyperlink{classShapeBase}{Shape\+Base} destructor. This destructor should not be called uner healthy conditions. 

\subsection{Member Function Documentation}
\hypertarget{classShapeBase_a2e8e11261fb35bc925259151218eebf3}{}\index{Shape\+Base@{Shape\+Base}!add\+To\+Tri\+Point\+Ke@{add\+To\+Tri\+Point\+Ke}}
\index{add\+To\+Tri\+Point\+Ke@{add\+To\+Tri\+Point\+Ke}!Shape\+Base@{Shape\+Base}}
\subsubsection[{add\+To\+Tri\+Point\+Ke}]{\setlength{\rightskip}{0pt plus 5cm}void Shape\+Base\+::add\+To\+Tri\+Point\+Ke (
\begin{DoxyParamCaption}
\item[{int}]{i, }
\item[{int}]{j, }
\item[{double}]{value}
\end{DoxyParamCaption}
)}\label{classShapeBase_a2e8e11261fb35bc925259151218eebf3}


This function is to add the input value, to the (i,j)th element of the Elemental\+Elastic\+System\+Forces. 

This funciton adds the input value to the elemental stiffness matrix, elastic part of the elemental Jacobian, \hyperlink{classShapeBase_ace20710f27099833509c474b221c25df}{Shape\+Base\+::\+Tri\+Point\+Ke}, at the input indices (i,j).\hypertarget{classShapeBase_a9b249ac3da27e7eeb6e0604a76f15faf}{}\index{Shape\+Base@{Shape\+Base}!calculate3\+D\+Rot\+Mat\+From\+F@{calculate3\+D\+Rot\+Mat\+From\+F}}
\index{calculate3\+D\+Rot\+Mat\+From\+F@{calculate3\+D\+Rot\+Mat\+From\+F}!Shape\+Base@{Shape\+Base}}
\subsubsection[{calculate3\+D\+Rot\+Mat\+From\+F}]{\setlength{\rightskip}{0pt plus 5cm}bool Shape\+Base\+::calculate3\+D\+Rot\+Mat\+From\+F (
\begin{DoxyParamCaption}
\item[{gsl\+\_\+matrix $\ast$}]{rot\+Mat}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classShapeBase_a9b249ac3da27e7eeb6e0604a76f15faf}


This function dissects the deformation gradient of the element into the rigid body rotation and deformation. 

The rigid body rotation is extracted via single value decomposition.

The decomposition isdone by the gsl routine gsl\+\_\+linalg\+\_\+\+S\+V\+\_\+decomp, and here, the output gives Sgsl as $ \mathbf{U} $ , the rotation matrix $ \mathbf{U} \mathbf{V}^{T} $ in the decomposition $ \mathbf{A} = \mathbf{U} \mathbf{S} \mathbf{V}^{T} $\hypertarget{classShapeBase_ae09cb91359e10677889c3f59c3f5d70a}{}\index{Shape\+Base@{Shape\+Base}!calculate\+Cauchy\+Green\+Deformation\+Tensor@{calculate\+Cauchy\+Green\+Deformation\+Tensor}}
\index{calculate\+Cauchy\+Green\+Deformation\+Tensor@{calculate\+Cauchy\+Green\+Deformation\+Tensor}!Shape\+Base@{Shape\+Base}}
\subsubsection[{calculate\+Cauchy\+Green\+Deformation\+Tensor}]{\setlength{\rightskip}{0pt plus 5cm}gsl\+\_\+matrix $\ast$ Shape\+Base\+::calculate\+Cauchy\+Green\+Deformation\+Tensor (
\begin{DoxyParamCaption}
\item[{gsl\+\_\+matrix $\ast$}]{Fe}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classShapeBase_ae09cb91359e10677889c3f59c3f5d70a}


This function calculates the Caucy-\/\+Green deformation tensor, from the elastic part of the deformation gradient. 

The Cauchy Green deformation Tensor $ \mathbf{C} $ is defned as\+: ~\newline
 $ \mathbf{C} = \left( \mathbf{F}^{eT} \mathbf{F}^{e} \right) $ where $ \mathbf{F}^{e} $ is the elastic part of the deformation gradient.\hypertarget{classShapeBase_a56e588bb8d290158200c6e35826f7566}{}\index{Shape\+Base@{Shape\+Base}!calculate\+Compact\+Stress\+For\+Nodal\+Forces@{calculate\+Compact\+Stress\+For\+Nodal\+Forces}}
\index{calculate\+Compact\+Stress\+For\+Nodal\+Forces@{calculate\+Compact\+Stress\+For\+Nodal\+Forces}!Shape\+Base@{Shape\+Base}}
\subsubsection[{calculate\+Compact\+Stress\+For\+Nodal\+Forces}]{\setlength{\rightskip}{0pt plus 5cm}gsl\+\_\+matrix $\ast$ Shape\+Base\+::calculate\+Compact\+Stress\+For\+Nodal\+Forces (
\begin{DoxyParamCaption}
\item[{double}]{det\+Fe, }
\item[{gsl\+\_\+matrix $\ast$}]{Fe, }
\item[{gsl\+\_\+matrix $\ast$}]{S, }
\item[{gsl\+\_\+matrix $\ast$}]{Stress}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classShapeBase_a56e588bb8d290158200c6e35826f7566}


This function calculates elemental stress in Voigt notation. 

Stress is calculated via\+: ~\newline
 $ \mathbf{\sigma}^e = J^{e-1} \mathbf{F}^{e} \mathbf{S}^{e} \mathbf{F}^{eT} $\hypertarget{classShapeBase_a58ffd31ed76797d558b085fe754cc4b3}{}\index{Shape\+Base@{Shape\+Base}!calculate\+Current\+Grown\+And\+Emergent\+Volumes@{calculate\+Current\+Grown\+And\+Emergent\+Volumes}}
\index{calculate\+Current\+Grown\+And\+Emergent\+Volumes@{calculate\+Current\+Grown\+And\+Emergent\+Volumes}!Shape\+Base@{Shape\+Base}}
\subsubsection[{calculate\+Current\+Grown\+And\+Emergent\+Volumes}]{\setlength{\rightskip}{0pt plus 5cm}double Shape\+Base\+::calculate\+Current\+Grown\+And\+Emergent\+Volumes (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classShapeBase_a58ffd31ed76797d558b085fe754cc4b3}


This is the function to calculate hte current ideal volume of the element and its current apparent volume. 

Once the reference volume is calculated, the current prefered volume is obtained by scaling the reference shape volume by the determinant of the growth deformation gradinet \hyperlink{classShapeBase_a4156d7c7f91f0b528214b74277279df0}{Shape\+Base\+::\+Fg}. On the other hand, current emergent volume is the deformed volume and should be obtained by scaling the reference volume with the determinant of the total deformation gradient, including both growth and deformation.\hypertarget{classShapeBase_a347fb2687678294a252a12820842cb0d}{}\index{Shape\+Base@{Shape\+Base}!calculate\+E\+For\+Nodal\+Forces\+Kirshoff@{calculate\+E\+For\+Nodal\+Forces\+Kirshoff}}
\index{calculate\+E\+For\+Nodal\+Forces\+Kirshoff@{calculate\+E\+For\+Nodal\+Forces\+Kirshoff}!Shape\+Base@{Shape\+Base}}
\subsubsection[{calculate\+E\+For\+Nodal\+Forces\+Kirshoff}]{\setlength{\rightskip}{0pt plus 5cm}gsl\+\_\+matrix $\ast$ Shape\+Base\+::calculate\+E\+For\+Nodal\+Forces\+Kirshoff (
\begin{DoxyParamCaption}
\item[{gsl\+\_\+matrix $\ast$}]{C}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classShapeBase_a347fb2687678294a252a12820842cb0d}


This function calculates the green strains for a Kirshoff material model. 

$ \mathbf{E} $ for Kirshoff material is\+: ~\newline
 $ \mathbf{E} = \frac{1}{2} \times \left( \mathbf{C}- \mathbf{I} \right) $ where $ \mathbf{C} $ is the Cauchy Green deformation Tensor calculated in \hyperlink{classShapeBase_ae09cb91359e10677889c3f59c3f5d70a}{Shape\+Base\+::calculate\+Cauchy\+Green\+Deformation\+Tensor} and $ \mathbf{I} $ is identity.\hypertarget{classShapeBase_a3eecbff8db98871f4b5f1ee0992f3d6d}{}\index{Shape\+Base@{Shape\+Base}!calculate\+Emergent\+Shape\+Orientation@{calculate\+Emergent\+Shape\+Orientation}}
\index{calculate\+Emergent\+Shape\+Orientation@{calculate\+Emergent\+Shape\+Orientation}!Shape\+Base@{Shape\+Base}}
\subsubsection[{calculate\+Emergent\+Shape\+Orientation}]{\setlength{\rightskip}{0pt plus 5cm}double Shape\+Base\+::calculate\+Emergent\+Shape\+Orientation (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classShapeBase_a3eecbff8db98871f4b5f1ee0992f3d6d}


This fucntion calculates the orientation of the emergent shape of an element in the xy plane of the tissue. 

The function calculates in which direction the emergent shape is oriented. We need to have the combination of growth gradient and deformation gradient. It will reflect how the clones would \char`\"{}look\char`\"{}\+:

We keep a copy of the original \hyperlink{classShapeBase_a4bda00f80968d836c647afe5f6d1fb36}{Shape\+Base\+::\+Strain} to utilise the Strain matrix in eigen value decomposition.

Calculated by the funciton \hyperlink{classShapeBase_a6fe833f9684db5cc1847761b6bbd9aa9}{Shape\+Base\+::calculate\+Principal\+Strains2\+D}, the Eigen vector matrix is a 3 by 3 matrix, but only stores the 2\+D vectors in its upper corner 2x2 terms. The vectors are written in columns of the matrix. The strain I have here is Green strain, I would like to convert it back to deformation gradient terms. Since $ E = 1/2 *(Fe^T*Fe-I): $ $ F_{ii} = \sqrt{e_{i} \times 2 + 1} $

Then with the aspect ratio, the emergent long and short axes are calculated.

Finally, the original \hyperlink{classShapeBase_a4bda00f80968d836c647afe5f6d1fb36}{Shape\+Base\+::\+Strain} are copied over back to the Strains matrix

The function returns the volumentric strain (ratio of emergent volume to reference shape volume) as autput.\hypertarget{classShapeBase_a23ed61e92393b0d7364a4a99ac0f77f9}{}\index{Shape\+Base@{Shape\+Base}!calculate\+Fg\+From\+Grid\+Corners@{calculate\+Fg\+From\+Grid\+Corners}}
\index{calculate\+Fg\+From\+Grid\+Corners@{calculate\+Fg\+From\+Grid\+Corners}!Shape\+Base@{Shape\+Base}}
\subsubsection[{calculate\+Fg\+From\+Grid\+Corners}]{\setlength{\rightskip}{0pt plus 5cm}void Shape\+Base\+::calculate\+Fg\+From\+Grid\+Corners (
\begin{DoxyParamCaption}
\item[{int}]{grid\+Growths\+Interpolation\+Type, }
\item[{double}]{dt, }
\item[{{\bf Growth\+Function\+Base} $\ast$}]{curr\+G\+F, }
\item[{gsl\+\_\+matrix $\ast$}]{increment, }
\item[{int}]{source\+Tissue, }
\item[{int}]{Index\+X, }
\item[{int}]{Index\+Y, }
\item[{double}]{Frac\+X, }
\item[{double}]{d\+Frac\+Y}
\end{DoxyParamCaption}
)}\label{classShapeBase_a23ed61e92393b0d7364a4a99ac0f77f9}


This fucntion will calculate the incremental growth deformation gradient change for the current time step by reading it from the grid, and interpolating on 4 corners. 

The current growth deformation gradient increment is calculated from the input growth magnitude and rotations map in a grid ~\newline
 First check point is for cheking if the growth function is applicable to the element, via \hyperlink{classShapeBase_aa0f0cc5b33f3e12d91a246cc591c346c}{Shape\+Base\+::is\+Growth\+Rate\+Applicable}. If the element is growing, the four corners of the grid that are closest to the relative position of the element are extracted from the input grid. The growth rates are obtained at four the corners via the function Growth\+Base\+::get\+Growth\+Profile\+At4\+Corners. Depending on th einterpolation method chosen, the growth of the point can be mapped to the closest corner, or can be interpolated between the points depending on the distance the relative position of the element centre falls within the grid\+: ~\newline
\begin{DoxyVerb}       [point 2] ------------- [point 3]
          |                        |
          |<--fracX----> (o)       |
          |               |        |
          |               |        |
          |             fracY      |
          |               |        |
       [point 0] ------------- [point 1]
\end{DoxyVerb}


In the interpolation schenario, the angles are checked and for the corners that have an aspect ratio over the threshold the angle is included in the averaging.

A linera interpolation with the distances are carried out for teh growth rates and orientation angles\+:

If the element is \hyperlink{classShapeBase_a892e478508ed8a375f0816b330e36ac1}{Shape\+Base\+::is\+Actin\+Mimicing}, then growth in the tissue height is ignored.

Then growth is scaled if there is any distribution of tissue volume in z axis, thourgh \hyperlink{classShapeBase_aace7f6727db271b84db82d0560d26b86}{Shape\+Base\+::scale\+Growth\+For\+Z\+Redistribution}.\hypertarget{classShapeBase_a45508a35016a845b9c3b2d8f7d51479a}{}\index{Shape\+Base@{Shape\+Base}!calculate\+Fg\+From\+Rates@{calculate\+Fg\+From\+Rates}}
\index{calculate\+Fg\+From\+Rates@{calculate\+Fg\+From\+Rates}!Shape\+Base@{Shape\+Base}}
\subsubsection[{calculate\+Fg\+From\+Rates}]{\setlength{\rightskip}{0pt plus 5cm}void Shape\+Base\+::calculate\+Fg\+From\+Rates (
\begin{DoxyParamCaption}
\item[{double}]{dt, }
\item[{double}]{x, }
\item[{double}]{y, }
\item[{double}]{z, }
\item[{gsl\+\_\+matrix $\ast$}]{rot\+Mat, }
\item[{gsl\+\_\+matrix $\ast$}]{increment, }
\item[{int}]{source\+Tissue, }
\item[{double}]{z\+Min, }
\item[{double}]{z\+Max}
\end{DoxyParamCaption}
)}\label{classShapeBase_a45508a35016a845b9c3b2d8f7d51479a}


This fucntion will calculate the incremental growth deformation gradient change for the current time step, from input growth rates. 

The current growth deformation gradient increment is calculated from rates and rotation.~\newline
First check point is for cheking if the growth function is applicable to the element, via \hyperlink{classShapeBase_aa0f0cc5b33f3e12d91a246cc591c346c}{Shape\+Base\+::is\+Growth\+Rate\+Applicable}. If the element is growing, the diagonal of the growth increment is obtained. Then the increment is rotated with a tensor rotation (M\textquotesingle{} = R M R$^\wedge$\+T), using the input rotation matrix.\hypertarget{classShapeBase_a1afbb15d92215f337090262753eb24ab}{}\index{Shape\+Base@{Shape\+Base}!calculate\+Forces3\+D@{calculate\+Forces3\+D}}
\index{calculate\+Forces3\+D@{calculate\+Forces3\+D}!Shape\+Base@{Shape\+Base}}
\subsubsection[{calculate\+Forces3\+D}]{\setlength{\rightskip}{0pt plus 5cm}void Shape\+Base\+::calculate\+Forces3\+D (
\begin{DoxyParamCaption}
\item[{const std\+::vector$<$ std\+::unique\+\_\+ptr$<$ {\bf Node} $>$$>$ \&}]{Nodes, }
\item[{gsl\+\_\+matrix $\ast$}]{displacement\+Per\+Dt}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classShapeBase_a1afbb15d92215f337090262753eb24ab}


The function calculates the viscous and elastic forces generated by the element. 

The nodal forces are calculated as an average of all Gauss Points. The number of Gauss Points and their weights are stored in \hyperlink{classShapeBase_a5c80fec4188317146cb31b74c36c7640}{Shape\+Base\+::number\+Of\+Gauss\+Points} and \hyperlink{classShapeBase_a50ec0d74748313a30a280258bd1e1827}{Shape\+Base\+::gauss\+Weights}, respectively. The order of points weights should be consistent with point definition order in shape function derivative calculation. The nodal forces for the selected Gauss point are calculated via \hyperlink{classShapeBase_acca6ea9484bbc995d941f1a7bb25e1db}{Shape\+Base\+::calculate\+Curr\+Nodal\+Forces}. Then the output nodal elastic forces, viscous forces, and the deformation gradient are scaled with weights.

Then the elemental forces are written on the system forces.\hypertarget{classShapeBase_a9ae4c5fc8817528493502e3f75c9a984}{}\index{Shape\+Base@{Shape\+Base}!Calculate\+Growth\+Rotation\+By\+F@{Calculate\+Growth\+Rotation\+By\+F}}
\index{Calculate\+Growth\+Rotation\+By\+F@{Calculate\+Growth\+Rotation\+By\+F}!Shape\+Base@{Shape\+Base}}
\subsubsection[{Calculate\+Growth\+Rotation\+By\+F}]{\setlength{\rightskip}{0pt plus 5cm}void Shape\+Base\+::\+Calculate\+Growth\+Rotation\+By\+F (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classShapeBase_a9ae4c5fc8817528493502e3f75c9a984}


This function calculates the rigid body rotation of the element around the z axis of the tissue from hte fecormation gradient. 

The rigid body rotation is extracted from the deformation gradient, and the rotation around the z-\/axis is stored. The disassembling of the rigid body rotation is carried out via \hyperlink{classShapeBase_a91a660608ede71c5bfdd1c4956843760}{Shape\+Base\+::disassemble\+Rotation\+Matrix\+For\+Z}.\hypertarget{classShapeBase_a20c23d30b7f9f3bc7ed2fde542401aeb}{}\index{Shape\+Base@{Shape\+Base}!calculate\+Implicit\+K\+Viscous@{calculate\+Implicit\+K\+Viscous}}
\index{calculate\+Implicit\+K\+Viscous@{calculate\+Implicit\+K\+Viscous}!Shape\+Base@{Shape\+Base}}
\subsubsection[{calculate\+Implicit\+K\+Viscous}]{\setlength{\rightskip}{0pt plus 5cm}void Shape\+Base\+::calculate\+Implicit\+K\+Viscous (
\begin{DoxyParamCaption}
\item[{gsl\+\_\+matrix $\ast$}]{displacement\+Per\+Dt, }
\item[{double}]{dt}
\end{DoxyParamCaption}
)}\label{classShapeBase_a20c23d30b7f9f3bc7ed2fde542401aeb}


This function calculates the elemental viscous component of the Jacobian for implicit N\+R itaration. 

The viscous part of the elemental Jacobian will be calculated over the sum of two integrals, via \hyperlink{classShapeBase_a5cdcb5b445291f28d3ed3d83c582f534}{Shape\+Base\+::calculate\+Viscous\+K\+Integral1} and \hyperlink{classShapeBase_a9795e5aad1361070df5ecdd735d9361b}{Shape\+Base\+::calculate\+Viscous\+K\+Integral2}. The inputs are\+: ~\newline
1) the displacement between the current N-\/\+R iteration positions $ \mathbf{u}_k^{t+\Delta t} $ and the nodal positions at teh end of previous step $ \mathbf{u}_n^{t} $. ~\newline
2) the time step, $ \Delta t $. ~\newline
The calculation is carried out over all Gauss Points.\hypertarget{classShapeBase_aa1c9eda4ef1eb0b23620235039bab921}{}\index{Shape\+Base@{Shape\+Base}!calculate\+Plastic\+Deformation3\+D@{calculate\+Plastic\+Deformation3\+D}}
\index{calculate\+Plastic\+Deformation3\+D@{calculate\+Plastic\+Deformation3\+D}!Shape\+Base@{Shape\+Base}}
\subsubsection[{calculate\+Plastic\+Deformation3\+D}]{\setlength{\rightskip}{0pt plus 5cm}void Shape\+Base\+::calculate\+Plastic\+Deformation3\+D (
\begin{DoxyParamCaption}
\item[{bool}]{volume\+Conserved, }
\item[{double}]{dt, }
\item[{double}]{plastic\+Deformation\+Half\+Life, }
\item[{double}]{z\+Remodelling\+Lower\+Threshold, }
\item[{double}]{z\+Remodelling\+Upper\+Threshold}
\end{DoxyParamCaption}
)}\label{classShapeBase_aa1c9eda4ef1eb0b23620235039bab921}


This function calculates the plastic deformation (remodelling) from the current elastic deformation gradient. 

This function calculates the plastic deformation (remodelling) from the current elastic deformation gradient. First check is against tissue specific compartments and z remodelling capping. The linker zone of the tissue and E\+C\+M mimicking elements should be able to remodell in z regardless of currently active caps.

The princiapl starins on the element are then calculated bie eigen vsalue decomposition via \hyperlink{classShapeBase_a3cde54fe712bac297fa73949d07c1bd4}{Shape\+Base\+::calculate\+Principal\+Strains3\+D}.

This gives the green strain in principal direction in the orientation of the element internal coordinates. One can simply grow the element in this axis, to obtain some form of plastic deformation/remodelling. Now the Green stains need to be converted to deformation gradient terms. Since $ E = 1/2 *(Fe^T*Fe-I): $ $ F_{ii} = \sqrt{e_{i} \times 2 + 1} $

Then remodelling with a decay half-\/life Shape\+Base\+::plastic\+Deformation\+Half\+Life becomes\+: ~\newline
 $ N(t+\Delta t) = N(t) * 2 ^ (-\Delta t/\tau_{1/2}) $ where $ \tau_{1/2} = plasticDeformationHalfLifeMultiplier * plasticDeformationHalfLife/(log(2)) $. Here the multiplier term reflects perturbations.

The obtained remodelling increment is then checked against capping in z remodelling via \hyperlink{classShapeBase_a2e7fdc8e749b8b709b6c80248dc2bc3f}{Shape\+Base\+::check\+Z\+Capping\+In\+Remodelling}.

If there is z capping the procedure is repeated in 2\+D, with the strains calculated via \hyperlink{classShapeBase_a6fe833f9684db5cc1847761b6bbd9aa9}{Shape\+Base\+::calculate\+Principal\+Strains2\+D}.

If hte volume is conserved, the incremeent is sclaed to have a determinant of unity.

The total z remodelling up to the current time step (\hyperlink{classShapeBase_a0dc566eb70e64da9fc3fa222b16999da}{Shape\+Base\+::z\+Remodelling\+So\+Far}) is then updated for z remodelling capping checks in following time points.\hypertarget{classShapeBase_afbbf191777e8787a0e8307d30ce0aa9d}{}\index{Shape\+Base@{Shape\+Base}!calculate\+Rate\+Of\+Deformation\+Tensor@{calculate\+Rate\+Of\+Deformation\+Tensor}}
\index{calculate\+Rate\+Of\+Deformation\+Tensor@{calculate\+Rate\+Of\+Deformation\+Tensor}!Shape\+Base@{Shape\+Base}}
\subsubsection[{calculate\+Rate\+Of\+Deformation\+Tensor}]{\setlength{\rightskip}{0pt plus 5cm}gsl\+\_\+matrix $\ast$ Shape\+Base\+::calculate\+Rate\+Of\+Deformation\+Tensor (
\begin{DoxyParamCaption}
\item[{gsl\+\_\+matrix $\ast$}]{l}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classShapeBase_afbbf191777e8787a0e8307d30ce0aa9d}


This function will calculate rate of deformation tensor from velocity gradient tensor. 

Inputs\+:
\begin{DoxyEnumerate}
\item The velocity gradient tensor given in Voigt notation (6 x 1).
\end{DoxyEnumerate}

Output\+:
\begin{DoxyEnumerate}
\item Rate of deformation tensor (3 x 3).
\end{DoxyEnumerate}

This function primarily rearranges the elements of the velocity gradient tensor given in Voigt notation, to from the rate of deformation tensor

Procedure\+:
\begin{DoxyItemize}
\item Allocate the memory for rate of deformation tensor
\item Write the terms of velocity gradient tensor into rate of deformation tensor
\item Return rate of deformation tensor
\end{DoxyItemize}\hypertarget{classShapeBase_a9c79b3bced80eac8af18a0a81d3898ab}{}\index{Shape\+Base@{Shape\+Base}!calculate\+S\+For\+Nodal\+Forces\+Kirshoff@{calculate\+S\+For\+Nodal\+Forces\+Kirshoff}}
\index{calculate\+S\+For\+Nodal\+Forces\+Kirshoff@{calculate\+S\+For\+Nodal\+Forces\+Kirshoff}!Shape\+Base@{Shape\+Base}}
\subsubsection[{calculate\+S\+For\+Nodal\+Forces\+Kirshoff}]{\setlength{\rightskip}{0pt plus 5cm}gsl\+\_\+matrix $\ast$ Shape\+Base\+::calculate\+S\+For\+Nodal\+Forces\+Kirshoff (
\begin{DoxyParamCaption}
\item[{gsl\+\_\+matrix $\ast$}]{E}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classShapeBase_a9c79b3bced80eac8af18a0a81d3898ab}


This function calculates the Secons order Piola-\/\+Kirshoff stress tensor for Kirshoff material model. 

The Second order Piola-\/ Kirshoff Stress Tensor $ \mathbf{S} $ for Kirshoff material is\+: ~\newline
 $ \mathbf{S} = \mathbf{D}: \mathbf{E} $ where $ \mathbf{E} $ is calculated in \hyperlink{classShapeBase_a347fb2687678294a252a12820842cb0d}{Shape\+Base\+::calculate\+E\+For\+Nodal\+Forces\+Kirshoff} and $ \mathbf{D} $ is \hyperlink{classShapeBase_a1878efccfc629e53748e8907386825b0}{Shape\+Base\+::\+D}.\hypertarget{classShapeBase_a697f24754441df216b4245e7eb467b13}{}\index{Shape\+Base@{Shape\+Base}!calculate\+S\+For\+Nodal\+Forces\+Neo\+Hookean@{calculate\+S\+For\+Nodal\+Forces\+Neo\+Hookean}}
\index{calculate\+S\+For\+Nodal\+Forces\+Neo\+Hookean@{calculate\+S\+For\+Nodal\+Forces\+Neo\+Hookean}!Shape\+Base@{Shape\+Base}}
\subsubsection[{calculate\+S\+For\+Nodal\+Forces\+Neo\+Hookean}]{\setlength{\rightskip}{0pt plus 5cm}gsl\+\_\+matrix $\ast$ Shape\+Base\+::calculate\+S\+For\+Nodal\+Forces\+Neo\+Hookean (
\begin{DoxyParamCaption}
\item[{gsl\+\_\+matrix $\ast$}]{inv\+C, }
\item[{double}]{ln\+J}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classShapeBase_a697f24754441df216b4245e7eb467b13}


This function calculates the Secons order Piola-\/\+Kirshoff stress tensor for Neo-\/\+Hookean material model.\+v. 

The Second order Piola-\/ Kirshoff Stress Tensor for a Neo-\/\+Hookean material is\+: $ \mathbf{S}^e = \mu (\mathbf {I} - \mathbf {C^{-1}}) + \lambda (ln J^e) \mathbf {C^{-1}} $\hypertarget{classShapeBase_aef460b84dc469f89742af7c19411454f}{}\index{Shape\+Base@{Shape\+Base}!calculate\+Stiffness\+Perturbation\+Rate@{calculate\+Stiffness\+Perturbation\+Rate}}
\index{calculate\+Stiffness\+Perturbation\+Rate@{calculate\+Stiffness\+Perturbation\+Rate}!Shape\+Base@{Shape\+Base}}
\subsubsection[{calculate\+Stiffness\+Perturbation\+Rate}]{\setlength{\rightskip}{0pt plus 5cm}void Shape\+Base\+::calculate\+Stiffness\+Perturbation\+Rate (
\begin{DoxyParamCaption}
\item[{bool}]{There\+Is\+Basolateral\+With\+Apical\+Relaxation\+Stiffness\+Perturbation, }
\item[{double}]{stiffness\+Perturbation\+Begin\+Time\+In\+Sec, }
\item[{double}]{stiffness\+Perturbation\+End\+Time\+In\+Sec, }
\item[{double}]{stiffness\+Changed\+To\+Fraction\+Of\+Original}
\end{DoxyParamCaption}
)}\label{classShapeBase_aef460b84dc469f89742af7c19411454f}


This function will calciulate the stiffness perturbation rate. 

This function will calciulate the stiffness perturbation rate.

the used rate will be different for apical elements and all the remaining elements. I do not need to check for E\+C\+M, as this is called for only the elements that has applied stiffness perturbations, which already excluded E\+C\+M elements.

If the element is apical, whatever I am applying to the basal side, I will apply the inverse to the apical side. If the baso-\/lateral side is doubling, apical surface will halve. Please note this will not be feasible for elements that span the whole disc. You cannot do a baso-\/lateral change for elements that cover the whole tissue!\hypertarget{classShapeBase_aafb0d14adc7ac116191bcff4a7837e98}{}\index{Shape\+Base@{Shape\+Base}!calculate\+Velocity\+Gradient\+Tensor@{calculate\+Velocity\+Gradient\+Tensor}}
\index{calculate\+Velocity\+Gradient\+Tensor@{calculate\+Velocity\+Gradient\+Tensor}!Shape\+Base@{Shape\+Base}}
\subsubsection[{calculate\+Velocity\+Gradient\+Tensor}]{\setlength{\rightskip}{0pt plus 5cm}gsl\+\_\+matrix $\ast$ Shape\+Base\+::calculate\+Velocity\+Gradient\+Tensor (
\begin{DoxyParamCaption}
\item[{gsl\+\_\+matrix $\ast$}]{B, }
\item[{gsl\+\_\+matrix $\ast$}]{displacement\+Per\+Dt}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classShapeBase_aafb0d14adc7ac116191bcff4a7837e98}


This function calculates the velocity gradient tensor. 

Inputs\+:
\begin{DoxyEnumerate}
\item The elemental B matrix (6 , \hyperlink{classShapeBase_a0ae4246d158f4d66b5bd1644df40f150}{Shape\+Base\+::n\+Dim} x \hyperlink{classShapeBase_a0daa5629b1335ca3e1be089a006fe897}{Shape\+Base\+::n\+Nodes}).
\item The displacement of all nodes of the system, divided by the time step (\hyperlink{classShapeBase_a0ae4246d158f4d66b5bd1644df40f150}{Shape\+Base\+::n\+Dim} x \hyperlink{classSimulation_ab779ac291bc517de8a598ab72094c1a6}{Simulation\+::n\+Nodes}, 1).
\end{DoxyEnumerate}

Output\+:
\begin{DoxyEnumerate}
\item Velocity gradient tensor in Voigt notation (6, 1).
\end{DoxyEnumerate}

This function calculates the velocity gradient tensor from elemental B matrix and elemental displacement. The elemental B matrix is composed of a stack of B matrices for each node of the element\+: \begin{eqnarray*} \textbf{B} &=& \left[ \left[ \textbf{B}_{0} \right] \left[ \textbf{B}_{1} \right] ... \left[ \textbf{B}_{nNode}\right] \right]\\ &=& \left[ \begin{bmatrix} \partial_x N_0 & 0 & 0 \\ 0 & \partial_y N_0 & 0 \\ 0 & 0 & \partial_z N_0 \\ \partial_y N_0 & \partial_x N_0 & 0\\ \partial_z N_0 & 0 & \partial_x N_0 \\ 0 & \partial_z N_0 & \partial_y N_0 \end{bmatrix} \begin{bmatrix} \partial_x N_1 & 0 & 0 \\ 0 & \partial_y N_1 & 0 \\ 0 & 0 & \partial_z N_1 \\ \partial_y N_1 & \partial_x N_1 & 0\\ \partial_z N_1 & 0 & \partial_x N_1 \\ 0 & \partial_z N_1 & \partial_y N_1 \end{bmatrix} ... \begin{bmatrix} \partial_x N_{nNode} & 0 & 0 \\ 0 & \partial_y N_{nNode} & 0 \\ 0 & 0 & \partial_z N_{nNode} \\ \partial_y N_{nNode} & \partial_x N_{nNode} & 0\\ \partial_z N_{nNode} & 0 & \partial_x N_{nNode} \\ 0 & \partial_z N_{nNode} & \partial_y N_{nNode} \end{bmatrix} \right] \end{eqnarray*} The elemental displacement matrix is extracted from the system displacement matrix via the function \hyperlink{classShapeBase_afcdbbe37a746ade52a1af70a9aa12b9f}{Shape\+Base\+::construct\+Elemental\+Displacement\+Matrix}. The displacement is calculated as the displacement of a node from its position at the end of last time step, $ u_{n}$ to the position at the current Newton-\/\+Raphson iteration $ u_{k}$. With the velocities (displacement per time step), and the $\textbf{B}$ matrix, velocity gradient tensor can be calculated through\+: \begin{eqnarray*} \boldsymbol{l} & = \boldsymbol{B} \boldsymbol{v_{n+1}}\nonumber \\ & = \boldsymbol{B} \frac{{u_{n+1}^{k} - u_{n}}} {\delta t}. \end{eqnarray*}

Procedure\+:
\begin{DoxyItemize}
\item construct the Elemental\+Displacement\+Matrix.
\item Allocate the velocity gradient tensor in Voigt notation.
\item calculate velocity gradient tensor.
\item free allocated memory.
\item return velocity gradient tensor.
\end{DoxyItemize}\hypertarget{classShapeBase_a4d10225f251fa1bd8a2e6ffc8feb5326}{}\index{Shape\+Base@{Shape\+Base}!calculate\+Viscous\+Forces@{calculate\+Viscous\+Forces}}
\index{calculate\+Viscous\+Forces@{calculate\+Viscous\+Forces}!Shape\+Base@{Shape\+Base}}
\subsubsection[{calculate\+Viscous\+Forces}]{\setlength{\rightskip}{0pt plus 5cm}void Shape\+Base\+::calculate\+Viscous\+Forces (
\begin{DoxyParamCaption}
\item[{gsl\+\_\+matrix $\ast$}]{gv, }
\item[{gsl\+\_\+matrix $\ast$}]{B\+Tdet\+Fdetd\+Xde, }
\item[{gsl\+\_\+matrix $\ast$}]{viscous\+Stress}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classShapeBase_a4d10225f251fa1bd8a2e6ffc8feb5326}


This function will calculate the elemental viscous forces from viscous stress. 

Inputs\+:
\begin{DoxyEnumerate}
\item Elemental matrix for internal viscous forces (\hyperlink{classShapeBase_a0ae4246d158f4d66b5bd1644df40f150}{Shape\+Base\+::n\+Dim} x \hyperlink{classShapeBase_a0daa5629b1335ca3e1be089a006fe897}{Shape\+Base\+::n\+Nodes}, 1) the resulting forces will be written on this matrix
\item Transpose of elemental B matrix, multiplied by the determinant of the deformation gradient, $\textbf{F}$, and the determinant of $ \delta \textbf{X}/\delta \boldsymbol{\xi}$
\item The viscous stresses calculated in \hyperlink{classShapeBase_a22ffae25fafb0fa584a3a4d0196af7aa}{Shape\+Base\+::calculate\+Viscous\+Stress}
\end{DoxyEnumerate}

This function will calculate the elemental viscous forces from viscous stress, via\+: \begin{eqnarray*} \textbf{g}^v &=& \int_{V} \textbf{B}^{T} \sigma^{v} dV \\ &=& det(\textbf{F})det\left( \frac{\delta \textbf{X} }{\delta \boldsymbol{\xi}} \right) \textbf{B}^{T} \sigma^{v} \end{eqnarray*} Procedure\+:
\begin{DoxyItemize}
\item Allocate the memory for stress in Voigt notation
\item Write stress in Voigt notation
\item Calculate nodal forces
\item Free memory
\end{DoxyItemize}\hypertarget{classShapeBase_a22ffae25fafb0fa584a3a4d0196af7aa}{}\index{Shape\+Base@{Shape\+Base}!calculate\+Viscous\+Stress@{calculate\+Viscous\+Stress}}
\index{calculate\+Viscous\+Stress@{calculate\+Viscous\+Stress}!Shape\+Base@{Shape\+Base}}
\subsubsection[{calculate\+Viscous\+Stress}]{\setlength{\rightskip}{0pt plus 5cm}void Shape\+Base\+::calculate\+Viscous\+Stress (
\begin{DoxyParamCaption}
\item[{gsl\+\_\+matrix $\ast$}]{d, }
\item[{gsl\+\_\+matrix $\ast$}]{viscous\+Stress}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classShapeBase_a22ffae25fafb0fa584a3a4d0196af7aa}


This function will calculate internal viscous stress of the element from rate of deformation matrix. 

Inputs\+:
\begin{DoxyEnumerate}
\item The rate of deformation matrix (\hyperlink{classShapeBase_a0ae4246d158f4d66b5bd1644df40f150}{Shape\+Base\+::n\+Dim} x \hyperlink{classShapeBase_a0ae4246d158f4d66b5bd1644df40f150}{Shape\+Base\+::n\+Dim}).
\item the viscous stress of current Gauss point, the result will be written on this matrix
\end{DoxyEnumerate}

This function will calculate the internal viscous stress of the element using rate of deformation matrix and \hyperlink{classShapeBase_a7fd0830ee5d4e64bb68e58aa77736757}{Shape\+Base\+::internal\+Viscosity}, $\eta$ , via\+: \[\sigma^{v} = \eta \textbf{d} \]

Procedure\+:
\begin{DoxyItemize}
\item Copy rate of deformation tensor over to viscous stress tensor.
\item Scale with the internal viscosity to obtain viscous stress tensor
\end{DoxyItemize}\hypertarget{classShapeBase_a5409de18ee9e47af0bb977f4a1e608fb}{}\index{Shape\+Base@{Shape\+Base}!change\+Shape\+By\+Fsc@{change\+Shape\+By\+Fsc}}
\index{change\+Shape\+By\+Fsc@{change\+Shape\+By\+Fsc}!Shape\+Base@{Shape\+Base}}
\subsubsection[{change\+Shape\+By\+Fsc}]{\setlength{\rightskip}{0pt plus 5cm}void Shape\+Base\+::change\+Shape\+By\+Fsc (
\begin{DoxyParamCaption}
\item[{double}]{dt}
\end{DoxyParamCaption}
)}\label{classShapeBase_a5409de18ee9e47af0bb977f4a1e608fb}


This function calculates the shape change increment from shape change rates. 

$<$ The increment of shape change that will be induced this step \hypertarget{classShapeBase_a346f4ec76554bea282a5cab7ea28dfa2}{}\index{Shape\+Base@{Shape\+Base}!check\+For\+Collapsed\+Nodes@{check\+For\+Collapsed\+Nodes}}
\index{check\+For\+Collapsed\+Nodes@{check\+For\+Collapsed\+Nodes}!Shape\+Base@{Shape\+Base}}
\subsubsection[{check\+For\+Collapsed\+Nodes}]{\setlength{\rightskip}{0pt plus 5cm}void Shape\+Base\+::check\+For\+Collapsed\+Nodes (
\begin{DoxyParamCaption}
\item[{int}]{Tissue\+Height\+Discretisation\+Layers, }
\item[{const std\+::vector$<$ std\+::unique\+\_\+ptr$<$ {\bf Node} $>$$>$ \&}]{Nodes, }
\item[{const std\+::vector$<$ std\+::unique\+\_\+ptr$<$ {\bf Shape\+Base} $>$$>$ \&}]{Elements}
\end{DoxyParamCaption}
)}\label{classShapeBase_a346f4ec76554bea282a5cab7ea28dfa2}


This function checks if any of the edges of the element is shortened to the extent that it should be collapsed. 

If the element has any nodes that are collapsed with any other node, then the element is considered collapsed. This definition does not make any distinction betwenn elements collapsing on themselves to avoid flips, or the nodal collapse due to adhesion of two elements.\hypertarget{classShapeBase_a2e7fdc8e749b8b709b6c80248dc2bc3f}{}\index{Shape\+Base@{Shape\+Base}!check\+Z\+Capping\+In\+Remodelling@{check\+Z\+Capping\+In\+Remodelling}}
\index{check\+Z\+Capping\+In\+Remodelling@{check\+Z\+Capping\+In\+Remodelling}!Shape\+Base@{Shape\+Base}}
\subsubsection[{check\+Z\+Capping\+In\+Remodelling}]{\setlength{\rightskip}{0pt plus 5cm}bool Shape\+Base\+::check\+Z\+Capping\+In\+Remodelling (
\begin{DoxyParamCaption}
\item[{bool}]{volume\+Conserved, }
\item[{double}]{z\+Remodelling\+Lower\+Threshold, }
\item[{double}]{z\+Remodelling\+Upper\+Threshold, }
\item[{gsl\+\_\+matrix $\ast$}]{increment, }
\item[{gsl\+\_\+matrix $\ast$}]{eigen\+Vec}
\end{DoxyParamCaption}
)}\label{classShapeBase_a2e7fdc8e749b8b709b6c80248dc2bc3f}


This function checks if the remodelling of the element in z axis have reached the specified cap. 

This function checks if the remodelling of the element in z axis have reached the specified cap. First step is to figure out what the gorwth on z axis will be upon the applicatin of perturbation.

Once the gorwth increment in a non is non-\/volume conserved and non-\/scaled for z approach, I will have the potential new z deformation. There are limitations to how much z axis can be remodelled. I check those limits provided as inputs to the funciton and cap the z deformation if necessary.\hypertarget{classShapeBase_afcdbbe37a746ade52a1af70a9aa12b9f}{}\index{Shape\+Base@{Shape\+Base}!construct\+Elemental\+Displacement\+Matrix@{construct\+Elemental\+Displacement\+Matrix}}
\index{construct\+Elemental\+Displacement\+Matrix@{construct\+Elemental\+Displacement\+Matrix}!Shape\+Base@{Shape\+Base}}
\subsubsection[{construct\+Elemental\+Displacement\+Matrix}]{\setlength{\rightskip}{0pt plus 5cm}gsl\+\_\+matrix $\ast$ Shape\+Base\+::construct\+Elemental\+Displacement\+Matrix (
\begin{DoxyParamCaption}
\item[{gsl\+\_\+matrix $\ast$}]{displacement}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classShapeBase_afcdbbe37a746ade52a1af70a9aa12b9f}


This function will assemble elemental node displacement matrix from the input displacement matrix for the whole system. 

Inputs\+:
\begin{DoxyEnumerate}
\item The displacement matrix (\hyperlink{classShapeBase_a0ae4246d158f4d66b5bd1644df40f150}{Shape\+Base\+::n\+Dim} x \hyperlink{classSimulation_ab779ac291bc517de8a598ab72094c1a6}{Simulation\+::n\+Nodes}, 1).
\end{DoxyEnumerate}

This function calculates the elemental displacement matrix from the displacement matrix of the whole system, given as input. In current usage, under normal circumstances, the input matrix is displacement divided by time step. The displacement is calculated by Simulation\+::calculate\+Displacement\+Matrix Both matrices, the displacement matrix of the whole system and the elemental displacement matrix are in vector form\+:

$ displacement = \begin{bmatrix} \Delta x_{0}\\ \Delta y_{0}\\ \Delta z_{0}\\ ... ,\\ \Delta x_{N}\\ \Delta y_{N}\\ \Delta z_{N} \end{bmatrix} $\hypertarget{classShapeBase_ac5ea30d81c19c9f7c904af66310c750b}{}\index{Shape\+Base@{Shape\+Base}!construct\+Rotation\+Matrix@{construct\+Rotation\+Matrix}}
\index{construct\+Rotation\+Matrix@{construct\+Rotation\+Matrix}!Shape\+Base@{Shape\+Base}}
\subsubsection[{construct\+Rotation\+Matrix}]{\setlength{\rightskip}{0pt plus 5cm}void Shape\+Base\+::construct\+Rotation\+Matrix (
\begin{DoxyParamCaption}
\item[{double}]{c, }
\item[{double}]{s, }
\item[{double $\ast$}]{rot\+Ax, }
\item[{double $\ast$}]{rot\+Mat}
\end{DoxyParamCaption}
)}\label{classShapeBase_ac5ea30d81c19c9f7c904af66310c750b}


Helper algebraic function calculates the rotation axis needed to align vector u onto v. 

Helper algebraic functio calculates the rotation matrix from input sine, cosine of the rotation angle and the rotation axis. Writes the matrix into the input rot\+Mat \hypertarget{classShapeBase_a91a660608ede71c5bfdd1c4956843760}{}\index{Shape\+Base@{Shape\+Base}!disassemble\+Rotation\+Matrix\+For\+Z@{disassemble\+Rotation\+Matrix\+For\+Z}}
\index{disassemble\+Rotation\+Matrix\+For\+Z@{disassemble\+Rotation\+Matrix\+For\+Z}!Shape\+Base@{Shape\+Base}}
\subsubsection[{disassemble\+Rotation\+Matrix\+For\+Z}]{\setlength{\rightskip}{0pt plus 5cm}bool Shape\+Base\+::disassemble\+Rotation\+Matrix\+For\+Z (
\begin{DoxyParamCaption}
\item[{gsl\+\_\+matrix $\ast$}]{rot\+Mat}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classShapeBase_a91a660608ede71c5bfdd1c4956843760}


This function extracts the z rotation from a rotation matrix. 

This function extracts the z rotation from a rotation matrix. From Extracting euler angles from a rotation matrix by Mike Day of insomniac games\+: ~\newline
 To extract a rotation of $ \mathbf{R}_{x}(\theta_{1}) \mathbf{R}_{y}(\theta_{2}) \mathbf{R}_{z}(\theta_{3})$ from a matrix M where\+: \begin{eqnarray*} \mathbf{M} = \begin{bmatrix} m_{00} & m_{01} & m_{02} \\ m_{10} & m_{11} & m_{12} \\ m_{20} & m_{21} & m_{22}] \end{bmatrix} \end{eqnarray*} and $ c_{1} $ denote $ cos(\theta_{1}) $ and $ s_{1} $ denote $ sin(\theta_{1}) $\+: \begin{eqnarray*} tet_1 & = & atan2(m_{12},m_{22}) = atan2(s_1c_2, c_1c_2) \\ c_2 & = & \sqrt{m_{00}*m_{00} + m_{01}*m_{01}} \\ tet_2 & = & atan2(-m_{02},c_2) \\ tet_3 & = & atan2(m_{01},m_{00}) \end{eqnarray*}\hypertarget{classShapeBase_ab8a7323c50767ecdc82d8d8ce411b264}{}\index{Shape\+Base@{Shape\+Base}!display\+Name@{display\+Name}}
\index{display\+Name@{display\+Name}!Shape\+Base@{Shape\+Base}}
\subsubsection[{display\+Name}]{\setlength{\rightskip}{0pt plus 5cm}void Shape\+Base\+::display\+Name (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classShapeBase_ab8a7323c50767ecdc82d8d8ce411b264}


Helper function, display the name of the element. 

This function will write the shape type and shape id to standard output.\hypertarget{classShapeBase_abb8aa4fb16ea7b545e6b8e13b95d6b6e}{}\index{Shape\+Base@{Shape\+Base}!get\+Current\+Fe@{get\+Current\+Fe}}
\index{get\+Current\+Fe@{get\+Current\+Fe}!Shape\+Base@{Shape\+Base}}
\subsubsection[{get\+Current\+Fe}]{\setlength{\rightskip}{0pt plus 5cm}gsl\+\_\+matrix $\ast$ Shape\+Base\+::get\+Current\+Fe (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classShapeBase_abb8aa4fb16ea7b545e6b8e13b95d6b6e}


This function returns the current elastic part of the deformation gradient. 

The current elastic deformation gradient is calculated the average at all Gauss points (\hyperlink{classShapeBase_a5c80fec4188317146cb31b74c36c7640}{Shape\+Base\+::number\+Of\+Gauss\+Points} with weights in \hyperlink{classShapeBase_a50ec0d74748313a30a280258bd1e1827}{Shape\+Base\+::gauss\+Weights}), as recorded in \hyperlink{classShapeBase_aae6b0d0bc99f2c07986522fd866312ea}{Shape\+Base\+::\+Fe\+Matrices} is calculated.\hypertarget{classShapeBase_a438155adad0f124efa714b349830437b}{}\index{Shape\+Base@{Shape\+Base}!get\+Current\+Volume@{get\+Current\+Volume}}
\index{get\+Current\+Volume@{get\+Current\+Volume}!Shape\+Base@{Shape\+Base}}
\subsubsection[{get\+Current\+Volume}]{\setlength{\rightskip}{0pt plus 5cm}double Shape\+Base\+::get\+Current\+Volume (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classShapeBase_a438155adad0f124efa714b349830437b}


This function returns the current volume of the element. 

The current volume of the element is calculated from the determinant of the deformation gradient and the initial volume at relaxed state. As the determinants are already recorded, this is cheaper than calculation of a compex deformed shape calculation. First the average of the determinants at all Gauss points (\hyperlink{classShapeBase_a5c80fec4188317146cb31b74c36c7640}{Shape\+Base\+::number\+Of\+Gauss\+Points} with weights in \hyperlink{classShapeBase_a50ec0d74748313a30a280258bd1e1827}{Shape\+Base\+::gauss\+Weights}), as recorded in \hyperlink{classShapeBase_a01d3d2738b44a003e08a6a6b96c0b91e}{Shape\+Base\+::det\+Fs} is calculated. Then the reference shape volume is scaled.\hypertarget{classShapeBase_a2e91ece1ff8f6cfa8d8c495a3afc59c5}{}\index{Shape\+Base@{Shape\+Base}!get\+Initial\+Relative\+Position\+In\+Tissue\+In\+Grid\+Index@{get\+Initial\+Relative\+Position\+In\+Tissue\+In\+Grid\+Index}}
\index{get\+Initial\+Relative\+Position\+In\+Tissue\+In\+Grid\+Index@{get\+Initial\+Relative\+Position\+In\+Tissue\+In\+Grid\+Index}!Shape\+Base@{Shape\+Base}}
\subsubsection[{get\+Initial\+Relative\+Position\+In\+Tissue\+In\+Grid\+Index}]{\setlength{\rightskip}{0pt plus 5cm}void Shape\+Base\+::get\+Initial\+Relative\+Position\+In\+Tissue\+In\+Grid\+Index (
\begin{DoxyParamCaption}
\item[{int}]{n\+Grid\+X, }
\item[{int}]{n\+Grid\+Y, }
\item[{int \&}]{Index\+X, }
\item[{int \&}]{Index\+Y, }
\item[{double \&}]{Frac\+X, }
\item[{double \&}]{Frac\+Y}
\end{DoxyParamCaption}
)}\label{classShapeBase_a2e91ece1ff8f6cfa8d8c495a3afc59c5}


The relative positions of the iitial configuration of the element within the bounding box of the tissue. 

This function provides the relative initial position within the bounding box of the tissue, and calculates which point on the growth maps should be read. The relative position is calculated through the function \hyperlink{classShapeBase_a775b57d5074679c6fd4d3f57885e86d8}{Shape\+Base\+::get\+Initial\+Relative\+Pos\+In\+Bounding\+Box}, and converted to grid indices through \hyperlink{classShapeBase_acde567878e8335d5f3b82042bcf23e5b}{Shape\+Base\+::convert\+Relative\+Pos\+To\+Grid\+Index}.\hypertarget{classShapeBase_a13cf955dcc9db425c762053468578d72}{}\index{Shape\+Base@{Shape\+Base}!get\+Relative\+Position\+In\+Tissue\+In\+Grid\+Index@{get\+Relative\+Position\+In\+Tissue\+In\+Grid\+Index}}
\index{get\+Relative\+Position\+In\+Tissue\+In\+Grid\+Index@{get\+Relative\+Position\+In\+Tissue\+In\+Grid\+Index}!Shape\+Base@{Shape\+Base}}
\subsubsection[{get\+Relative\+Position\+In\+Tissue\+In\+Grid\+Index}]{\setlength{\rightskip}{0pt plus 5cm}void Shape\+Base\+::get\+Relative\+Position\+In\+Tissue\+In\+Grid\+Index (
\begin{DoxyParamCaption}
\item[{int}]{n\+Grid\+X, }
\item[{int}]{n\+Grid\+Y, }
\item[{int \&}]{Index\+X, }
\item[{int \&}]{Index\+Y, }
\item[{double \&}]{Frac\+X, }
\item[{double \&}]{Frac\+Y}
\end{DoxyParamCaption}
)}\label{classShapeBase_a13cf955dcc9db425c762053468578d72}


Provides the relative position within the bounding box of the tissue, and calculates which point on the growth maps should be read. 

This function provides the relative position within the bounding box of the tissue, and calculates which point on the growth maps should be read. The relative position is calculated through the function \hyperlink{classShapeBase_ad50e45399c54ae205ae1adabbc485ff1}{Shape\+Base\+::get\+Relative\+Pos\+In\+Bounding\+Box}, and converted to grid indices through \hyperlink{classShapeBase_acde567878e8335d5f3b82042bcf23e5b}{Shape\+Base\+::convert\+Relative\+Pos\+To\+Grid\+Index}.\hypertarget{classShapeBase_a29ee0eeca30fdd381d294b383c3baf0c}{}\index{Shape\+Base@{Shape\+Base}!grow\+Shape\+By\+Fg@{grow\+Shape\+By\+Fg}}
\index{grow\+Shape\+By\+Fg@{grow\+Shape\+By\+Fg}!Shape\+Base@{Shape\+Base}}
\subsubsection[{grow\+Shape\+By\+Fg}]{\setlength{\rightskip}{0pt plus 5cm}void Shape\+Base\+::grow\+Shape\+By\+Fg (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classShapeBase_a29ee0eeca30fdd381d294b383c3baf0c}


This function updates the current growth deformaiton gradient with the growt/shape change/plastic deformation increments and their respective rotations. 

This function updates the current growth deformaiton gradient with the growt/shape change/plastic deformation increments and their respective rotations.

If the growth is rotated (\hyperlink{classShapeBase_aee6a2cd267d49404f5442a48c867860f}{Shape\+Base\+::rotated\+Growth}), the current growth increment in rotated with a tensor rotation\+: $ \mathbf{R}^{T} \mathbf{F}^{G}_{increment} \mathbf{R} $.~\newline
 Where $ \mathbf{F}^{G}_{increment} $ is \hyperlink{classShapeBase_af553856335d7344ea67ab10f9cc3babf}{Shape\+Base\+::growth\+Increment} and the rotation matrix is \hyperlink{classShapeBase_acc1408c3e89b91787fec7e913cac1f58}{Shape\+Base\+::\+Growth\+Strains\+Rot\+Mat}. A similar rotation is applied on shape change increment defined in \hyperlink{classShapeBase_a2db4859942429aa4e3efc26a119a5aa3}{Shape\+Base\+::shape\+Change\+Increment} and \hyperlink{classShapeBase_acc1408c3e89b91787fec7e913cac1f58}{Shape\+Base\+::\+Growth\+Strains\+Rot\+Mat}.

The plastic deformation increment is already in the correct orientation by definiton. The increments are then merged and added on the current growth deformation gradient $ F^{G} $

The volumentric change induced by growth is calculated via the determinant of the growth deformation gradient. The current prefered volume is updated accordingly.\hypertarget{classShapeBase_ae9cfd1ae56e018477dd3642d4d769d90}{}\index{Shape\+Base@{Shape\+Base}!is\+Actin\+Stiffness\+Change\+Applied\+To\+Element@{is\+Actin\+Stiffness\+Change\+Applied\+To\+Element}}
\index{is\+Actin\+Stiffness\+Change\+Applied\+To\+Element@{is\+Actin\+Stiffness\+Change\+Applied\+To\+Element}!Shape\+Base@{Shape\+Base}}
\subsubsection[{is\+Actin\+Stiffness\+Change\+Applied\+To\+Element}]{\setlength{\rightskip}{0pt plus 5cm}bool Shape\+Base\+::is\+Actin\+Stiffness\+Change\+Applied\+To\+Element (
\begin{DoxyParamCaption}
\item[{bool}]{There\+Is\+Whole\+Tissue\+Stiffness\+Perturbation, }
\item[{bool}]{There\+Is\+Apical\+Stiffness\+Perturbation, }
\item[{bool}]{There\+Is\+Basal\+Stiffness\+Perturbation, }
\item[{bool}]{There\+Is\+Basolateral\+With\+Apical\+Relaxation\+Stiffness\+Perturbation, }
\item[{bool}]{There\+Is\+Basolateral\+Stiffness\+Perturbation, }
\item[{std\+::vector$<$ int $>$ \&}]{stiffness\+Perturbation\+Ellipse\+Band\+Ids, }
\item[{int}]{number\+Of\+Stiffness\+Perturbation\+Applies\+Ellipse\+Bands}
\end{DoxyParamCaption}
)}\label{classShapeBase_ae9cfd1ae56e018477dd3642d4d769d90}


This function decides if the actin stiffness perturbation is applied to this element. 

The function regulating stiffness perturbations to tissue and E\+C\+M are distinct. Therefore first chack is tissue specific characterisation, \hyperlink{classShapeBase_a5e442b31d2341cbe477d7c33195a576c}{Shape\+Base\+::is\+E\+C\+M\+Mimicing}. If the the element is not, the positional coupling between the input perturbation adn the element tissue properties are checked to see if the perturbation is applied to this element.\hypertarget{classShapeBase_a8763ab46f90adb819ec776a5829573c5}{}\index{Shape\+Base@{Shape\+Base}!is\+Element\+Flipped\+In\+Potential\+New\+Shape@{is\+Element\+Flipped\+In\+Potential\+New\+Shape}}
\index{is\+Element\+Flipped\+In\+Potential\+New\+Shape@{is\+Element\+Flipped\+In\+Potential\+New\+Shape}!Shape\+Base@{Shape\+Base}}
\subsubsection[{is\+Element\+Flipped\+In\+Potential\+New\+Shape}]{\setlength{\rightskip}{0pt plus 5cm}bool Shape\+Base\+::is\+Element\+Flipped\+In\+Potential\+New\+Shape (
\begin{DoxyParamCaption}
\item[{int}]{node\+Id, }
\item[{double}]{new\+X, }
\item[{double}]{new\+Y, }
\item[{double}]{new\+Z}
\end{DoxyParamCaption}
)}\label{classShapeBase_a8763ab46f90adb819ec776a5829573c5}


This function checks if the element will plip in the case that its node (node\+I\+D) is moved to the new x,y,z coordintes specified in the input. Necessary in node collapsing. 

The current positions are taken on a temporary matrix, and the position update is carried out to the new position specified in the funciton input. Then the new elastic deformation gradient is calculated through the standard procedure. If the determinant of the deformation gradient is negative, then the element is flipped and the node position update the the new position should be avoided.

$<$ Removing growth \hypertarget{classShapeBase_aa0f0cc5b33f3e12d91a246cc591c346c}{}\index{Shape\+Base@{Shape\+Base}!is\+Growth\+Rate\+Applicable@{is\+Growth\+Rate\+Applicable}}
\index{is\+Growth\+Rate\+Applicable@{is\+Growth\+Rate\+Applicable}!Shape\+Base@{Shape\+Base}}
\subsubsection[{is\+Growth\+Rate\+Applicable}]{\setlength{\rightskip}{0pt plus 5cm}bool Shape\+Base\+::is\+Growth\+Rate\+Applicable (
\begin{DoxyParamCaption}
\item[{int}]{source\+Tissue, }
\item[{double \&}]{weight, }
\item[{double}]{zmin, }
\item[{double}]{zmax}
\end{DoxyParamCaption}
)}\label{classShapeBase_aa0f0cc5b33f3e12d91a246cc591c346c}


The function checks if the element if affected by the current growth functions. 

This function checks if the current growth is appliable tothe element. The input source\+Tissue defines which tissue compartment the growth is applicable to. The weight is needed for elements that are in transition zones between compartments, giving the weight of the growth that should be applide to the element, should be below 1.\+0 by definition. ~\newline
 The code first chacks if the relative z coordinate of teh elemetn is within the limits of growth application.

Then the tissue type is checked. If compartments match, the weight is zero, if they don\textquotesingle{}t it is 0 and growth is not applied. If the element is in a transition compartment, the weight is assigned dependent on the source tissue type.\hypertarget{classShapeBase_a96dae3d137adec217bb0bc6ed2cace97}{}\index{Shape\+Base@{Shape\+Base}!read\+Node\+Ids@{read\+Node\+Ids}}
\index{read\+Node\+Ids@{read\+Node\+Ids}!Shape\+Base@{Shape\+Base}}
\subsubsection[{read\+Node\+Ids}]{\setlength{\rightskip}{0pt plus 5cm}void Shape\+Base\+::read\+Node\+Ids (
\begin{DoxyParamCaption}
\item[{const std\+::vector$<$ int $>$ \&}]{inp\+Node\+Ids}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classShapeBase_a96dae3d137adec217bb0bc6ed2cace97}


The function sets the \hyperlink{classNode_a1bd379569cc1a8b96432e61971aed4d9}{Node\+::\+Id} array that constructs the shape. 

This function will take the input of an int pointer that contains the Ids of the nodes that construct the element, and write them into the int array \hyperlink{classShapeBase_af96e17fa9a23289fb743ff0722a7dc64}{Shape\+Base\+::\+Node\+Ids} of size \hyperlink{classShapeBase_a0daa5629b1335ca3e1be089a006fe897}{Shape\+Base\+::n\+Nodes}.\hypertarget{classShapeBase_a40a3c680c1b96ae81d6bfe21a0127655}{}\index{Shape\+Base@{Shape\+Base}!relax\+Elastic\+Forces@{relax\+Elastic\+Forces}}
\index{relax\+Elastic\+Forces@{relax\+Elastic\+Forces}!Shape\+Base@{Shape\+Base}}
\subsubsection[{relax\+Elastic\+Forces}]{\setlength{\rightskip}{0pt plus 5cm}void Shape\+Base\+::relax\+Elastic\+Forces (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classShapeBase_a40a3c680c1b96ae81d6bfe21a0127655}


This function relaxes all teh accumulated elastic forces in the system. 

The current elastic deformation gradient coped over growth deformation gradient to relax all elastic forces.\hypertarget{classShapeBase_aace7f6727db271b84db82d0560d26b86}{}\index{Shape\+Base@{Shape\+Base}!scale\+Growth\+For\+Z\+Redistribution@{scale\+Growth\+For\+Z\+Redistribution}}
\index{scale\+Growth\+For\+Z\+Redistribution@{scale\+Growth\+For\+Z\+Redistribution}!Shape\+Base@{Shape\+Base}}
\subsubsection[{scale\+Growth\+For\+Z\+Redistribution}]{\setlength{\rightskip}{0pt plus 5cm}void Shape\+Base\+::scale\+Growth\+For\+Z\+Redistribution (
\begin{DoxyParamCaption}
\item[{double \&}]{x, }
\item[{double \&}]{y, }
\item[{double \&}]{z}
\end{DoxyParamCaption}
)}\label{classShapeBase_aace7f6727db271b84db82d0560d26b86}


This function will modify the incremental growth deformation gradient of the element to reflect the volume redistribution in the height of the tissue. 

This function will modify the incremental growth deformation gradient of the element to reflect the volume redistribution in the height of the tissue. First check point id for if there is such redistribution in simulaiton. ~\newline


I\+F there is distribution, hourly xy-\/plane growth is calculated. z growth is not affected.

If the element should be loosing volume (shrunk) due to redistrtibution, the shrink rate is applied.

Else, the sclae is inverted for growth and applied.\hypertarget{classShapeBase_a48f114984fe31a847a9b5485d4622ca1}{}\index{Shape\+Base@{Shape\+Base}!set\+E\+C\+M\+Mimicing@{set\+E\+C\+M\+Mimicing}}
\index{set\+E\+C\+M\+Mimicing@{set\+E\+C\+M\+Mimicing}!Shape\+Base@{Shape\+Base}}
\subsubsection[{set\+E\+C\+M\+Mimicing}]{\setlength{\rightskip}{0pt plus 5cm}void Shape\+Base\+::set\+E\+C\+M\+Mimicing (
\begin{DoxyParamCaption}
\item[{bool}]{Is\+E\+C\+M\+Mimicing}
\end{DoxyParamCaption}
)}\label{classShapeBase_a48f114984fe31a847a9b5485d4622ca1}


This funciton sets the element as an E\+C\+M mimicking element (distinct domain in terms of physical characteristics). 

While setting the element to E\+C\+M mimicking, the Poisson\textquotesingle{}s ratio is also set to zero. The physical definition of the E\+C\+M material requires so.\hypertarget{classShapeBase_a8dafd8524fe5aa5326173aa49a8f78a0}{}\index{Shape\+Base@{Shape\+Base}!set\+Identification\+Colour@{set\+Identification\+Colour}}
\index{set\+Identification\+Colour@{set\+Identification\+Colour}!Shape\+Base@{Shape\+Base}}
\subsubsection[{set\+Identification\+Colour}]{\setlength{\rightskip}{0pt plus 5cm}void Shape\+Base\+::set\+Identification\+Colour (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classShapeBase_a8dafd8524fe5aa5326173aa49a8f78a0}


The function sets the unique \hyperlink{classShapeBase_a8c6daae25e30af2e55599b7d1ecfbddb}{Shape\+Base\+::\+Identifier\+Colour} colour for the element, which is used in element picking from the user interface. 

The function sets the unique \hyperlink{classShapeBase_a8c6daae25e30af2e55599b7d1ecfbddb}{Shape\+Base\+::\+Identifier\+Colour}, which on click, will allow the user interface to identify this element as the selected element. \hyperlink{classShapeBase_a8c6daae25e30af2e55599b7d1ecfbddb}{Shape\+Base\+::\+Identifier\+Colour} is an integer array of size 3, and corresponds to rgb channels, in 0-\/255 range. Therefore, the selection tool works for 255$^\wedge$3 = 16581375 elements. The colour storing is started from b channel moving towards r, and done with element Id\hypertarget{classShapeBase_a474774dd9db4c42990de569b3d8cd52e}{}\index{Shape\+Base@{Shape\+Base}!set\+Position\+Matrix@{set\+Position\+Matrix}}
\index{set\+Position\+Matrix@{set\+Position\+Matrix}!Shape\+Base@{Shape\+Base}}
\subsubsection[{set\+Position\+Matrix}]{\setlength{\rightskip}{0pt plus 5cm}void Shape\+Base\+::set\+Position\+Matrix (
\begin{DoxyParamCaption}
\item[{const std\+::vector$<$ std\+::unique\+\_\+ptr$<$ {\bf Node} $>$$>$ \&}]{Nodes}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classShapeBase_a474774dd9db4c42990de569b3d8cd52e}


The function sets the \hyperlink{classShapeBase_a6a6bd8c65e2a0bfea3a956604bc05cb9}{Shape\+Base\+::\+Positions} matrix to define the locations of each constructing node. 

This function will take the address of a Nodes pointers vector (It should be the \hyperlink{classSimulation_aa6913c3f238cbf5455955b42bd617f72}{Simulation\+::\+Nodes} vector) It will go through the \hyperlink{classShapeBase_af96e17fa9a23289fb743ff0722a7dc64}{Shape\+Base\+::\+Node\+Ids} in a nested loop of \hyperlink{classShapeBase_a0daa5629b1335ca3e1be089a006fe897}{Shape\+Base\+::n\+Nodes} and \hyperlink{classShapeBase_a0ae4246d158f4d66b5bd1644df40f150}{Shape\+Base\+::n\+Dim}, read the positions of the corresponding node from the input vector storing the pointers to all the nodes, and write the position information into the \hyperlink{classShapeBase_a6a6bd8c65e2a0bfea3a956604bc05cb9}{Shape\+Base\+::\+Positions} array. This is a double storing of the same information, yet is practical for elasticity calculations.\hypertarget{classShapeBase_aa260269fe9605765f5adb494d1a99737}{}\index{Shape\+Base@{Shape\+Base}!set\+Reference\+Position\+Matrix@{set\+Reference\+Position\+Matrix}}
\index{set\+Reference\+Position\+Matrix@{set\+Reference\+Position\+Matrix}!Shape\+Base@{Shape\+Base}}
\subsubsection[{set\+Reference\+Position\+Matrix}]{\setlength{\rightskip}{0pt plus 5cm}void Shape\+Base\+::set\+Reference\+Position\+Matrix (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classShapeBase_aa260269fe9605765f5adb494d1a99737}


The function sets the Referenece\+Shape\+Base\+::\+Positions matrix to define the reference positions of the element. 

This function will allocate the position array of the Reference\+Shape (Reference\+Shape\+::\+Positions) Then the reference will be equated to the current position of the element. It is essential this function is called at simulation initiation, and after any subsequent modifications made to the reference structure of the tissue. But it should not be called in cases where the current shape of the element has progressed to differ from its reference (such as after loading steps of a save file). In saves, the reference shapes are set at the initiation of the system, and the positions of saves steps are loaded afterwards.\hypertarget{classShapeBase_a4cc6c721ed24f27baa71fe9398edd87a}{}\index{Shape\+Base@{Shape\+Base}!set\+Shape\+Type@{set\+Shape\+Type}}
\index{set\+Shape\+Type@{set\+Shape\+Type}!Shape\+Base@{Shape\+Base}}
\subsubsection[{set\+Shape\+Type}]{\setlength{\rightskip}{0pt plus 5cm}void Shape\+Base\+::set\+Shape\+Type (
\begin{DoxyParamCaption}
\item[{std\+::string}]{Type\+Name}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classShapeBase_a4cc6c721ed24f27baa71fe9398edd87a}


The function sets the type of the shape. 

The function will set the shape type of the element, stored in variable \hyperlink{classShapeBase_a36aedd41e8465a186a0b0c454b5b76f3}{Shape\+Base\+::\+Shape\+Type}. The mapping is as follows\+:
\begin{DoxyItemize}
\item 1 \+: \hyperlink{classPrism}{Prism}
\item 2 \+: Prism\+Lateral
\item 3 \+: Tetrahedron
\item 4 \+: Triangle
\item (-\/100)\+: Default number if input name is not recognised.
\end{DoxyItemize}\hypertarget{classShapeBase_a3777927e49e4b09bfb524b4f4ac889ad}{}\index{Shape\+Base@{Shape\+Base}!set\+Tissue\+Placement@{set\+Tissue\+Placement}}
\index{set\+Tissue\+Placement@{set\+Tissue\+Placement}!Shape\+Base@{Shape\+Base}}
\subsubsection[{set\+Tissue\+Placement}]{\setlength{\rightskip}{0pt plus 5cm}void Shape\+Base\+::set\+Tissue\+Placement (
\begin{DoxyParamCaption}
\item[{const std\+::vector$<$ std\+::unique\+\_\+ptr$<$ {\bf Node} $>$$>$ \&}]{Nodes}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classShapeBase_a3777927e49e4b09bfb524b4f4ac889ad}


The function sets the placement of the element within the tissue. 

This function will take the address of a Nodes pointers vector (It should be the \hyperlink{classSimulation_aa6913c3f238cbf5455955b42bd617f72}{Simulation\+::\+Nodes} vector) Checking the nodes that construct the element, the function will decide the placement of the element within the tissue. The placement of the element within the tissue is defined by the \hyperlink{classShapeBase_aff63b1fcb823bbfdb5b19fe78dea59b8}{Shape\+Base\+::tissue\+Placement} integer such that\+:
\begin{DoxyItemize}
\item Apical\+: \hyperlink{classShapeBase_aff63b1fcb823bbfdb5b19fe78dea59b8}{Shape\+Base\+::tissue\+Placement} = 1
\item Basal\+: \hyperlink{classShapeBase_aff63b1fcb823bbfdb5b19fe78dea59b8}{Shape\+Base\+::tissue\+Placement} = 0
\item Mid-\/line or spans the whole tissue\+: \hyperlink{classShapeBase_aff63b1fcb823bbfdb5b19fe78dea59b8}{Shape\+Base\+::tissue\+Placement} = 2
\item Lateral\+: \hyperlink{classShapeBase_aff63b1fcb823bbfdb5b19fe78dea59b8}{Shape\+Base\+::tissue\+Placement} = 3
\end{DoxyItemize}

The function will first decide which type of nodes the element is composed of.

Lateral elements can be composed of any combination of lateral, mid-\/line, apical and basal nodes. Any element that contains at least one lateral node, must be a lateral element.

Elements that does not contain any lateral nodes, but apical nodes must be apical. The only exception to this when the whole tissue is spanned by a single layer of elements. Then the element will have apical and basal nodes, and it will be defined as a mid-\/line node, with \hyperlink{classShapeBase_adafe85bbee6173d2a321408cd8b63db3}{Shape\+Base\+::spans\+Whole\+Tissue} set to true.

Elements that does not contain any lateral or apical nodes, but does contain basal nodes then must be basal.

If the element does not contain any lateral, apical or basal nodes, it must be that the element is composed wholly of mid-\/line nodes. Then, the element lies in the mid-\/layer of tissue.\hypertarget{classShapeBase_ad5f0b9431be849133a4eab5484fbb1f8}{}\index{Shape\+Base@{Shape\+Base}!set\+Tissue\+Type@{set\+Tissue\+Type}}
\index{set\+Tissue\+Type@{set\+Tissue\+Type}!Shape\+Base@{Shape\+Base}}
\subsubsection[{set\+Tissue\+Type}]{\setlength{\rightskip}{0pt plus 5cm}void Shape\+Base\+::set\+Tissue\+Type (
\begin{DoxyParamCaption}
\item[{const std\+::vector$<$ std\+::unique\+\_\+ptr$<$ {\bf Node} $>$$>$ \&}]{Nodes}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classShapeBase_ad5f0b9431be849133a4eab5484fbb1f8}


The function sets the tissue type of the element. 

The tissue can be of columnar epithelum type, peripodial type, or be connecting the two. Depending on the owner nodes of the element, if the element has any linker type nodes, it will be a linker node. If there are no linker elements, but there are peripodial elements, then assign peripodial, as some peripodial elements can contain columnar nodes wehen the mesh does not have linkers. Only when all hte nodes are of columnar type, the element is columnar.\hypertarget{classShapeBase_ac4e051a82edb9b987edfbd783076e348}{}\index{Shape\+Base@{Shape\+Base}!set\+Viscosity@{set\+Viscosity}}
\index{set\+Viscosity@{set\+Viscosity}!Shape\+Base@{Shape\+Base}}
\subsubsection[{set\+Viscosity}]{\setlength{\rightskip}{0pt plus 5cm}void Shape\+Base\+::set\+Viscosity (
\begin{DoxyParamCaption}
\item[{double}]{viscosity\+Apical, }
\item[{double}]{viscosity\+Basal, }
\item[{double}]{viscosity\+Mid}
\end{DoxyParamCaption}
)}\label{classShapeBase_ac4e051a82edb9b987edfbd783076e348}


This function sets the viscosity of the element depending on its placement in the tissue. 

Start by setting the viscosity to the mid layer value. If the element has a specific node placement (\hyperlink{classShapeBase_aff63b1fcb823bbfdb5b19fe78dea59b8}{Shape\+Base\+::tissue\+Placement} is apical or basal) then alter accordingly.\hypertarget{classShapeBase_a8b6ffc8d699795e4efb867efd065a679}{}\index{Shape\+Base@{Shape\+Base}!set\+Viscosity@{set\+Viscosity}}
\index{set\+Viscosity@{set\+Viscosity}!Shape\+Base@{Shape\+Base}}
\subsubsection[{set\+Viscosity}]{\setlength{\rightskip}{0pt plus 5cm}void Shape\+Base\+::set\+Viscosity (
\begin{DoxyParamCaption}
\item[{double}]{viscosity\+Apical, }
\item[{double}]{viscosity\+Basal}
\end{DoxyParamCaption}
)}\label{classShapeBase_a8b6ffc8d699795e4efb867efd065a679}


This function sets the viscosity of the element depending on its placement in the tissue. 

Start by setting the viscosity to the mid layer value to the average of apical and basal values. If the element has a specific node placement (\hyperlink{classShapeBase_aff63b1fcb823bbfdb5b19fe78dea59b8}{Shape\+Base\+::tissue\+Placement} is apical or basal) then alter accordingly.\hypertarget{classShapeBase_a466480b1e7de98250dd22c8cdb092d54}{}\index{Shape\+Base@{Shape\+Base}!update\+Growth\+By\+Mutation@{update\+Growth\+By\+Mutation}}
\index{update\+Growth\+By\+Mutation@{update\+Growth\+By\+Mutation}!Shape\+Base@{Shape\+Base}}
\subsubsection[{update\+Growth\+By\+Mutation}]{\setlength{\rightskip}{0pt plus 5cm}void Shape\+Base\+::update\+Growth\+By\+Mutation (
\begin{DoxyParamCaption}
\item[{double}]{dt}
\end{DoxyParamCaption}
)}\label{classShapeBase_a466480b1e7de98250dd22c8cdb092d54}


This function will update the growth growth deformaton gradient increment of the element due to a mutation. 

Mutation can be defined in a scaled growth increase, stored in \hyperlink{classShapeBase_ac7b83cb76a8f4ec11a4a6292c2899ba2}{Shape\+Base\+::mutation\+Growth\+Fold}, or a direct overwriting of hte growth, with \hyperlink{classShapeBase_a35ee77fed372f7702889bebb67875136}{Shape\+Base\+::mutation\+Growth\+Rate\+Per\+Sec}. If the growth fold in non-\/zero, growth in xy plane is scaled accordingly, and set in the rates \hyperlink{classShapeBase_ac06c53088788e3c1461233623f506dbb}{Shape\+Base\+::set\+Growth\+Rate}. If the growth is set directly, then the increment is updated directly to the given value. Then the incremnt is updated via \hyperlink{classShapeBase_ad7d7957431a1ae402347efb03ad94d0e}{Shape\+Base\+::update\+Growth\+Increment\+From\+Rate}.\hypertarget{classShapeBase_a009b5aed1c546db5e517f9f33f67b066}{}\index{Shape\+Base@{Shape\+Base}!update\+Growth\+Increment@{update\+Growth\+Increment}}
\index{update\+Growth\+Increment@{update\+Growth\+Increment}!Shape\+Base@{Shape\+Base}}
\subsubsection[{update\+Growth\+Increment}]{\setlength{\rightskip}{0pt plus 5cm}void Shape\+Base\+::update\+Growth\+Increment (
\begin{DoxyParamCaption}
\item[{gsl\+\_\+matrix $\ast$}]{columnar, }
\item[{gsl\+\_\+matrix $\ast$}]{peripodial}
\end{DoxyParamCaption}
)}\label{classShapeBase_a009b5aed1c546db5e517f9f33f67b066}


This function will update the elemental growth deformation gradient from the current growth deformation gradient increment. 

This function will update the elemental growth deformation gradient from the current growth deformation gradient increment. The inputs to the function provides growht for two dostonct tissue types, and the growth is distributed according to the \hyperlink{classShapeBase_a1d56f7eb3fed744adc268bc4da7a790f}{Shape\+Base\+::tissue\+Type}.\hypertarget{classShapeBase_a606ddc7f909062e9faae9f4a311ccd8a}{}\index{Shape\+Base@{Shape\+Base}!update\+Lagrangian\+Elasticity\+Tensor\+Neo\+Hookean@{update\+Lagrangian\+Elasticity\+Tensor\+Neo\+Hookean}}
\index{update\+Lagrangian\+Elasticity\+Tensor\+Neo\+Hookean@{update\+Lagrangian\+Elasticity\+Tensor\+Neo\+Hookean}!Shape\+Base@{Shape\+Base}}
\subsubsection[{update\+Lagrangian\+Elasticity\+Tensor\+Neo\+Hookean}]{\setlength{\rightskip}{0pt plus 5cm}void Shape\+Base\+::update\+Lagrangian\+Elasticity\+Tensor\+Neo\+Hookean (
\begin{DoxyParamCaption}
\item[{gsl\+\_\+matrix $\ast$}]{inv\+C, }
\item[{double}]{ln\+J, }
\item[{int}]{point\+No}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classShapeBase_a606ddc7f909062e9faae9f4a311ccd8a}


This function calcualtes the Lagrangian elasticity tensor for Neo-\/\+Hookean material model. 

The voigt notation of the transformed elasticity tensor $ \mathcal D $ is calculated via $ \mathcal{D}_{ijkl} = \lambda \boldsymbol{C}^{-1}_{ij} \boldsymbol{C}^{-1}_{kl} + 2 \left( \mu - \lambda ln(J)\right) \mathcal{I}_{ijkl} $ ~\newline
where $ \lambda $ Lame\textquotesingle{}s first parameter and $ \mu $ is the shear modulus. Each value at index ijkl is calculated for each Gauss Point and the information is stored in an array of D\mbox{[}gauss points\mbox{]} \mbox{[}system dimension (3\+D)\mbox{]} \mbox{[}system dimension (3\+D)\mbox{]} \mbox{[}system dimension (3\+D)\mbox{]} \mbox{[}system dimension (3\+D)\mbox{]}.

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
/home/melda/\+Documents/non\+Academic/\+Tissue\+Folding\+Fefractor/\+Tissue\+Folding\+Refractor/\+Tissue\+Folding\+Linux/\+Tissue\+Folding/\+Source\+Code/Shape\+Base.\+h\item 
/home/melda/\+Documents/non\+Academic/\+Tissue\+Folding\+Fefractor/\+Tissue\+Folding\+Refractor/\+Tissue\+Folding\+Linux/\+Tissue\+Folding/\+Source\+Code/Shape\+Base.\+cpp\end{DoxyCompactItemize}
