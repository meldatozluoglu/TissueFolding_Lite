<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Tissue Origami: ShapeBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tissue Origami
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classShapeBase.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classShapeBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ShapeBase Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for ShapeBase:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classShapeBase.png" usemap="#ShapeBase_map" alt=""/>
  <map id="ShapeBase_map" name="ShapeBase_map">
<area href="classPrism.html" alt="Prism" shape="rect" coords="0,56,76,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af919db3ff5e6a6d4a137cf4625189c23"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#af919db3ff5e6a6d4a137cf4625189c23">~ShapeBase</a> ()</td></tr>
<tr class="separator:af919db3ff5e6a6d4a137cf4625189c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55ac0089ea8e37649b0d85409c008ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab55ac0089ea8e37649b0d85409c008ac"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ab55ac0089ea8e37649b0d85409c008ac">getId</a> ()</td></tr>
<tr class="memdesc:ab55ac0089ea8e37649b0d85409c008ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function returns the unique ID of the element. <br /></td></tr>
<tr class="separator:ab55ac0089ea8e37649b0d85409c008ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0adf2bb9b59c68adc9dfdab8b9a67a5a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0adf2bb9b59c68adc9dfdab8b9a67a5a"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a0adf2bb9b59c68adc9dfdab8b9a67a5a">getName</a> ()</td></tr>
<tr class="memdesc:a0adf2bb9b59c68adc9dfdab8b9a67a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function returns the name of the element. <br /></td></tr>
<tr class="separator:a0adf2bb9b59c68adc9dfdab8b9a67a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae6deee4256eb19c6e99b52a40847cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ae6deee4256eb19c6e99b52a40847cb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a7ae6deee4256eb19c6e99b52a40847cb">getShapeType</a> ()</td></tr>
<tr class="memdesc:a7ae6deee4256eb19c6e99b52a40847cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function returns the shape type of the element. <br /></td></tr>
<tr class="separator:a7ae6deee4256eb19c6e99b52a40847cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578a8062720c07fc8e1ad526422c96b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a578a8062720c07fc8e1ad526422c96b8"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a578a8062720c07fc8e1ad526422c96b8">getNodeNumber</a> ()</td></tr>
<tr class="memdesc:a578a8062720c07fc8e1ad526422c96b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function returns the number of nodes o the element. <br /></td></tr>
<tr class="separator:a578a8062720c07fc8e1ad526422c96b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f803aa2f7587251d746706cc478b71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0f803aa2f7587251d746706cc478b71"></a>
const std::vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ab0f803aa2f7587251d746706cc478b71">getNodeIds</a> ()</td></tr>
<tr class="memdesc:ab0f803aa2f7587251d746706cc478b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function returns the vector of node IDs. <br /></td></tr>
<tr class="separator:ab0f803aa2f7587251d746706cc478b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586ebd517ab4b08eab7685b3c004b800"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a586ebd517ab4b08eab7685b3c004b800"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a586ebd517ab4b08eab7685b3c004b800">getNodeId</a> (int i)</td></tr>
<tr class="memdesc:a586ebd517ab4b08eab7685b3c004b800"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function returns the input i^{th} node's ID. <br /></td></tr>
<tr class="separator:a586ebd517ab4b08eab7685b3c004b800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9bc340db8e5add7974be8c36e64802"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf9bc340db8e5add7974be8c36e64802"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aaf9bc340db8e5add7974be8c36e64802">getDim</a> ()</td></tr>
<tr class="memdesc:aaf9bc340db8e5add7974be8c36e64802"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function returns the dimensions of the node, ShapeBase::Dim. <br /></td></tr>
<tr class="separator:aaf9bc340db8e5add7974be8c36e64802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787774fa435981eaba73d4137686783d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a787774fa435981eaba73d4137686783d"></a>
std::array&lt; int, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a787774fa435981eaba73d4137686783d">getIdentifierColour</a> ()</td></tr>
<tr class="memdesc:a787774fa435981eaba73d4137686783d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unique [r,g,b] identifier colour of the element, utilised in picking in the user interface. <br /></td></tr>
<tr class="separator:a787774fa435981eaba73d4137686783d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeddd04a53a677417d8577f031b1ca25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaeddd04a53a677417d8577f031b1ca25"></a>
std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aaeddd04a53a677417d8577f031b1ca25">getCentre</a> ()</td></tr>
<tr class="memdesc:aaeddd04a53a677417d8577f031b1ca25"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the centre of the element in world spave. <br /></td></tr>
<tr class="separator:aaeddd04a53a677417d8577f031b1ca25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d1eaa5a49262418cee28284da14c16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90d1eaa5a49262418cee28284da14c16"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a90d1eaa5a49262418cee28284da14c16">getPeripodialness</a> ()</td></tr>
<tr class="memdesc:a90d1eaa5a49262418cee28284da14c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the relative influence of the peripodial physical characteristics to this element. <br /></td></tr>
<tr class="separator:a90d1eaa5a49262418cee28284da14c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c758ac93865a1e51e63212ebfe2787"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44c758ac93865a1e51e63212ebfe2787"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a44c758ac93865a1e51e63212ebfe2787">getColumnarness</a> ()</td></tr>
<tr class="memdesc:a44c758ac93865a1e51e63212ebfe2787"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the relative influence of the columnar physical characteristics ot this element. <br /></td></tr>
<tr class="separator:a44c758ac93865a1e51e63212ebfe2787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13cf955dcc9db425c762053468578d72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a13cf955dcc9db425c762053468578d72">getRelativePositionInTissueInGridIndex</a> (int nGridX, int nGridY, int &amp;IndexX, int &amp;IndexY, double &amp;FracX, double &amp;FracY)</td></tr>
<tr class="memdesc:a13cf955dcc9db425c762053468578d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the relative position within the bounding box of the tissue, and calculates which point on the growth maps should be read.  <a href="#a13cf955dcc9db425c762053468578d72">More...</a><br /></td></tr>
<tr class="separator:a13cf955dcc9db425c762053468578d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e91ece1ff8f6cfa8d8c495a3afc59c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a2e91ece1ff8f6cfa8d8c495a3afc59c5">getInitialRelativePositionInTissueInGridIndex</a> (int nGridX, int nGridY, int &amp;IndexX, int &amp;IndexY, double &amp;FracX, double &amp;FracY)</td></tr>
<tr class="memdesc:a2e91ece1ff8f6cfa8d8c495a3afc59c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The relative positions of the iitial configuration of the element within the bounding box of the tissue.  <a href="#a2e91ece1ff8f6cfa8d8c495a3afc59c5">More...</a><br /></td></tr>
<tr class="separator:a2e91ece1ff8f6cfa8d8c495a3afc59c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf8b080646ee417af28e94f5857aa17"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aedf8b080646ee417af28e94f5857aa17"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aedf8b080646ee417af28e94f5857aa17">getStiffnessMultiplier</a> ()</td></tr>
<tr class="memdesc:aedf8b080646ee417af28e94f5857aa17"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the current stiffness multiplier as a result of perturbations to physical properties. <br /></td></tr>
<tr class="separator:aedf8b080646ee417af28e94f5857aa17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438155adad0f124efa714b349830437b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a438155adad0f124efa714b349830437b">getCurrentVolume</a> ()</td></tr>
<tr class="memdesc:a438155adad0f124efa714b349830437b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the current volume of the element.  <a href="#a438155adad0f124efa714b349830437b">More...</a><br /></td></tr>
<tr class="separator:a438155adad0f124efa714b349830437b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6c972d40af4b6709481f63903c4342"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf6c972d40af4b6709481f63903c4342"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#adf6c972d40af4b6709481f63903c4342">getElementalElasticForce</a> (int nodeIndex, int dimIndex)</td></tr>
<tr class="memdesc:adf6c972d40af4b6709481f63903c4342"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the calculated elastic force for the node nodeIndex, in coordinate dimIndex. <br /></td></tr>
<tr class="separator:adf6c972d40af4b6709481f63903c4342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d82f91854fff8473dcd722ab423e10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4d82f91854fff8473dcd722ab423e10"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ae4d82f91854fff8473dcd722ab423e10">setElementalElasticForce</a> (int nodeIndex, int dimIndex, double value)</td></tr>
<tr class="memdesc:ae4d82f91854fff8473dcd722ab423e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions sets the calculated elastic force for the node nodeIndex, dimension dimIndex, to the input value. <br /></td></tr>
<tr class="separator:ae4d82f91854fff8473dcd722ab423e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8aa4fb16ea7b545e6b8e13b95d6b6e"><td class="memItemLeft" align="right" valign="top">gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#abb8aa4fb16ea7b545e6b8e13b95d6b6e">getCurrentFe</a> ()</td></tr>
<tr class="memdesc:abb8aa4fb16ea7b545e6b8e13b95d6b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the current elastic part of the deformation gradient.  <a href="#abb8aa4fb16ea7b545e6b8e13b95d6b6e">More...</a><br /></td></tr>
<tr class="separator:abb8aa4fb16ea7b545e6b8e13b95d6b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8f0f737818ca01e15b7652c38d4900"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b8f0f737818ca01e15b7652c38d4900"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a5b8f0f737818ca01e15b7652c38d4900">getApicalArea</a> ()</td></tr>
<tr class="memdesc:a5b8f0f737818ca01e15b7652c38d4900"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the current apical area of the element. <br /></td></tr>
<tr class="separator:a5b8f0f737818ca01e15b7652c38d4900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a3c680c1b96ae81d6bfe21a0127655"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a40a3c680c1b96ae81d6bfe21a0127655">relaxElasticForces</a> ()</td></tr>
<tr class="memdesc:a40a3c680c1b96ae81d6bfe21a0127655"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function relaxes all teh accumulated elastic forces in the system.  <a href="#a40a3c680c1b96ae81d6bfe21a0127655">More...</a><br /></td></tr>
<tr class="separator:a40a3c680c1b96ae81d6bfe21a0127655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f0cc5b33f3e12d91a246cc591c346c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aa0f0cc5b33f3e12d91a246cc591c346c">isGrowthRateApplicable</a> (int sourceTissue, double &amp;weight, double zmin, double zmax)</td></tr>
<tr class="memdesc:aa0f0cc5b33f3e12d91a246cc591c346c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function checks if the element if affected by the current growth functions.  <a href="#aa0f0cc5b33f3e12d91a246cc591c346c">More...</a><br /></td></tr>
<tr class="separator:aa0f0cc5b33f3e12d91a246cc591c346c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605f5ce36b0d86330fbc535f553ae140"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a605f5ce36b0d86330fbc535f553ae140"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a605f5ce36b0d86330fbc535f553ae140">updateGrowthWillBeScaledDueToApikobasalRedistribution</a> (bool thisFunctionShrinksApical, std::vector&lt; int &gt; &amp;ellipseBandIdsForGrowthRedistribution)</td></tr>
<tr class="memdesc:a605f5ce36b0d86330fbc535f553ae140"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function decide if the growth will be redistirbuted in the height of the tissue. <br /></td></tr>
<tr class="separator:a605f5ce36b0d86330fbc535f553ae140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace7f6727db271b84db82d0560d26b86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aace7f6727db271b84db82d0560d26b86">scaleGrowthForZRedistribution</a> (double &amp;x, double &amp;y, double &amp;z)</td></tr>
<tr class="memdesc:aace7f6727db271b84db82d0560d26b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will modify the incremental growth deformation gradient of the element to reflect the volume redistribution in the height of the tissue.  <a href="#aace7f6727db271b84db82d0560d26b86">More...</a><br /></td></tr>
<tr class="separator:aace7f6727db271b84db82d0560d26b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45508a35016a845b9c3b2d8f7d51479a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a45508a35016a845b9c3b2d8f7d51479a">calculateFgFromRates</a> (double dt, double x, double y, double z, gsl_matrix *rotMat, gsl_matrix *increment, int sourceTissue, double zMin, double zMax)</td></tr>
<tr class="memdesc:a45508a35016a845b9c3b2d8f7d51479a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This fucntion will calculate the incremental growth deformation gradient change for the current time step, from input growth rates.  <a href="#a45508a35016a845b9c3b2d8f7d51479a">More...</a><br /></td></tr>
<tr class="separator:a45508a35016a845b9c3b2d8f7d51479a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ed61e92393b0d7364a4a99ac0f77f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a23ed61e92393b0d7364a4a99ac0f77f9">calculateFgFromGridCorners</a> (int gridGrowthsInterpolationType, double dt, <a class="el" href="classGrowthFunctionBase.html">GrowthFunctionBase</a> *currGF, gsl_matrix *increment, int sourceTissue, int IndexX, int IndexY, double FracX, double dFracY)</td></tr>
<tr class="memdesc:a23ed61e92393b0d7364a4a99ac0f77f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This fucntion will calculate the incremental growth deformation gradient change for the current time step by reading it from the grid, and interpolating on 4 corners.  <a href="#a23ed61e92393b0d7364a4a99ac0f77f9">More...</a><br /></td></tr>
<tr class="separator:a23ed61e92393b0d7364a4a99ac0f77f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfee9abf0c9b00e278762688525ef333"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acfee9abf0c9b00e278762688525ef333"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#acfee9abf0c9b00e278762688525ef333">getGrowthIncrement</a> ()</td></tr>
<tr class="memdesc:acfee9abf0c9b00e278762688525ef333"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the current growth deformation gradient increment. <br /></td></tr>
<tr class="separator:acfee9abf0c9b00e278762688525ef333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009b5aed1c546db5e517f9f33f67b066"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a009b5aed1c546db5e517f9f33f67b066">updateGrowthIncrement</a> (gsl_matrix *columnar, gsl_matrix *peripodial)</td></tr>
<tr class="memdesc:a009b5aed1c546db5e517f9f33f67b066"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will update the elemental growth deformation gradient from the current growth deformation gradient increment.  <a href="#a009b5aed1c546db5e517f9f33f67b066">More...</a><br /></td></tr>
<tr class="separator:a009b5aed1c546db5e517f9f33f67b066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466480b1e7de98250dd22c8cdb092d54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a466480b1e7de98250dd22c8cdb092d54">updateGrowthByMutation</a> (double dt)</td></tr>
<tr class="memdesc:a466480b1e7de98250dd22c8cdb092d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will update the growth growth deformaton gradient increment of the element due to a mutation.  <a href="#a466480b1e7de98250dd22c8cdb092d54">More...</a><br /></td></tr>
<tr class="separator:a466480b1e7de98250dd22c8cdb092d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c8d69e858be0ad6414f4f5f64eeb3b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33c8d69e858be0ad6414f4f5f64eeb3b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a33c8d69e858be0ad6414f4f5f64eeb3b">scaleGrowthIncrement</a> (double multiuplier)</td></tr>
<tr class="memdesc:a33c8d69e858be0ad6414f4f5f64eeb3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will scale the growth growth deformaton gradient increment by input double. <br /></td></tr>
<tr class="separator:a33c8d69e858be0ad6414f4f5f64eeb3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2423a7dd85ab25b7eb38b5a954d732ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2423a7dd85ab25b7eb38b5a954d732ab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a2423a7dd85ab25b7eb38b5a954d732ab">calculateShapeChangeIncrementFromRates</a> (double dt, double rx, double ry, double rz, gsl_matrix *increment)</td></tr>
<tr class="memdesc:a2423a7dd85ab25b7eb38b5a954d732ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will calculate the current shape change deformation gradient increment due to elemental active shape change, from input rates. <br /></td></tr>
<tr class="separator:a2423a7dd85ab25b7eb38b5a954d732ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab057fa6a1189b6bed5ac9201fc6ca620"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab057fa6a1189b6bed5ac9201fc6ca620"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ab057fa6a1189b6bed5ac9201fc6ca620">updateShapeChangeIncrement</a> (gsl_matrix *columnarShapeChangeIncrement)</td></tr>
<tr class="memdesc:ab057fa6a1189b6bed5ac9201fc6ca620"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function updates the growth increment of the element with the current shape change increment. <br /></td></tr>
<tr class="separator:ab057fa6a1189b6bed5ac9201fc6ca620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04278729ad9cc3238b1966ade0685a3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04278729ad9cc3238b1966ade0685a3d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a04278729ad9cc3238b1966ade0685a3d">calculateRelativePosInBoundingBox</a> (double boundingBoxXMin, double boundingBoxYMin, double boundingBoxLength, double boundingBoxWidth)</td></tr>
<tr class="memdesc:a04278729ad9cc3238b1966ade0685a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will calculate the relative positions of the element in the xy-plane bounding box of the tissue. <br /></td></tr>
<tr class="separator:a04278729ad9cc3238b1966ade0685a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39a584fa424f92b219d0ad903439ae7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af39a584fa424f92b219d0ad903439ae7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#af39a584fa424f92b219d0ad903439ae7">mutateElement</a> (double growthFold, double growthRatePerHour)</td></tr>
<tr class="memdesc:af39a584fa424f92b219d0ad903439ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will set the element as a mutant, the mutant growth rates will be set. <br /></td></tr>
<tr class="separator:af39a584fa424f92b219d0ad903439ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf601cf9b007a1e001b01fb5ed84399a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf601cf9b007a1e001b01fb5ed84399a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#acf601cf9b007a1e001b01fb5ed84399a">updateReferencePositionMatrixFromInput</a> (double **input)</td></tr>
<tr class="memdesc:acf601cf9b007a1e001b01fb5ed84399a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will update the reference position matrix. Not used under healthy, continuous simulations, to preserve continuity of the mesh. <br /></td></tr>
<tr class="separator:acf601cf9b007a1e001b01fb5ed84399a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e17514271f121498ed12cebae3aebe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5e17514271f121498ed12cebae3aebe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ae5e17514271f121498ed12cebae3aebe">displayRelativePosInBoundingBox</a> ()</td></tr>
<tr class="memdesc:ae5e17514271f121498ed12cebae3aebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to display the relative position of the element in the bounding box of the tissue. <br /></td></tr>
<tr class="separator:ae5e17514271f121498ed12cebae3aebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50e45399c54ae205ae1adabbc485ff1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad50e45399c54ae205ae1adabbc485ff1"></a>
std::array&lt; double, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ad50e45399c54ae205ae1adabbc485ff1">getRelativePosInBoundingBox</a> ()</td></tr>
<tr class="memdesc:ad50e45399c54ae205ae1adabbc485ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the relative position of the element in the xy bounding box of the tissue. <br /></td></tr>
<tr class="separator:ad50e45399c54ae205ae1adabbc485ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d8a64fec5591d51c6d54ea76711e0d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71d8a64fec5591d51c6d54ea76711e0d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a71d8a64fec5591d51c6d54ea76711e0d">setRelativePosInBoundingBox</a> (double x, double y)</td></tr>
<tr class="memdesc:a71d8a64fec5591d51c6d54ea76711e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functoin will set the relative position of the element in the bounding box of the tissue to the input coordinates. <br /></td></tr>
<tr class="separator:a71d8a64fec5591d51c6d54ea76711e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7a7578407be503531bf14af6d004d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c7a7578407be503531bf14af6d004d1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a8c7a7578407be503531bf14af6d004d1">setInitialRelativePosInBoundingBox</a> ()</td></tr>
<tr class="memdesc:a8c7a7578407be503531bf14af6d004d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the initial relative position in bounding box of the tissue to current reference position. <br /></td></tr>
<tr class="separator:a8c7a7578407be503531bf14af6d004d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e054f84b56303812eee5b3abeec9b2f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e054f84b56303812eee5b3abeec9b2f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a3e054f84b56303812eee5b3abeec9b2f">setInitialZPosition</a> (double zMax, double TissueHeight)</td></tr>
<tr class="memdesc:a3e054f84b56303812eee5b3abeec9b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This fucntion sets the initial relative z position of the tissue in tissue height. <br /></td></tr>
<tr class="separator:a3e054f84b56303812eee5b3abeec9b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775b57d5074679c6fd4d3f57885e86d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a775b57d5074679c6fd4d3f57885e86d8"></a>
std::array&lt; double, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a775b57d5074679c6fd4d3f57885e86d8">getInitialRelativePosInBoundingBox</a> ()</td></tr>
<tr class="memdesc:a775b57d5074679c6fd4d3f57885e86d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the initial relative position of the element in the xy bounding box of the tissue. <br /></td></tr>
<tr class="separator:a775b57d5074679c6fd4d3f57885e86d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde567878e8335d5f3b82042bcf23e5b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acde567878e8335d5f3b82042bcf23e5b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#acde567878e8335d5f3b82042bcf23e5b">convertRelativePosToGridIndex</a> (std::array&lt; double, 2 &gt; relpos, int &amp;indexX, int &amp;indexY, double &amp;fracX, double &amp;fracY, int nGridX, int nGridY)</td></tr>
<tr class="memdesc:acde567878e8335d5f3b82042bcf23e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will convert the relative position of the tissue in xy plane bounding box to growth map grid indices. <br /></td></tr>
<tr class="separator:acde567878e8335d5f3b82042bcf23e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf99016ea7c36e0bff43a40e6a89df3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aecf99016ea7c36e0bff43a40e6a89df3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aecf99016ea7c36e0bff43a40e6a89df3">getStrain</a> (int type, float &amp;StrainMag)</td></tr>
<tr class="memdesc:aecf99016ea7c36e0bff43a40e6a89df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the selected strain component of the element. <br /></td></tr>
<tr class="separator:aecf99016ea7c36e0bff43a40e6a89df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6971273ad49bfe9a49b2ddf09e426291"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6971273ad49bfe9a49b2ddf09e426291"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a6971273ad49bfe9a49b2ddf09e426291">getNodeBasedPysProp</a> (int type, int NodeNo, const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes, float &amp;PysPropMag)</td></tr>
<tr class="memdesc:a6971273ad49bfe9a49b2ddf09e426291"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the selected physical properties of the element on a nodal basis. <br /></td></tr>
<tr class="separator:a6971273ad49bfe9a49b2ddf09e426291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff91451c3465778ed89624d6196f7f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abff91451c3465778ed89624d6196f7f6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#abff91451c3465778ed89624d6196f7f6">getPysProp</a> (int type, float &amp;PysPropMag, double dt)</td></tr>
<tr class="memdesc:abff91451c3465778ed89624d6196f7f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the selected physical properties of the element. <br /></td></tr>
<tr class="separator:abff91451c3465778ed89624d6196f7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51bc2c7303dfaae0687d1d785b077e81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51bc2c7303dfaae0687d1d785b077e81"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a51bc2c7303dfaae0687d1d785b077e81">getInternalViscosity</a> ()</td></tr>
<tr class="memdesc:a51bc2c7303dfaae0687d1d785b077e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the internal viscosity of the element. <br /></td></tr>
<tr class="separator:a51bc2c7303dfaae0687d1d785b077e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0651f685642cfddf6cefa3542ece51a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0651f685642cfddf6cefa3542ece51a"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ac0651f685642cfddf6cefa3542ece51a">getOriginalInternalViscosity</a> ()</td></tr>
<tr class="memdesc:ac0651f685642cfddf6cefa3542ece51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the internal viscosity of the element prior to any perturbations. <br /></td></tr>
<tr class="separator:ac0651f685642cfddf6cefa3542ece51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade96ff86461eaabce716e83fa68bfa19"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade96ff86461eaabce716e83fa68bfa19"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ade96ff86461eaabce716e83fa68bfa19">getYoungModulus</a> ()</td></tr>
<tr class="memdesc:ade96ff86461eaabce716e83fa68bfa19"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the Young's modulus of the element. <br /></td></tr>
<tr class="separator:ade96ff86461eaabce716e83fa68bfa19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01140f17779cd2e990c9f28e3c86b77e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01140f17779cd2e990c9f28e3c86b77e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a01140f17779cd2e990c9f28e3c86b77e">getPoissonRatio</a> ()</td></tr>
<tr class="memdesc:a01140f17779cd2e990c9f28e3c86b77e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the Poissons's ratio of the element. <br /></td></tr>
<tr class="separator:a01140f17779cd2e990c9f28e3c86b77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348086a2524d9f12ca7748757d6ce645"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a348086a2524d9f12ca7748757d6ce645"></a>
const std::array&lt; double, 3 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a348086a2524d9f12ca7748757d6ce645">getGrowthRate</a> ()</td></tr>
<tr class="memdesc:a348086a2524d9f12ca7748757d6ce645"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the current growth rate of the element. <br /></td></tr>
<tr class="separator:a348086a2524d9f12ca7748757d6ce645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ca43e5283df3a948ab6e56f71fd3c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5ca43e5283df3a948ab6e56f71fd3c6"></a>
const std::array&lt; double, 6 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ac5ca43e5283df3a948ab6e56f71fd3c6">getShapeChangeRate</a> ()</td></tr>
<tr class="memdesc:ac5ca43e5283df3a948ab6e56f71fd3c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the current shape change rate of the element. <br /></td></tr>
<tr class="separator:ac5ca43e5283df3a948ab6e56f71fd3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8362daf177d7d30d0b02aca95a185b25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8362daf177d7d30d0b02aca95a185b25"></a>
const std::vector&lt; std::array&lt; double, 3 &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a8362daf177d7d30d0b02aca95a185b25">getReferencePos</a> ()</td></tr>
<tr class="memdesc:a8362daf177d7d30d0b02aca95a185b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the reference positions of the element. <br /></td></tr>
<tr class="separator:a8362daf177d7d30d0b02aca95a185b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1906a5afda8fcbeef23010759f2538c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1906a5afda8fcbeef23010759f2538c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ab1906a5afda8fcbeef23010759f2538c">getPos</a> (gsl_matrix *Pos)</td></tr>
<tr class="memdesc:ab1906a5afda8fcbeef23010759f2538c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will write the position of the element into input matrix. <br /></td></tr>
<tr class="separator:ab1906a5afda8fcbeef23010759f2538c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79889ef9cb7831a50e5391cb1cc19793"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79889ef9cb7831a50e5391cb1cc19793"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a79889ef9cb7831a50e5391cb1cc19793">getFg</a> ()</td></tr>
<tr class="memdesc:a79889ef9cb7831a50e5391cb1cc19793"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the growth component of the deformation gradient. <br /></td></tr>
<tr class="separator:a79889ef9cb7831a50e5391cb1cc19793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79110e674e80a1e429669ccb5c3e4cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa79110e674e80a1e429669ccb5c3e4cb"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aa79110e674e80a1e429669ccb5c3e4cb">getInvFg</a> ()</td></tr>
<tr class="memdesc:aa79110e674e80a1e429669ccb5c3e4cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the inverse of the growth deformation gradient matrix. <br /></td></tr>
<tr class="separator:aa79110e674e80a1e429669ccb5c3e4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab261573ddd6829df0ee104260352c7ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab261573ddd6829df0ee104260352c7ae"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ab261573ddd6829df0ee104260352c7ae">getFsc</a> ()</td></tr>
<tr class="memdesc:ab261573ddd6829df0ee104260352c7ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the shape change component of the deformation gradient. <br /></td></tr>
<tr class="separator:ab261573ddd6829df0ee104260352c7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884da8f201986aaef5c27efdd4a5b7d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a884da8f201986aaef5c27efdd4a5b7d4"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a884da8f201986aaef5c27efdd4a5b7d4">getInvFsc</a> ()</td></tr>
<tr class="memdesc:a884da8f201986aaef5c27efdd4a5b7d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the inverse of the shape change deformation gradient matrix. <br /></td></tr>
<tr class="separator:a884da8f201986aaef5c27efdd4a5b7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26de227e5135a355667be3a2a86d1431"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26de227e5135a355667be3a2a86d1431"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a26de227e5135a355667be3a2a86d1431">getFe</a> ()</td></tr>
<tr class="memdesc:a26de227e5135a355667be3a2a86d1431"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the elastic component of the deformation gradient. <br /></td></tr>
<tr class="separator:a26de227e5135a355667be3a2a86d1431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4916a23d305f1258ec83b7e53adabea1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4916a23d305f1258ec83b7e53adabea1"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a4916a23d305f1258ec83b7e53adabea1">getZRemodellingSoFar</a> ()</td></tr>
<tr class="memdesc:a4916a23d305f1258ec83b7e53adabea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the z remodelling applied to the element so far, to cap the z remodelling. <br /></td></tr>
<tr class="separator:a4916a23d305f1258ec83b7e53adabea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad225c2235e531e5ee239a127bbf92def"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad225c2235e531e5ee239a127bbf92def"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ad225c2235e531e5ee239a127bbf92def">setZRemodellingSoFar</a> (double <a class="el" href="classShapeBase.html#a0dc566eb70e64da9fc3fa222b16999da">zRemodellingSoFar</a>)</td></tr>
<tr class="memdesc:ad225c2235e531e5ee239a127bbf92def"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will set the z remodelling applied to the element so far to input value. This is needed during saved input reading. <br /></td></tr>
<tr class="separator:ad225c2235e531e5ee239a127bbf92def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a7323c50767ecdc82d8d8ce411b264"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ab8a7323c50767ecdc82d8d8ce411b264">displayName</a> ()</td></tr>
<tr class="memdesc:ab8a7323c50767ecdc82d8d8ce411b264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function, display the name of the element.  <a href="#ab8a7323c50767ecdc82d8d8ce411b264">More...</a><br /></td></tr>
<tr class="separator:ab8a7323c50767ecdc82d8d8ce411b264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324f8fd5dd90c14b621b2f2ee3ec98db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a324f8fd5dd90c14b621b2f2ee3ec98db"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a324f8fd5dd90c14b621b2f2ee3ec98db">displayNodeIds</a> ()</td></tr>
<tr class="memdesc:a324f8fd5dd90c14b621b2f2ee3ec98db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function, display the Ids of the nodes of the element. <br /></td></tr>
<tr class="separator:a324f8fd5dd90c14b621b2f2ee3ec98db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4d0f70caf459dc93f914ef7fc2a053"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca4d0f70caf459dc93f914ef7fc2a053"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aca4d0f70caf459dc93f914ef7fc2a053">displayPositions</a> ()</td></tr>
<tr class="memdesc:aca4d0f70caf459dc93f914ef7fc2a053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function, display the nodal positions of the element. <br /></td></tr>
<tr class="separator:aca4d0f70caf459dc93f914ef7fc2a053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d221cf63220dad3ecf139ffa164698"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2d221cf63220dad3ecf139ffa164698"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#af2d221cf63220dad3ecf139ffa164698">displayReferencePositions</a> ()</td></tr>
<tr class="memdesc:af2d221cf63220dad3ecf139ffa164698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function, display the nodal positions of the reference element. <br /></td></tr>
<tr class="separator:af2d221cf63220dad3ecf139ffa164698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6bb76d8adffaeb7ad36cce8a3f17ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba6bb76d8adffaeb7ad36cce8a3f17ab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aba6bb76d8adffaeb7ad36cce8a3f17ab">displayIdentifierColour</a> ()</td></tr>
<tr class="memdesc:aba6bb76d8adffaeb7ad36cce8a3f17ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function, display the unique identifier colour, for picking in user interface. <br /></td></tr>
<tr class="separator:aba6bb76d8adffaeb7ad36cce8a3f17ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39c3f3a555a89e106c4afaaf81c72f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad39c3f3a555a89e106c4afaaf81c72f6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ad39c3f3a555a89e106c4afaaf81c72f6">setFg</a> (gsl_matrix *currFg)</td></tr>
<tr class="memdesc:ad39c3f3a555a89e106c4afaaf81c72f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the current grwoth deformation gradient matrix equal to input matrix. <br /></td></tr>
<tr class="separator:ad39c3f3a555a89e106c4afaaf81c72f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a100fb162232636bf666eb1603f023"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38a100fb162232636bf666eb1603f023"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a38a100fb162232636bf666eb1603f023">setGrowthWeightsViaTissuePlacement</a> (double periWeight)</td></tr>
<tr class="memdesc:a38a100fb162232636bf666eb1603f023"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the weight for growth rate scaling depending on tissue type. <br /></td></tr>
<tr class="separator:a38a100fb162232636bf666eb1603f023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27bc09051d65ebc27e31b67462950070"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27bc09051d65ebc27e31b67462950070"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a27bc09051d65ebc27e31b67462950070">setYoungsModulus</a> (double <a class="el" href="classShapeBase.html#a6c1a3a0173841d6072a5268978463ff2">E</a>)</td></tr>
<tr class="memdesc:a27bc09051d65ebc27e31b67462950070"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the Young's modulus of the shape to inout double. <br /></td></tr>
<tr class="separator:a27bc09051d65ebc27e31b67462950070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3988352864bd06d7509b74977320d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac3988352864bd06d7509b74977320d8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aac3988352864bd06d7509b74977320d8">setElasticProperties</a> (double, double, double, double, double)</td></tr>
<tr class="memdesc:aac3988352864bd06d7509b74977320d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the parent virtual function for setting up the elasticity properties of the shape depending on its tissue type placement. <br /></td></tr>
<tr class="separator:aac3988352864bd06d7509b74977320d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab277fb6868925516b675821add019cef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab277fb6868925516b675821add019cef"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ab277fb6868925516b675821add019cef">checkEdgeLenghtsForBinding</a> (std::vector&lt; int &gt; &amp;, std::vector&lt; int &gt; &amp;)</td></tr>
<tr class="memdesc:ab277fb6868925516b675821add019cef"><td class="mdescLeft">&#160;</td><td class="mdescRight">The virt. <br /></td></tr>
<tr class="separator:ab277fb6868925516b675821add019cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e051a82edb9b987edfbd783076e348"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ac4e051a82edb9b987edfbd783076e348">setViscosity</a> (double viscosityApical, double viscosityBasal, double viscosityMid)</td></tr>
<tr class="memdesc:ac4e051a82edb9b987edfbd783076e348"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the viscosity of the element depending on its placement in the tissue.  <a href="#ac4e051a82edb9b987edfbd783076e348">More...</a><br /></td></tr>
<tr class="separator:ac4e051a82edb9b987edfbd783076e348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6ffc8d699795e4efb867efd065a679"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a8b6ffc8d699795e4efb867efd065a679">setViscosity</a> (double viscosityApical, double viscosityBasal)</td></tr>
<tr class="memdesc:a8b6ffc8d699795e4efb867efd065a679"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the viscosity of the element depending on its placement in the tissue.  <a href="#a8b6ffc8d699795e4efb867efd065a679">More...</a><br /></td></tr>
<tr class="separator:a8b6ffc8d699795e4efb867efd065a679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17e8a052b0a2bf5b11f6d5498d61923"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae17e8a052b0a2bf5b11f6d5498d61923"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ae17e8a052b0a2bf5b11f6d5498d61923">setViscosity</a> (double viscosity)</td></tr>
<tr class="memdesc:ae17e8a052b0a2bf5b11f6d5498d61923"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the viscosity of the element depending on its placement in the tissue. <br /></td></tr>
<tr class="separator:ae17e8a052b0a2bf5b11f6d5498d61923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eecbff8db98871f4b5f1ee0992f3d6d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a3eecbff8db98871f4b5f1ee0992f3d6d">calculateEmergentShapeOrientation</a> ()</td></tr>
<tr class="memdesc:a3eecbff8db98871f4b5f1ee0992f3d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This fucntion calculates the orientation of the emergent shape of an element in the xy plane of the tissue.  <a href="#a3eecbff8db98871f4b5f1ee0992f3d6d">More...</a><br /></td></tr>
<tr class="separator:a3eecbff8db98871f4b5f1ee0992f3d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9cfd1ae56e018477dd3642d4d769d90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ae9cfd1ae56e018477dd3642d4d769d90">isActinStiffnessChangeAppliedToElement</a> (bool ThereIsWholeTissueStiffnessPerturbation, bool ThereIsApicalStiffnessPerturbation, bool ThereIsBasalStiffnessPerturbation, bool ThereIsBasolateralWithApicalRelaxationStiffnessPerturbation, bool ThereIsBasolateralStiffnessPerturbation, std::vector&lt; int &gt; &amp;stiffnessPerturbationEllipseBandIds, int numberOfStiffnessPerturbationAppliesEllipseBands)</td></tr>
<tr class="memdesc:ae9cfd1ae56e018477dd3642d4d769d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function decides if the actin stiffness perturbation is applied to this element.  <a href="#ae9cfd1ae56e018477dd3642d4d769d90">More...</a><br /></td></tr>
<tr class="separator:ae9cfd1ae56e018477dd3642d4d769d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1572ddb1f68178e0607873a432f227c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1572ddb1f68178e0607873a432f227c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ab1572ddb1f68178e0607873a432f227c">isECMChangeAppliedToElement</a> (bool changeApicalECM, bool changeBasalECM, std::vector&lt; int &gt; &amp;ECMChangeEllipseBandIds, int numberOfECMChangeEllipseBands)</td></tr>
<tr class="memdesc:ab1572ddb1f68178e0607873a432f227c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function decides if the ECM perturbation is applied to this element. <br /></td></tr>
<tr class="separator:ab1572ddb1f68178e0607873a432f227c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff9e4c602276e9aec411d7a05e83a118"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff9e4c602276e9aec411d7a05e83a118"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aff9e4c602276e9aec411d7a05e83a118">isShapeChangeAppliedToElement</a> (std::vector&lt; int &gt; &amp;ellipseBandIds, bool applyBasalECM, bool applyToLateralECM, bool applyApically, bool applyBasally, bool applyMidLayer)</td></tr>
<tr class="memdesc:aff9e4c602276e9aec411d7a05e83a118"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function decides if the shape change perturbation is applied to this element. <br /></td></tr>
<tr class="separator:aff9e4c602276e9aec411d7a05e83a118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef460b84dc469f89742af7c19411454f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aef460b84dc469f89742af7c19411454f">calculateStiffnessPerturbationRate</a> (bool ThereIsBasolateralWithApicalRelaxationStiffnessPerturbation, double stiffnessPerturbationBeginTimeInSec, double stiffnessPerturbationEndTimeInSec, double stiffnessChangedToFractionOfOriginal)</td></tr>
<tr class="memdesc:aef460b84dc469f89742af7c19411454f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will calciulate the stiffness perturbation rate.  <a href="#aef460b84dc469f89742af7c19411454f">More...</a><br /></td></tr>
<tr class="separator:aef460b84dc469f89742af7c19411454f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb97c0c1a988e77126809745b191c02"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4eb97c0c1a988e77126809745b191c02"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a4eb97c0c1a988e77126809745b191c02">updateStiffnessMultiplier</a> (double dt)</td></tr>
<tr class="memdesc:a4eb97c0c1a988e77126809745b191c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function will update the actin multiplier as a result of stiffness perturbations. <br /></td></tr>
<tr class="separator:a4eb97c0c1a988e77126809745b191c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12eb565639695764997f8cb81e801055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12eb565639695764997f8cb81e801055"></a>
virtual std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a12eb565639695764997f8cb81e801055">calculateBasalNormal</a> ()</td></tr>
<tr class="memdesc:a12eb565639695764997f8cb81e801055"><td class="mdescLeft">&#160;</td><td class="mdescRight">The virtual function of the parent for basal normal calculation. The value is dependent on node topology of the element and defined for eac individual child class. <br /></td></tr>
<tr class="separator:a12eb565639695764997f8cb81e801055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82400cae7963721655c867547caf6a76"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82400cae7963721655c867547caf6a76"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a82400cae7963721655c867547caf6a76">calculateApicalNormalCurrentShape</a> ()</td></tr>
<tr class="memdesc:a82400cae7963721655c867547caf6a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">The virtual function of the parent for apical normal calculation. The value is dependent on node topology of the element and defined for eac individual child class. <br /></td></tr>
<tr class="separator:a82400cae7963721655c867547caf6a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c05f660fb3d68482c8ba751b68b2ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2c05f660fb3d68482c8ba751b68b2ed"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ac2c05f660fb3d68482c8ba751b68b2ed">calculateCurrentGrowthIncrement</a> (gsl_matrix *resultingGrowthIncrement, double dt, double growthx, double growthy, double growthz, gsl_matrix *ShearAngleRotationMatrix)</td></tr>
<tr class="memdesc:ac2c05f660fb3d68482c8ba751b68b2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function calculates the current growth increment from the input of growth rate and the orientation rotation matrix. <br /></td></tr>
<tr class="separator:ac2c05f660fb3d68482c8ba751b68b2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227d409b04d95e3110db851a9cb3ed8c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a227d409b04d95e3110db851a9cb3ed8c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateShapeChangeRate</b> (double x, double y, double z, double xy, double yz, double xz)</td></tr>
<tr class="separator:a227d409b04d95e3110db851a9cb3ed8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab86b6c4eef2ea6232dd1d0c300ae5602"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab86b6c4eef2ea6232dd1d0c300ae5602"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ab86b6c4eef2ea6232dd1d0c300ae5602">calculateElementShapeFunctionDerivatives</a> ()</td></tr>
<tr class="memdesc:ab86b6c4eef2ea6232dd1d0c300ae5602"><td class="mdescLeft">&#160;</td><td class="mdescRight">The virtual function of the parent for calculation of shape function derivatives. This is topology dependent and implemented in each child shape type. <br /></td></tr>
<tr class="separator:ab86b6c4eef2ea6232dd1d0c300ae5602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca6ea9484bbc995d941f1a7bb25e1db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acca6ea9484bbc995d941f1a7bb25e1db"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#acca6ea9484bbc995d941f1a7bb25e1db">calculateCurrNodalForces</a> (gsl_matrix *, gsl_matrix *, gsl_matrix *, gsl_matrix *, int)</td></tr>
<tr class="memdesc:acca6ea9484bbc995d941f1a7bb25e1db"><td class="mdescLeft">&#160;</td><td class="mdescRight">The virtual function to calculate nodal force. This is topology dependent and implemented in each child shape type. <br /></td></tr>
<tr class="separator:acca6ea9484bbc995d941f1a7bb25e1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1dc3dcba4b76026ce83fb7b78c0831"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c1dc3dcba4b76026ce83fb7b78c0831"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>calculateCurrTriPointFForRotation</b> (gsl_matrix *, int)</td></tr>
<tr class="separator:a9c1dc3dcba4b76026ce83fb7b78c0831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010092ac7af5667facbbb8fb6bd98976"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a010092ac7af5667facbbb8fb6bd98976"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a010092ac7af5667facbbb8fb6bd98976">calculateApicalArea</a> ()</td></tr>
<tr class="memdesc:a010092ac7af5667facbbb8fb6bd98976"><td class="mdescLeft">&#160;</td><td class="mdescRight">The virtual function to calculate apical area of element. This is topology dependent and implemented in each child shape type. <br /></td></tr>
<tr class="separator:a010092ac7af5667facbbb8fb6bd98976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc80947335afbc181fca326e9a6b7fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0bc80947335afbc181fca326e9a6b7fb"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a0bc80947335afbc181fca326e9a6b7fb">calculateBasalArea</a> ()</td></tr>
<tr class="memdesc:a0bc80947335afbc181fca326e9a6b7fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The virtual function to calculate basal area of element. This is topology dependent and implemented in each child shape type. <br /></td></tr>
<tr class="separator:a0bc80947335afbc181fca326e9a6b7fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ffd31ed76797d558b085fe754cc4b3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a58ffd31ed76797d558b085fe754cc4b3">calculateCurrentGrownAndEmergentVolumes</a> ()</td></tr>
<tr class="memdesc:a58ffd31ed76797d558b085fe754cc4b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function to calculate hte current ideal volume of the element and its current apparent volume.  <a href="#a58ffd31ed76797d558b085fe754cc4b3">More...</a><br /></td></tr>
<tr class="separator:a58ffd31ed76797d558b085fe754cc4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018cc92b513ff64b919c374b0767cc1b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a018cc92b513ff64b919c374b0767cc1b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a018cc92b513ff64b919c374b0767cc1b">updateElasticProperties</a> ()</td></tr>
<tr class="memdesc:a018cc92b513ff64b919c374b0767cc1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions updates elastic propertiesand their dependent tensors upon alteration of a physical property. <br /></td></tr>
<tr class="separator:a018cc92b513ff64b919c374b0767cc1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e7d2fb83a97d57922c145dcc9be2f09"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e7d2fb83a97d57922c145dcc9be2f09"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a5e7d2fb83a97d57922c145dcc9be2f09">writeInternalForcesTogeAndgv</a> (gsl_matrix *ge, gsl_matrix *gvInternal, std::vector&lt; std::array&lt; double, 3 &gt;&gt; &amp;SystemForces, const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes)</td></tr>
<tr class="memdesc:a5e7d2fb83a97d57922c145dcc9be2f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes the elemental elastic and viscous forces to the system scale force vector. <br /></td></tr>
<tr class="separator:a5e7d2fb83a97d57922c145dcc9be2f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e69d4ab492428c657941fa3b9423cef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e69d4ab492428c657941fa3b9423cef"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>calculateForces</b> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes, gsl_matrix *displacementPerDt)</td></tr>
<tr class="separator:a7e69d4ab492428c657941fa3b9423cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14199858399bf70d6cc1b33cfdd6bf01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14199858399bf70d6cc1b33cfdd6bf01"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a14199858399bf70d6cc1b33cfdd6bf01">updatePositions</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes)</td></tr>
<tr class="memdesc:a14199858399bf70d6cc1b33cfdd6bf01"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function updates the position array of the element from the updated nodal posiitons. <br /></td></tr>
<tr class="separator:a14199858399bf70d6cc1b33cfdd6bf01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac06c53088788e3c1461233623f506dbb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac06c53088788e3c1461233623f506dbb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ac06c53088788e3c1461233623f506dbb">setGrowthRate</a> (double dt, double rx, double ry, double rz)</td></tr>
<tr class="memdesc:ac06c53088788e3c1461233623f506dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the growth of the element from the tome step and the input rates. <br /></td></tr>
<tr class="separator:ac06c53088788e3c1461233623f506dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9572e9a52675224dfada4f4de366f05d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9572e9a52675224dfada4f4de366f05d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a9572e9a52675224dfada4f4de366f05d">setGrowthRateViaInputTimeMultipliedMagnitude</a> (double x, double y, double z)</td></tr>
<tr class="memdesc:a9572e9a52675224dfada4f4de366f05d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the growht rate to pre-calculated rates given as input. <br /></td></tr>
<tr class="separator:a9572e9a52675224dfada4f4de366f05d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d7957431a1ae402347efb03ad94d0e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7d7957431a1ae402347efb03ad94d0e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ad7d7957431a1ae402347efb03ad94d0e">updateGrowthIncrementFromRate</a> ()</td></tr>
<tr class="memdesc:ad7d7957431a1ae402347efb03ad94d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function fills th egrowht increment matirx from the current growth rate matrix. <br /></td></tr>
<tr class="separator:ad7d7957431a1ae402347efb03ad94d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda828c652c3253076530000226a5dbb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeda828c652c3253076530000226a5dbb"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aeda828c652c3253076530000226a5dbb">calculateVolumeForInputShapeStructure</a> (std::vector&lt; std::array&lt; double, 3 &gt;&gt; shapePositions, size_t nTriangularFaces, std::vector&lt; std::array&lt; int, 3 &gt;&gt; triangularFaces, std::array&lt; double, 3 &gt; midPoint)</td></tr>
<tr class="memdesc:aeda828c652c3253076530000226a5dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the volume of the shape, it is generalised such that the shape is defined as an array of triengles forming a convex hull. <br /></td></tr>
<tr class="separator:aeda828c652c3253076530000226a5dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cde54fe712bac297fa73949d07c1bd4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3cde54fe712bac297fa73949d07c1bd4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a3cde54fe712bac297fa73949d07c1bd4">calculatePrincipalStrains3D</a> (double &amp;e1, double &amp;e2, double &amp;e3, gsl_matrix *eigenVec)</td></tr>
<tr class="memdesc:a3cde54fe712bac297fa73949d07c1bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the principal components of the strains through eigen values and eigen vectors in 3D. <br /></td></tr>
<tr class="separator:a3cde54fe712bac297fa73949d07c1bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe833f9684db5cc1847761b6bbd9aa9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fe833f9684db5cc1847761b6bbd9aa9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a6fe833f9684db5cc1847761b6bbd9aa9">calculatePrincipalStrains2D</a> (double &amp;e1, double &amp;e2, double &amp;e3, gsl_matrix *eigenVec)</td></tr>
<tr class="memdesc:a6fe833f9684db5cc1847761b6bbd9aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the principal components of the strains through eigen values and eigen vectors in 2D. <br /></td></tr>
<tr class="separator:a6fe833f9684db5cc1847761b6bbd9aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9f91384133d8953dbb38d71cc29d51"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a9f91384133d8953dbb38d71cc29d51"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a8a9f91384133d8953dbb38d71cc29d51">setShapeChangeRate</a> (double x, double y, double z, double xy, double yz, double xz)</td></tr>
<tr class="memdesc:a8a9f91384133d8953dbb38d71cc29d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the shape change rate to pre-calculated rates given as input. <br /></td></tr>
<tr class="separator:a8a9f91384133d8953dbb38d71cc29d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adacee19f788f056fe794bde14b934063"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adacee19f788f056fe794bde14b934063"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#adacee19f788f056fe794bde14b934063">setShapeChangeInrementToIdentity</a> ()</td></tr>
<tr class="memdesc:adacee19f788f056fe794bde14b934063"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the shape change deformation gradient increment to identity. <br /></td></tr>
<tr class="separator:adacee19f788f056fe794bde14b934063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3292b2b5d9fd3430a21914031614ccdd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3292b2b5d9fd3430a21914031614ccdd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a3292b2b5d9fd3430a21914031614ccdd">updateElementVolumesAndTissuePlacementsForSave</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes)</td></tr>
<tr class="memdesc:a3292b2b5d9fd3430a21914031614ccdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the reference volume, tissue placement and tissue type from nodal information. <br /></td></tr>
<tr class="separator:a3292b2b5d9fd3430a21914031614ccdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fba51323da7719de06fba53077eebc4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4fba51323da7719de06fba53077eebc4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a4fba51323da7719de06fba53077eebc4">readNodeIdData</a> (std::ifstream &amp;file)</td></tr>
<tr class="memdesc:a4fba51323da7719de06fba53077eebc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads in the node Ids for the element from save file. <br /></td></tr>
<tr class="separator:a4fba51323da7719de06fba53077eebc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123de76dba6d7d9242c2931d79e47e37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a123de76dba6d7d9242c2931d79e47e37"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a123de76dba6d7d9242c2931d79e47e37">readReferencePositionData</a> (std::ifstream &amp;file)</td></tr>
<tr class="memdesc:a123de76dba6d7d9242c2931d79e47e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads the reference element positions from save file. <br /></td></tr>
<tr class="separator:a123de76dba6d7d9242c2931d79e47e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aeacce216911def0e0c54b1bb4286bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4aeacce216911def0e0c54b1bb4286bd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a4aeacce216911def0e0c54b1bb4286bd">areanyOfMyNodesAtCircumference</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; &gt; &amp;Nodes)</td></tr>
<tr class="memdesc:a4aeacce216911def0e0c54b1bb4286bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function check if the element owns any node at tissue circumference. <br /></td></tr>
<tr class="separator:a4aeacce216911def0e0c54b1bb4286bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6927dd05e3f6aa1c5ac5d32a30b5da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb6927dd05e3f6aa1c5ac5d32a30b5da"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#adb6927dd05e3f6aa1c5ac5d32a30b5da">checkHealth</a> ()</td></tr>
<tr class="memdesc:adb6927dd05e3f6aa1c5ac5d32a30b5da"><td class="mdescLeft">&#160;</td><td class="mdescRight">The virtual function in parent to check if element is flipped, implemented for each child as it is node topology dependent. <br /></td></tr>
<tr class="separator:adb6927dd05e3f6aa1c5ac5d32a30b5da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfdde187477364a5a0e2220ea6b2e0e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2bfdde187477364a5a0e2220ea6b2e0e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a2bfdde187477364a5a0e2220ea6b2e0e">writeKelasticToMainKatrix</a> (gsl_matrix *K)</td></tr>
<tr class="memdesc:a2bfdde187477364a5a0e2220ea6b2e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes the elemental elastic component of the Jacobian to system Jacobian. <br /></td></tr>
<tr class="separator:a2bfdde187477364a5a0e2220ea6b2e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388d38c2d6588c7ddf622f1deed53853"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a388d38c2d6588c7ddf622f1deed53853"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a388d38c2d6588c7ddf622f1deed53853">writeKviscousToMainKatrix</a> (gsl_matrix *K)</td></tr>
<tr class="memdesc:a388d38c2d6588c7ddf622f1deed53853"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes the elemental viscous component of the Jacobian to system Jacobian. <br /></td></tr>
<tr class="separator:a388d38c2d6588c7ddf622f1deed53853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922c41864d4826725cc72089046f818c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a922c41864d4826725cc72089046f818c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a922c41864d4826725cc72089046f818c">calculateImplicitKElastic</a> ()</td></tr>
<tr class="memdesc:a922c41864d4826725cc72089046f818c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the elemental elastic component of the Jacobian for implicit NR itaration. <br /></td></tr>
<tr class="separator:a922c41864d4826725cc72089046f818c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c23d30b7f9f3bc7ed2fde542401aeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a20c23d30b7f9f3bc7ed2fde542401aeb">calculateImplicitKViscous</a> (gsl_matrix *displacementPerDt, double dt)</td></tr>
<tr class="memdesc:a20c23d30b7f9f3bc7ed2fde542401aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the elemental viscous component of the Jacobian for implicit NR itaration.  <a href="#a20c23d30b7f9f3bc7ed2fde542401aeb">More...</a><br /></td></tr>
<tr class="separator:a20c23d30b7f9f3bc7ed2fde542401aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9f16ddb320974584323d78ca4aec9c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a9f16ddb320974584323d78ca4aec9c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a6a9f16ddb320974584323d78ca4aec9c">calculateForceFromStress</a> (int nodeId, gsl_matrix *Externalstress, gsl_matrix *ExternalNodalForces)</td></tr>
<tr class="memdesc:a6a9f16ddb320974584323d78ca4aec9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the elemental nodal forces from an input external stress matrix. <br /></td></tr>
<tr class="separator:a6a9f16ddb320974584323d78ca4aec9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570d553851b58e0c12f45f2d70344eea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a570d553851b58e0c12f45f2d70344eea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a570d553851b58e0c12f45f2d70344eea">updateShapeFromSave</a> (std::ifstream &amp;file)</td></tr>
<tr class="memdesc:a570d553851b58e0c12f45f2d70344eea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function updates the element geometric poroerties from save file. <br /></td></tr>
<tr class="separator:a570d553851b58e0c12f45f2d70344eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1912b0fe9cfe98ed4b377774c2f0c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef1912b0fe9cfe98ed4b377774c2f0c7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aef1912b0fe9cfe98ed4b377774c2f0c7">displayMatrix</a> (boost::numeric::ublas::matrix&lt; double &gt; &amp;mat, std::string matname)</td></tr>
<tr class="memdesc:aef1912b0fe9cfe98ed4b377774c2f0c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function, displays the input blas (double) matrix with the input name. <br /></td></tr>
<tr class="separator:aef1912b0fe9cfe98ed4b377774c2f0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b74c35e2d5a2abed9c521c735f1954a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b74c35e2d5a2abed9c521c735f1954a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a2b74c35e2d5a2abed9c521c735f1954a">displayMatrix</a> (boost::numeric::ublas::matrix&lt; int &gt; &amp;mat, std::string matname)</td></tr>
<tr class="memdesc:a2b74c35e2d5a2abed9c521c735f1954a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function, displays the input blas (int) matrix with the input name. <br /></td></tr>
<tr class="separator:a2b74c35e2d5a2abed9c521c735f1954a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662efa15155aa6e90ccc1102563dada8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a662efa15155aa6e90ccc1102563dada8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a662efa15155aa6e90ccc1102563dada8">displayMatrix</a> (boost::numeric::ublas::vector&lt; double &gt; &amp;vec, std::string matname)</td></tr>
<tr class="memdesc:a662efa15155aa6e90ccc1102563dada8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function, displays the input blas (double) vector with the input name. <br /></td></tr>
<tr class="separator:a662efa15155aa6e90ccc1102563dada8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb781fb01957dfb519eb1863bb64d7ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb781fb01957dfb519eb1863bb64d7ab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#abb781fb01957dfb519eb1863bb64d7ab">displayMatrix</a> (gsl_matrix *mat, std::string matname)</td></tr>
<tr class="memdesc:abb781fb01957dfb519eb1863bb64d7ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function, displays the input gsl matrix with the input name. <br /></td></tr>
<tr class="separator:abb781fb01957dfb519eb1863bb64d7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0283ac144e865859f4e7bb455e06bee9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0283ac144e865859f4e7bb455e06bee9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a0283ac144e865859f4e7bb455e06bee9">displayMatrix</a> (gsl_vector *mat, std::string matname)</td></tr>
<tr class="memdesc:a0283ac144e865859f4e7bb455e06bee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function, displays the input gsl vector with the input name. <br /></td></tr>
<tr class="separator:a0283ac144e865859f4e7bb455e06bee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b37ec963a6078a7e03512d23470c257"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b37ec963a6078a7e03512d23470c257"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a4b37ec963a6078a7e03512d23470c257">createMatrixCopy</a> (gsl_matrix *dest, gsl_matrix *src)</td></tr>
<tr class="memdesc:a4b37ec963a6078a7e03512d23470c257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function, creates a copy of the gsl matrix on new memory locaiton. <br /></td></tr>
<tr class="separator:a4b37ec963a6078a7e03512d23470c257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f6cfbda8b021fd4e55ca1e3676f7c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31f6cfbda8b021fd4e55ca1e3676f7c6"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a31f6cfbda8b021fd4e55ca1e3676f7c6">calculateMagnitudeVector3D</a> (std::array&lt; double, 3 &gt; <a class="el" href="classShapeBase.html#a8b4c2d3bfbc6c9785c5181a56f929151">v</a>)</td></tr>
<tr class="memdesc:a31f6cfbda8b021fd4e55ca1e3676f7c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper algebraic function, calculates norm of the vector defined in the array&lt;double,3&gt;;. <br /></td></tr>
<tr class="separator:a31f6cfbda8b021fd4e55ca1e3676f7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7ca6bbc30107ed82e73694f9c34717"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e7ca6bbc30107ed82e73694f9c34717"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a9e7ca6bbc30107ed82e73694f9c34717">normaliseVector3D</a> (gsl_vector *<a class="el" href="classShapeBase.html#a8b4c2d3bfbc6c9785c5181a56f929151">v</a>)</td></tr>
<tr class="memdesc:a9e7ca6bbc30107ed82e73694f9c34717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper algebraic function, normalises the input gsl vector (the input vector is modified) <br /></td></tr>
<tr class="separator:a9e7ca6bbc30107ed82e73694f9c34717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefffe34f00f3e65c0894dacdc5f5bf5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acefffe34f00f3e65c0894dacdc5f5bf5"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#acefffe34f00f3e65c0894dacdc5f5bf5">normaliseVector3D</a> (std::array&lt; double, 3 &gt; &amp;<a class="el" href="classShapeBase.html#a8b4c2d3bfbc6c9785c5181a56f929151">v</a>)</td></tr>
<tr class="memdesc:acefffe34f00f3e65c0894dacdc5f5bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper algebraic function, normalises the input array&lt;double,3&gt; (the input vector is modified) <br /></td></tr>
<tr class="separator:acefffe34f00f3e65c0894dacdc5f5bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c436dca2006e445f7949bc34f08e3c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38c436dca2006e445f7949bc34f08e3c"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a38c436dca2006e445f7949bc34f08e3c">getNormVector3D</a> (gsl_vector *<a class="el" href="classShapeBase.html#a8b4c2d3bfbc6c9785c5181a56f929151">v</a>)</td></tr>
<tr class="memdesc:a38c436dca2006e445f7949bc34f08e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper algebraic function, calculates norm of the vector defined in the gsl vector, the vector is not modified. <br /></td></tr>
<tr class="separator:a38c436dca2006e445f7949bc34f08e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86161effaf1c7c607aba51609a99e70"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad86161effaf1c7c607aba51609a99e70"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ad86161effaf1c7c607aba51609a99e70">determinant3by3Matrix</a> (boost::numeric::ublas::matrix&lt; double &gt; &amp;Mat)</td></tr>
<tr class="memdesc:ad86161effaf1c7c607aba51609a99e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper algebraic function, calculates determinant of 3by3 boost matrix. <br /></td></tr>
<tr class="separator:ad86161effaf1c7c607aba51609a99e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52dce091d2e8369f546df9adeb1e6c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af52dce091d2e8369f546df9adeb1e6c0"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#af52dce091d2e8369f546df9adeb1e6c0">determinant3by3Matrix</a> (gsl_matrix *Mat)</td></tr>
<tr class="memdesc:af52dce091d2e8369f546df9adeb1e6c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper algebraic function, calculates determinant of 3by3 gsl matrix. <br /></td></tr>
<tr class="separator:af52dce091d2e8369f546df9adeb1e6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f1a594c4be91e71f567cc04290a7f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32f1a594c4be91e71f567cc04290a7f5"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a32f1a594c4be91e71f567cc04290a7f5">determinant2by2Matrix</a> (boost::numeric::ublas::matrix&lt; double &gt; &amp;Mat)</td></tr>
<tr class="memdesc:a32f1a594c4be91e71f567cc04290a7f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper algebraic function, calculates determinant of 2by2 boost matrix. <br /></td></tr>
<tr class="separator:a32f1a594c4be91e71f567cc04290a7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8334f4c3c865792f57ffb456ea61212b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8334f4c3c865792f57ffb456ea61212b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>calculateRotationAngleSinCos</b> (std::array&lt; double, 3 &gt; &amp;u, std::array&lt; double, 3 &gt; &amp;<a class="el" href="classShapeBase.html#a8b4c2d3bfbc6c9785c5181a56f929151">v</a>, double &amp;c, double &amp;s)</td></tr>
<tr class="separator:a8334f4c3c865792f57ffb456ea61212b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06df78e90e5d7bcb9898c2844ecf2e60"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06df78e90e5d7bcb9898c2844ecf2e60"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a06df78e90e5d7bcb9898c2844ecf2e60">calculateRotationAxis</a> (const std::array&lt; double, 3 &gt; &amp;u, const std::array&lt; double, 3 &gt; &amp;<a class="el" href="classShapeBase.html#a8b4c2d3bfbc6c9785c5181a56f929151">v</a>, std::array&lt; double, 3 &gt; &amp;rotAx, double c)</td></tr>
<tr class="memdesc:a06df78e90e5d7bcb9898c2844ecf2e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper algebraic function calculates the sine and cosine of the rotation angle needed to align vector u onto v. <br /></td></tr>
<tr class="separator:a06df78e90e5d7bcb9898c2844ecf2e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ea30d81c19c9f7c904af66310c750b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ac5ea30d81c19c9f7c904af66310c750b">constructRotationMatrix</a> (double c, double s, double *rotAx, double *rotMat)</td></tr>
<tr class="memdesc:ac5ea30d81c19c9f7c904af66310c750b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper algebraic function calculates the rotation axis needed to align vector u onto v.  <a href="#ac5ea30d81c19c9f7c904af66310c750b">More...</a><br /></td></tr>
<tr class="separator:ac5ea30d81c19c9f7c904af66310c750b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c9e11497d04d084fdfe72654bbfb174"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c9e11497d04d084fdfe72654bbfb174"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a4c9e11497d04d084fdfe72654bbfb174">constructRotationMatrix</a> (double c, double s, std::array&lt; double, 3 &gt; &amp;rotAx, std::array&lt; double, 9 &gt; &amp;rotMat)</td></tr>
<tr class="memdesc:a4c9e11497d04d084fdfe72654bbfb174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper algebraic functio calculates the rotation matrix from input sine, cosine of the rotation angle and the rotation axis. Writes the matrix into the input rotMat. <br /></td></tr>
<tr class="separator:a4c9e11497d04d084fdfe72654bbfb174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad803a237b7e7c06d419a308625a599e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad803a237b7e7c06d419a308625a599e0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ad803a237b7e7c06d419a308625a599e0">rotateVectorByRotationMatrix</a> (double *u, double *rotMat)</td></tr>
<tr class="memdesc:ad803a237b7e7c06d419a308625a599e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper algebraic function rotates the input vector v by rotation matrix rotMat. <br /></td></tr>
<tr class="separator:ad803a237b7e7c06d419a308625a599e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a573072213ea91314c8f1101f106bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14a573072213ea91314c8f1101f106bb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a14a573072213ea91314c8f1101f106bb">rotateVectorByRotationMatrix</a> (double *u, gsl_matrix *rotMat)</td></tr>
<tr class="memdesc:a14a573072213ea91314c8f1101f106bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper algebraic function rotates the input vector v by rotation matrix rotMat. <br /></td></tr>
<tr class="separator:a14a573072213ea91314c8f1101f106bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb9c0192df7d4de8232b52e7e3009ec5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb9c0192df7d4de8232b52e7e3009ec5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#adb9c0192df7d4de8232b52e7e3009ec5">rotateVectorByRotationMatrix</a> (std::array&lt; double, 3 &gt; &amp;u, std::array&lt; double, 9 &gt; rotMat)</td></tr>
<tr class="memdesc:adb9c0192df7d4de8232b52e7e3009ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper algebraic function rotates the input vector v by rotation matrix rotMat. <br /></td></tr>
<tr class="separator:adb9c0192df7d4de8232b52e7e3009ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae4c5fc8817528493502e3f75c9a984"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a9ae4c5fc8817528493502e3f75c9a984">CalculateGrowthRotationByF</a> ()</td></tr>
<tr class="memdesc:a9ae4c5fc8817528493502e3f75c9a984"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the rigid body rotation of the element around the z axis of the tissue from hte fecormation gradient.  <a href="#a9ae4c5fc8817528493502e3f75c9a984">More...</a><br /></td></tr>
<tr class="separator:a9ae4c5fc8817528493502e3f75c9a984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5e95f38f271d28f2856109b0256aa0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f5e95f38f271d28f2856109b0256aa0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a5f5e95f38f271d28f2856109b0256aa0">calculateTriPointFForRatation</a> ()</td></tr>
<tr class="memdesc:a5f5e95f38f271d28f2856109b0256aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the current deformaiton gradient as averaged at all Gauss points, for rigid body rotation extraction. <br /></td></tr>
<tr class="separator:a5f5e95f38f271d28f2856109b0256aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36cea09cbf418a9e37454016c5b3f30"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa36cea09cbf418a9e37454016c5b3f30"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aa36cea09cbf418a9e37454016c5b3f30">setPlasticDeformationIncrement</a> (double xx, double yy, double zz)</td></tr>
<tr class="memdesc:aa36cea09cbf418a9e37454016c5b3f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets diagonal of the plastic deformation gradient increment from input values. <br /></td></tr>
<tr class="separator:aa36cea09cbf418a9e37454016c5b3f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ee0eeca30fdd381d294b383c3baf0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a29ee0eeca30fdd381d294b383c3baf0c">growShapeByFg</a> ()</td></tr>
<tr class="memdesc:a29ee0eeca30fdd381d294b383c3baf0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function updates the current growth deformaiton gradient with the growt/shape change/plastic deformation increments and their respective rotations.  <a href="#a29ee0eeca30fdd381d294b383c3baf0c">More...</a><br /></td></tr>
<tr class="separator:a29ee0eeca30fdd381d294b383c3baf0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5409de18ee9e47af0bb977f4a1e608fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a5409de18ee9e47af0bb977f4a1e608fb">changeShapeByFsc</a> (double dt)</td></tr>
<tr class="memdesc:a5409de18ee9e47af0bb977f4a1e608fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the shape change increment from shape change rates.  <a href="#a5409de18ee9e47af0bb977f4a1e608fb">More...</a><br /></td></tr>
<tr class="separator:a5409de18ee9e47af0bb977f4a1e608fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff5db36385d757b38b7caa117686ec1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afff5db36385d757b38b7caa117686ec1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#afff5db36385d757b38b7caa117686ec1">checkIfInsideEllipseBands</a> (int nMarkerEllipseRanges, std::vector&lt; double &gt; markerEllipseBandXCentres, std::vector&lt; double &gt; markerEllipseBandR1Ranges, std::vector&lt; double &gt; markerEllipseBandR2Ranges, const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes)</td></tr>
<tr class="memdesc:afff5db36385d757b38b7caa117686ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if the element is inside any marker bands for perturbatins. <br /></td></tr>
<tr class="separator:afff5db36385d757b38b7caa117686ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7fdc8e749b8b709b6c80248dc2bc3f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a2e7fdc8e749b8b709b6c80248dc2bc3f">checkZCappingInRemodelling</a> (bool volumeConserved, double zRemodellingLowerThreshold, double zRemodellingUpperThreshold, gsl_matrix *increment, gsl_matrix *eigenVec)</td></tr>
<tr class="memdesc:a2e7fdc8e749b8b709b6c80248dc2bc3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if the remodelling of the element in z axis have reached the specified cap.  <a href="#a2e7fdc8e749b8b709b6c80248dc2bc3f">More...</a><br /></td></tr>
<tr class="separator:a2e7fdc8e749b8b709b6c80248dc2bc3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1370385074f4bdc2911b567b184308"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade1370385074f4bdc2911b567b184308"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ade1370385074f4bdc2911b567b184308">assignSoftHinge</a> (double lowHingeLimit, double highHingeLimit, double softnessLevel)</td></tr>
<tr class="memdesc:ade1370385074f4bdc2911b567b184308"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function modulates the stiffness of the hinge domain of the tissue with the input level. The domain is defined in relative x position boundaries. <br /></td></tr>
<tr class="separator:ade1370385074f4bdc2911b567b184308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c9eda4ef1eb0b23620235039bab921"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aa1c9eda4ef1eb0b23620235039bab921">calculatePlasticDeformation3D</a> (bool volumeConserved, double dt, double plasticDeformationHalfLife, double zRemodellingLowerThreshold, double zRemodellingUpperThreshold)</td></tr>
<tr class="memdesc:aa1c9eda4ef1eb0b23620235039bab921"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the plastic deformation (remodelling) from the current elastic deformation gradient.  <a href="#aa1c9eda4ef1eb0b23620235039bab921">More...</a><br /></td></tr>
<tr class="separator:aa1c9eda4ef1eb0b23620235039bab921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a9f16148650a7acce1ec74aa693930"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9a9f16148650a7acce1ec74aa693930"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ac9a9f16148650a7acce1ec74aa693930">displayDebuggingMatrices</a> ()</td></tr>
<tr class="memdesc:ac9a9f16148650a7acce1ec74aa693930"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function displays a selected set of matricex for debugging purposes. <br /></td></tr>
<tr class="separator:ac9a9f16148650a7acce1ec74aa693930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8088a8bb897d79a796a253c06d954f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d8088a8bb897d79a796a253c06d954f"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a6d8088a8bb897d79a796a253c06d954f">getApicalSideLengthAverage</a> ()</td></tr>
<tr class="memdesc:a6d8088a8bb897d79a796a253c06d954f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The virtual function of the parent to calculate average apical side length, dependent on nodal topology, defined in each child. <br /></td></tr>
<tr class="separator:a6d8088a8bb897d79a796a253c06d954f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050c5dc5cd30c29e79533a367723b936"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a050c5dc5cd30c29e79533a367723b936"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a050c5dc5cd30c29e79533a367723b936">getBasalSideLengthAverage</a> ()</td></tr>
<tr class="memdesc:a050c5dc5cd30c29e79533a367723b936"><td class="mdescLeft">&#160;</td><td class="mdescRight">The virtual function of the parent to calculate average basal side length, dependent on nodal topology, defined in each child. <br /></td></tr>
<tr class="separator:a050c5dc5cd30c29e79533a367723b936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af50dc1099b17b67a2e196724b74eab4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af50dc1099b17b67a2e196724b74eab4e"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#af50dc1099b17b67a2e196724b74eab4e">getCorrecpondingApical</a> (int)</td></tr>
<tr class="memdesc:af50dc1099b17b67a2e196724b74eab4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The virtual function of the parent to obtain the corresponding apical node of a basal node, dependent on nodal topology, defined in each child. <br /></td></tr>
<tr class="separator:af50dc1099b17b67a2e196724b74eab4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeaf86469ce03277c978e0fd739e3751"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeeaf86469ce03277c978e0fd739e3751"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aeeaf86469ce03277c978e0fd739e3751">IsThisNodeMyBasal</a> (int)</td></tr>
<tr class="memdesc:aeeaf86469ce03277c978e0fd739e3751"><td class="mdescLeft">&#160;</td><td class="mdescRight">The virtual function of the parent to check if the input node ID is a basal node of the element, dependent on nodal topology, defined in each child. <br /></td></tr>
<tr class="separator:aeeaf86469ce03277c978e0fd739e3751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acede81712d5205c96fcd6acdaa574368"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acede81712d5205c96fcd6acdaa574368"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#acede81712d5205c96fcd6acdaa574368">IsThisNodeMyApical</a> (int)</td></tr>
<tr class="memdesc:acede81712d5205c96fcd6acdaa574368"><td class="mdescLeft">&#160;</td><td class="mdescRight">The virtual function of the parent to check if the input node ID is an apical node of the element, dependent on nodal topology, defined in each child. <br /></td></tr>
<tr class="separator:acede81712d5205c96fcd6acdaa574368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995a5e6a553ed0cdaadf74dab4f88822"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a995a5e6a553ed0cdaadf74dab4f88822"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a995a5e6a553ed0cdaadf74dab4f88822">getElementHeight</a> ()</td></tr>
<tr class="memdesc:a995a5e6a553ed0cdaadf74dab4f88822"><td class="mdescLeft">&#160;</td><td class="mdescRight">//&lt; The virtual function of the parent to calculate z height of the element, dependent on nodal topology, defined in each child. <br /></td></tr>
<tr class="separator:a995a5e6a553ed0cdaadf74dab4f88822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b73c76574b69c1d02ff75f76a8ccbb6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b73c76574b69c1d02ff75f76a8ccbb6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>constructElementStackList</b> (const int, const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classShapeBase.html">ShapeBase</a> &gt;&gt; &amp;)</td></tr>
<tr class="separator:a5b73c76574b69c1d02ff75f76a8ccbb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e33b4fea2d126f59ca0bcf73e07a253"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e33b4fea2d126f59ca0bcf73e07a253"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a4e33b4fea2d126f59ca0bcf73e07a253">checkRotationConsistency3D</a> ()</td></tr>
<tr class="memdesc:a4e33b4fea2d126f59ca0bcf73e07a253"><td class="mdescLeft">&#160;</td><td class="mdescRight">The virtual function of the parent to check if the two input nodes of the element are directly connected on one of the elemental surfaces, dependent on nodal topology, defined in each child. <br /></td></tr>
<tr class="separator:a4e33b4fea2d126f59ca0bcf73e07a253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5ef32d56aa383108f2d6912469138f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae5ef32d56aa383108f2d6912469138f"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aae5ef32d56aa383108f2d6912469138f">areNodesDirectlyConnected</a> (int, int)</td></tr>
<tr class="memdesc:aae5ef32d56aa383108f2d6912469138f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The virtual function of the parent to check if the rotation of the nodes of the element are consistent, dependent on nodal topology, defined in each child. <br /></td></tr>
<tr class="separator:aae5ef32d56aa383108f2d6912469138f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4c893952a6afad718a2037e0635296"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed4c893952a6afad718a2037e0635296"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aed4c893952a6afad718a2037e0635296">DoesPointBelogToMe</a> (int IdNode)</td></tr>
<tr class="memdesc:aed4c893952a6afad718a2037e0635296"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if the input node belogs to the element. <br /></td></tr>
<tr class="separator:aed4c893952a6afad718a2037e0635296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4348dcb67c58e31020346cdc0a5e7cc7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4348dcb67c58e31020346cdc0a5e7cc7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a4348dcb67c58e31020346cdc0a5e7cc7">assignVolumesToNodes</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes)</td></tr>
<tr class="memdesc:a4348dcb67c58e31020346cdc0a5e7cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function distributes element's total volume among its owner nodes. <br /></td></tr>
<tr class="separator:a4348dcb67c58e31020346cdc0a5e7cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc9c0bb828f73c105321fd5a25be8cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bc9c0bb828f73c105321fd5a25be8cc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a4bc9c0bb828f73c105321fd5a25be8cc">calculateZProjectedAreas</a> ()</td></tr>
<tr class="memdesc:a4bc9c0bb828f73c105321fd5a25be8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculated the z-projected (to world xy plane) apical and basal areas of the element. <br /></td></tr>
<tr class="separator:a4bc9c0bb828f73c105321fd5a25be8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb53c1b619993aa5b7afd840771cfb0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6cb53c1b619993aa5b7afd840771cfb0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a6cb53c1b619993aa5b7afd840771cfb0">assignZProjectedAreas</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes)</td></tr>
<tr class="memdesc:a6cb53c1b619993aa5b7afd840771cfb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function distributes element's z-projected areas among its owner nodes. <br /></td></tr>
<tr class="separator:a6cb53c1b619993aa5b7afd840771cfb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc759e8bef0a7b02e8153d6bfb4272c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bc759e8bef0a7b02e8153d6bfb4272c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a4bc759e8bef0a7b02e8153d6bfb4272c">assignElementToConnectedNodes</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes)</td></tr>
<tr class="memdesc:a4bc759e8bef0a7b02e8153d6bfb4272c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function assigns the element to the nodes it owns, necessary to construc the owner and connectivity list of nodes. <br /></td></tr>
<tr class="separator:a4bc759e8bef0a7b02e8153d6bfb4272c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f114984fe31a847a9b5485d4622ca1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a48f114984fe31a847a9b5485d4622ca1">setECMMimicing</a> (bool IsECMMimicing)</td></tr>
<tr class="memdesc:a48f114984fe31a847a9b5485d4622ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This funciton sets the element as an ECM mimicking element (distinct domain in terms of physical characteristics).  <a href="#a48f114984fe31a847a9b5485d4622ca1">More...</a><br /></td></tr>
<tr class="separator:a48f114984fe31a847a9b5485d4622ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42c9ed461be059e0558740ed965a8d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac42c9ed461be059e0558740ed965a8d6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ac42c9ed461be059e0558740ed965a8d6">setActinMimicing</a> (bool <a class="el" href="classShapeBase.html#a892e478508ed8a375f0816b330e36ac1">isActinMimicing</a>)</td></tr>
<tr class="memdesc:ac42c9ed461be059e0558740ed965a8d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This funciton sets the element as an actin mimicking element (distinct domain in terms of physical characteristics). <br /></td></tr>
<tr class="separator:ac42c9ed461be059e0558740ed965a8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc635fbfb4e127eed1e449a91c19d13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0fc635fbfb4e127eed1e449a91c19d13"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a0fc635fbfb4e127eed1e449a91c19d13">assignExposedSurfaceAreaIndices</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;)</td></tr>
<tr class="memdesc:a0fc635fbfb4e127eed1e449a91c19d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">The virtual function on parent assigns the nodes of the surfaces that are exposed to external world, dependent on topology, defined for each child. <br /></td></tr>
<tr class="separator:a0fc635fbfb4e127eed1e449a91c19d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384ff1314700f9c7157e702c277d2819"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a384ff1314700f9c7157e702c277d2819"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a384ff1314700f9c7157e702c277d2819">calculateViscositySurfaces</a> ()</td></tr>
<tr class="memdesc:a384ff1314700f9c7157e702c277d2819"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calls for the assignment of exposed surfaces if the element has viscosity. <br /></td></tr>
<tr class="separator:a384ff1314700f9c7157e702c277d2819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91f3d3cddf8cc01ce06562185c291ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa91f3d3cddf8cc01ce06562185c291ba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aa91f3d3cddf8cc01ce06562185c291ba">assignViscositySurfaceAreaToNodes</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes)</td></tr>
<tr class="memdesc:aa91f3d3cddf8cc01ce06562185c291ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function distributes elemenbt's exposed surfaces to nodes. <br /></td></tr>
<tr class="separator:aa91f3d3cddf8cc01ce06562185c291ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af616bee3616ec9d1f99628745f330ad7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af616bee3616ec9d1f99628745f330ad7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#af616bee3616ec9d1f99628745f330ad7">calculateEmergentRotationAngles</a> ()</td></tr>
<tr class="memdesc:af616bee3616ec9d1f99628745f330ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the emergent rotation of the element in xy plane for display purposes. <br /></td></tr>
<tr class="separator:af616bee3616ec9d1f99628745f330ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e339624fd36c39f22a0ef8a40b56329"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e339624fd36c39f22a0ef8a40b56329"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a2e339624fd36c39f22a0ef8a40b56329">updateReferencePositionMatrixFromMeshInput</a> (std::ifstream &amp;file)</td></tr>
<tr class="memdesc:a2e339624fd36c39f22a0ef8a40b56329"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function updates the reference position of the element from save file. <br /></td></tr>
<tr class="separator:a2e339624fd36c39f22a0ef8a40b56329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea16f414d8c6318719badfef575a090d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea16f414d8c6318719badfef575a090d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aea16f414d8c6318719badfef575a090d">fillNodeNeighbourhood</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes)</td></tr>
<tr class="memdesc:aea16f414d8c6318719badfef575a090d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function fills in the node neightbourhood, needed for constrction of the connectivity of nodes. <br /></td></tr>
<tr class="separator:aea16f414d8c6318719badfef575a090d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe3c0f97f5ea130d95cc74be439c0d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fe3c0f97f5ea130d95cc74be439c0d1"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a6fe3c0f97f5ea130d95cc74be439c0d1">dotProduct3D</a> (std::array&lt; double, 3 &gt; &amp;u, std::array&lt; double, 3 &gt; &amp;<a class="el" href="classShapeBase.html#a8b4c2d3bfbc6c9785c5181a56f929151">v</a>)</td></tr>
<tr class="memdesc:a6fe3c0f97f5ea130d95cc74be439c0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper algebraic function, calculates dot product of two arrays &lt;double,3&gt; <br /></td></tr>
<tr class="separator:a6fe3c0f97f5ea130d95cc74be439c0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334a6cec6a698ac49006d8216a93ced9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a334a6cec6a698ac49006d8216a93ced9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a334a6cec6a698ac49006d8216a93ced9">crossProduct3D</a> (gsl_vector *u, gsl_vector *<a class="el" href="classShapeBase.html#a8b4c2d3bfbc6c9785c5181a56f929151">v</a>, gsl_vector *cross)</td></tr>
<tr class="memdesc:a334a6cec6a698ac49006d8216a93ced9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper algebraic function, calculates cross product of two gsl_vectors, writes into the third input gls vector. <br /></td></tr>
<tr class="separator:a334a6cec6a698ac49006d8216a93ced9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52860af5f883c90296e52ddb194568ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52860af5f883c90296e52ddb194568ff"></a>
std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a52860af5f883c90296e52ddb194568ff">crossProduct3D</a> (std::array&lt; double, 3 &gt; u, std::array&lt; double, 3 &gt; <a class="el" href="classShapeBase.html#a8b4c2d3bfbc6c9785c5181a56f929151">v</a>)</td></tr>
<tr class="memdesc:a52860af5f883c90296e52ddb194568ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper algebraic function, calculates cross product of two arrays &lt;double,3&gt; <br /></td></tr>
<tr class="separator:a52860af5f883c90296e52ddb194568ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1d85430abf35169eb5b53ef71768ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c1d85430abf35169eb5b53ef71768ad"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setBasalNeigElementId</b> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classShapeBase.html">ShapeBase</a> &gt;&gt; &amp;)</td></tr>
<tr class="separator:a4c1d85430abf35169eb5b53ef71768ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8763ab46f90adb819ec776a5829573c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a8763ab46f90adb819ec776a5829573c5">isElementFlippedInPotentialNewShape</a> (int nodeId, double newX, double newY, double newZ)</td></tr>
<tr class="memdesc:a8763ab46f90adb819ec776a5829573c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if the element will plip in the case that its node (nodeID) is moved to the new x,y,z coordintes specified in the input. Necessary in node collapsing.  <a href="#a8763ab46f90adb819ec776a5829573c5">More...</a><br /></td></tr>
<tr class="separator:a8763ab46f90adb819ec776a5829573c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346f4ec76554bea282a5cab7ea28dfa2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a346f4ec76554bea282a5cab7ea28dfa2">checkForCollapsedNodes</a> (int TissueHeightDiscretisationLayers, const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes, const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classShapeBase.html">ShapeBase</a> &gt;&gt; &amp;Elements)</td></tr>
<tr class="memdesc:a346f4ec76554bea282a5cab7ea28dfa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if any of the edges of the element is shortened to the extent that it should be collapsed.  <a href="#a346f4ec76554bea282a5cab7ea28dfa2">More...</a><br /></td></tr>
<tr class="separator:a346f4ec76554bea282a5cab7ea28dfa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae223927913b48f7044be8aa52a60575c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae223927913b48f7044be8aa52a60575c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ae223927913b48f7044be8aa52a60575c">hasEnoughNodesOnCurve</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; &gt; &amp;Nodes)</td></tr>
<tr class="memdesc:ae223927913b48f7044be8aa52a60575c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if the majority of the nodes of teh element reside in a curved region, to assign it to specific curvature dependent perturbations. <br /></td></tr>
<tr class="separator:ae223927913b48f7044be8aa52a60575c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf53d1dd8f8707d05c6a252b94093282"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf53d1dd8f8707d05c6a252b94093282"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#abf53d1dd8f8707d05c6a252b94093282">assignEllipseBandIdToWholeTissueColumn</a> (size_t TissueHeightDiscretisationLayers, const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes, const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classShapeBase.html">ShapeBase</a> &gt;&gt; &amp;Elements)</td></tr>
<tr class="memdesc:abf53d1dd8f8707d05c6a252b94093282"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function assigns the marker ID of the apical elemetn ot all its connected elements in the tissue hight (all column of the element). <br /></td></tr>
<tr class="separator:abf53d1dd8f8707d05c6a252b94093282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcdcb7ee31af4717efbd5b3c99698218"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcdcb7ee31af4717efbd5b3c99698218"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#afcdcb7ee31af4717efbd5b3c99698218">assignEllipseBandId</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes, int selectedEllipseBandId)</td></tr>
<tr class="memdesc:afcdcb7ee31af4717efbd5b3c99698218"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function assigns the marking ellipse band ID of the element depending on the definition of nodes it is consturcted of. <br /></td></tr>
<tr class="separator:afcdcb7ee31af4717efbd5b3c99698218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88977dbe166e6694ad6698b93abfa22"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa88977dbe166e6694ad6698b93abfa22"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aa88977dbe166e6694ad6698b93abfa22">assignEllipseBandIdToNodes</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes)</td></tr>
<tr class="memdesc:aa88977dbe166e6694ad6698b93abfa22"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function assigns the marker ID of the elemetn to all its nodes. <br /></td></tr>
<tr class="separator:aa88977dbe166e6694ad6698b93abfa22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677fceb50ab5626dbc9c4f8079829d59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a677fceb50ab5626dbc9c4f8079829d59"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addToElementalElasticSystemForces</b> (int i, int j, double value)</td></tr>
<tr class="separator:a677fceb50ab5626dbc9c4f8079829d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8e11261fb35bc925259151218eebf3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a2e8e11261fb35bc925259151218eebf3">addToTriPointKe</a> (int i, int j, double value)</td></tr>
<tr class="memdesc:a2e8e11261fb35bc925259151218eebf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is to add the input value, to the (i,j)th element of the ElementalElasticSystemForces.  <a href="#a2e8e11261fb35bc925259151218eebf3">More...</a><br /></td></tr>
<tr class="separator:a2e8e11261fb35bc925259151218eebf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a9cff4a8549b3399fec12309d18b6db70"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9cff4a8549b3399fec12309d18b6db70"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a9cff4a8549b3399fec12309d18b6db70">stiffnessMultiplier</a></td></tr>
<tr class="memdesc:a9cff4a8549b3399fec12309d18b6db70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current stiffness multiplier of the element, initially 1.0, modulated by stiffness perturbations ///&lt; The double for the multiplier that will define Young's modulus stress stiffening. <br /></td></tr>
<tr class="separator:a9cff4a8549b3399fec12309d18b6db70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8b443e4b55479a9d2a7a7eacd62b69"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e8b443e4b55479a9d2a7a7eacd62b69"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a0e8b443e4b55479a9d2a7a7eacd62b69">remodellingPlaneRotationMatrix</a></td></tr>
<tr class="memdesc:a0e8b443e4b55479a9d2a7a7eacd62b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">The rotation matrix converting the xyz coordinate system to the plane of remodelling for the lateral elements. <br /></td></tr>
<tr class="separator:a0e8b443e4b55479a9d2a7a7eacd62b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4156d7c7f91f0b528214b74277279df0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4156d7c7f91f0b528214b74277279df0"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a4156d7c7f91f0b528214b74277279df0">Fg</a></td></tr>
<tr class="memdesc:a4156d7c7f91f0b528214b74277279df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Growth deformation gradient. <br /></td></tr>
<tr class="separator:a4156d7c7f91f0b528214b74277279df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae097764dd4d607b54710d7ca0f7e12f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae097764dd4d607b54710d7ca0f7e12f8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ae097764dd4d607b54710d7ca0f7e12f8">Id</a></td></tr>
<tr class="memdesc:ae097764dd4d607b54710d7ca0f7e12f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unique ID of the element, without remodelling, equal to its indes on the <a class="el" href="classSimulation.html#a96e0aaea7b40dbb5bc11329fc7d34559" title="The vector storing the unique pointers ot the elements of the simulation. ">Simulation::Elements</a> vector. <br /></td></tr>
<tr class="separator:ae097764dd4d607b54710d7ca0f7e12f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d740b60433d7a9104c2d09b0d52703d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d740b60433d7a9104c2d09b0d52703d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a4d740b60433d7a9104c2d09b0d52703d">ShapeDim</a></td></tr>
<tr class="memdesc:a4d740b60433d7a9104c2d09b0d52703d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dimension of the shape in workd coordiantes (2D vs 3D). <br /></td></tr>
<tr class="separator:a4d740b60433d7a9104c2d09b0d52703d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96e17fa9a23289fb743ff0722a7dc64"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af96e17fa9a23289fb743ff0722a7dc64"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#af96e17fa9a23289fb743ff0722a7dc64">NodeIds</a></td></tr>
<tr class="memdesc:af96e17fa9a23289fb743ff0722a7dc64"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector storing the unique IDs (<a class="el" href="classNode.html#a1bd379569cc1a8b96432e61971aed4d9" title="The unique identification number of the node. ">Node::Id</a>) of nodes constructing this element. Their order is consistent for a given shape type. <br /></td></tr>
<tr class="separator:af96e17fa9a23289fb743ff0722a7dc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6bd8c65e2a0bfea3a956604bc05cb9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a6bd8c65e2a0bfea3a956604bc05cb9"></a>
std::vector&lt; std::array&lt; double, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a6a6bd8c65e2a0bfea3a956604bc05cb9">Positions</a></td></tr>
<tr class="memdesc:a6a6bd8c65e2a0bfea3a956604bc05cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector storing the positions of the nodes constructing the element. <br /></td></tr>
<tr class="separator:a6a6bd8c65e2a0bfea3a956604bc05cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93270dee7f71d075c73d1720c8279a44"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93270dee7f71d075c73d1720c8279a44"></a>
std::unique_ptr&lt; <a class="el" href="classReferenceShapeBase.html">ReferenceShapeBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a93270dee7f71d075c73d1720c8279a44">ReferenceShape</a></td></tr>
<tr class="memdesc:a93270dee7f71d075c73d1720c8279a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pointer to the reference shape object that defines th reference shape of this element. <br /></td></tr>
<tr class="separator:a93270dee7f71d075c73d1720c8279a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bda00f80968d836c647afe5f6d1fb36"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bda00f80968d836c647afe5f6d1fb36"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a4bda00f80968d836c647afe5f6d1fb36">Strain</a></td></tr>
<tr class="memdesc:a4bda00f80968d836c647afe5f6d1fb36"><td class="mdescLeft">&#160;</td><td class="mdescRight">The gsl_matrix pointer, storing the address of the current strains on the element. <br /></td></tr>
<tr class="separator:a4bda00f80968d836c647afe5f6d1fb36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da6d64116b5d73e2bb27d378035df41"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3da6d64116b5d73e2bb27d378035df41"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a3da6d64116b5d73e2bb27d378035df41">isFlipped</a></td></tr>
<tr class="memdesc:a3da6d64116b5d73e2bb27d378035df41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if the element is flipped. The simulation will be stopped if there are flipped elements. <br /></td></tr>
<tr class="separator:a3da6d64116b5d73e2bb27d378035df41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994acea5e6f2cf92c94f485e7ba5afc9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a994acea5e6f2cf92c94f485e7ba5afc9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsChangingShape</b></td></tr>
<tr class="separator:a994acea5e6f2cf92c94f485e7ba5afc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff63b1fcb823bbfdb5b19fe78dea59b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff63b1fcb823bbfdb5b19fe78dea59b8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aff63b1fcb823bbfdb5b19fe78dea59b8">tissuePlacement</a></td></tr>
<tr class="memdesc:aff63b1fcb823bbfdb5b19fe78dea59b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 -&gt; apical, 0 -&gt; basal, 2-&gt;middle, 3 -&gt; lateral <br /></td></tr>
<tr class="separator:aff63b1fcb823bbfdb5b19fe78dea59b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d56f7eb3fed744adc268bc4da7a790f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d56f7eb3fed744adc268bc4da7a790f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a1d56f7eb3fed744adc268bc4da7a790f">tissueType</a></td></tr>
<tr class="memdesc:a1d56f7eb3fed744adc268bc4da7a790f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The tissue type is 000 for columnar layer, 1 for peripodial membrane, and 2 for linker zone. <br /></td></tr>
<tr class="separator:a1d56f7eb3fed744adc268bc4da7a790f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adafe85bbee6173d2a321408cd8b63db3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adafe85bbee6173d2a321408cd8b63db3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#adafe85bbee6173d2a321408cd8b63db3">spansWholeTissue</a></td></tr>
<tr class="memdesc:adafe85bbee6173d2a321408cd8b63db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean staing is the element spans the whole tissue. This is used to identify mid-layer tagged tissues (tissuePlacement = 2), that should still have apical abd basal responses. <br /></td></tr>
<tr class="separator:adafe85bbee6173d2a321408cd8b63db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47bfa280bf33fc0557e8d804aab3936c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47bfa280bf33fc0557e8d804aab3936c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a47bfa280bf33fc0557e8d804aab3936c">compartmentType</a></td></tr>
<tr class="memdesc:a47bfa280bf33fc0557e8d804aab3936c"><td class="mdescLeft">&#160;</td><td class="mdescRight">integer identifying the compartment of the tissue in DV axis, 0 pouch, 1 hinge, 2 notum <br /></td></tr>
<tr class="separator:a47bfa280bf33fc0557e8d804aab3936c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada8d021521dbe6815a887bc0cb28cc8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aada8d021521dbe6815a887bc0cb28cc8"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aada8d021521dbe6815a887bc0cb28cc8">compartmentIdentityFraction</a></td></tr>
<tr class="memdesc:aada8d021521dbe6815a887bc0cb28cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The weight defining the constibution of each compartment to the physical identity of this element. <br /></td></tr>
<tr class="separator:aada8d021521dbe6815a887bc0cb28cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e442b31d2341cbe477d7c33195a576c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e442b31d2341cbe477d7c33195a576c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a5e442b31d2341cbe477d7c33195a576c">isECMMimicing</a></td></tr>
<tr class="memdesc:a5e442b31d2341cbe477d7c33195a576c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if the element is an ECM element. <br /></td></tr>
<tr class="separator:a5e442b31d2341cbe477d7c33195a576c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25330a1d76d3ada08bd0dced22fb79b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa25330a1d76d3ada08bd0dced22fb79b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aa25330a1d76d3ada08bd0dced22fb79b">isECMMimimcingAtCircumference</a></td></tr>
<tr class="memdesc:aa25330a1d76d3ada08bd0dced22fb79b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if the element is an ECM element at the circumference of the tissue. <br /></td></tr>
<tr class="separator:aa25330a1d76d3ada08bd0dced22fb79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd1d4807f83e12b2df7606acb7518b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcd1d4807f83e12b2df7606acb7518b3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#afcd1d4807f83e12b2df7606acb7518b3">atBasalBorderOfECM</a></td></tr>
<tr class="memdesc:afcd1d4807f83e12b2df7606acb7518b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if the element is at the basal border of the cellular layer, linking to ECM elements. <br /></td></tr>
<tr class="separator:afcd1d4807f83e12b2df7606acb7518b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892e478508ed8a375f0816b330e36ac1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a892e478508ed8a375f0816b330e36ac1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a892e478508ed8a375f0816b330e36ac1">isActinMimicing</a></td></tr>
<tr class="memdesc:a892e478508ed8a375f0816b330e36ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if the element is forming the actin dense layer on the apical surface. <br /></td></tr>
<tr class="separator:a892e478508ed8a375f0816b330e36ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c9fe02c9c42e0617900c3282e4403a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95c9fe02c9c42e0617900c3282e4403a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a95c9fe02c9c42e0617900c3282e4403a">atApicalBorderOfActin</a></td></tr>
<tr class="memdesc:a95c9fe02c9c42e0617900c3282e4403a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if the element is at the apical border of the soft cellular layer, linking to actin dense layer. <br /></td></tr>
<tr class="separator:a95c9fe02c9c42e0617900c3282e4403a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f09d39d079bfe95ea7c25f5d3de6c09"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f09d39d079bfe95ea7c25f5d3de6c09"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a4f09d39d079bfe95ea7c25f5d3de6c09">IsAblated</a></td></tr>
<tr class="memdesc:a4f09d39d079bfe95ea7c25f5d3de6c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if the element is laser ablated, therefore dead. <br /></td></tr>
<tr class="separator:a4f09d39d079bfe95ea7c25f5d3de6c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d15f14d23230682242ed063872617af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d15f14d23230682242ed063872617af"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a3d15f14d23230682242ed063872617af">atSymetricityBoundary</a></td></tr>
<tr class="memdesc:a3d15f14d23230682242ed063872617af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if the element is at the symmetricity boundary. <br /></td></tr>
<tr class="separator:a3d15f14d23230682242ed063872617af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d48903871978d77a77cb77f569975c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d48903871978d77a77cb77f569975c0"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a3d48903871978d77a77cb77f569975c0">CurrShapeChangeToAdd</a> [3]</td></tr>
<tr class="memdesc:a3d48903871978d77a77cb77f569975c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current shape change to be applied to the element, in form of 3D rates. <br /></td></tr>
<tr class="separator:a3d48903871978d77a77cb77f569975c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1bafcaf21f040dd137abfe434a75a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a1bafcaf21f040dd137abfe434a75a9"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a8a1bafcaf21f040dd137abfe434a75a9">GrownVolume</a></td></tr>
<tr class="memdesc:a8a1bafcaf21f040dd137abfe434a75a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current volume of the element after growth. <br /></td></tr>
<tr class="separator:a8a1bafcaf21f040dd137abfe434a75a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59943ecb9f8ec139c0f564c1fb91d876"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59943ecb9f8ec139c0f564c1fb91d876"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a59943ecb9f8ec139c0f564c1fb91d876">VolumePerNode</a></td></tr>
<tr class="memdesc:a59943ecb9f8ec139c0f564c1fb91d876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume per node of the element. <br /></td></tr>
<tr class="separator:a59943ecb9f8ec139c0f564c1fb91d876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21420915ac7c8444e0e5b5f4e98d7322"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21420915ac7c8444e0e5b5f4e98d7322"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a21420915ac7c8444e0e5b5f4e98d7322">capElement</a></td></tr>
<tr class="memdesc:a21420915ac7c8444e0e5b5f4e98d7322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if the element is capped at its remodelling due to restrictions in z remodelling (avoiding too thin ot too thick layers due to numerical error). <br /></td></tr>
<tr class="separator:a21420915ac7c8444e0e5b5f4e98d7322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef483e9f69872329b0a6365803dc8ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ef483e9f69872329b0a6365803dc8ff"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a5ef483e9f69872329b0a6365803dc8ff">elementsIdsOnSameColumn</a></td></tr>
<tr class="memdesc:a5ef483e9f69872329b0a6365803dc8ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector storing the unique element IDs of each element that is on the same columnar region of the tissue, i.e. the elements share apical/basal surfaces. <br /></td></tr>
<tr class="separator:a5ef483e9f69872329b0a6365803dc8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7515f99cadce806894a7c254186a85f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7515f99cadce806894a7c254186a85f7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a7515f99cadce806894a7c254186a85f7">basalNeigElementId</a></td></tr>
<tr class="memdesc:a7515f99cadce806894a7c254186a85f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is recorded only for apical nodes of the columnar layer. If not recorded, id is -1. <br /></td></tr>
<tr class="separator:a7515f99cadce806894a7c254186a85f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1571eea2fb8259868afa5814540fe61d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1571eea2fb8259868afa5814540fe61d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a1571eea2fb8259868afa5814540fe61d">insideEllipseBand</a></td></tr>
<tr class="memdesc:a1571eea2fb8259868afa5814540fe61d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if the element is marked by any identifier bands for physical perturbation. <br /></td></tr>
<tr class="separator:a1571eea2fb8259868afa5814540fe61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2b9ded0e51df7c23499ccc3f4da9fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d2b9ded0e51df7c23499ccc3f4da9fc"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a8d2b9ded0e51df7c23499ccc3f4da9fc">coveringEllipseBandId</a></td></tr>
<tr class="memdesc:a8d2b9ded0e51df7c23499ccc3f4da9fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unique ID of the covering perturbation band. <br /></td></tr>
<tr class="separator:a8d2b9ded0e51df7c23499ccc3f4da9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1484f5942bbd147ce0e9e1d842919103"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1484f5942bbd147ce0e9e1d842919103"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a1484f5942bbd147ce0e9e1d842919103">emergentShapeLongAxis</a> [2]</td></tr>
<tr class="memdesc:a1484f5942bbd147ce0e9e1d842919103"><td class="mdescLeft">&#160;</td><td class="mdescRight">The long axis of the emergent shape. This is necessary for analysis of emergent growth orientations. <br /></td></tr>
<tr class="separator:a1484f5942bbd147ce0e9e1d842919103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c845ab5c6b7e8083faa1a9833765f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60c845ab5c6b7e8083faa1a9833765f7"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a60c845ab5c6b7e8083faa1a9833765f7">emergentShapeShortAxis</a> [2]</td></tr>
<tr class="memdesc:a60c845ab5c6b7e8083faa1a9833765f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The short axis of the emergent shape. This is necessary for analysis of emergent growth orientations. <br /></td></tr>
<tr class="separator:a60c845ab5c6b7e8083faa1a9833765f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30219b72a2e37fad6ad5dfbcb371a85e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30219b72a2e37fad6ad5dfbcb371a85e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a30219b72a2e37fad6ad5dfbcb371a85e">plasticDeformationHalfLifeMultiplier</a></td></tr>
<tr class="memdesc:a30219b72a2e37fad6ad5dfbcb371a85e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The multiplier to modify the remodelling half-life upon physical property perturbation. <br /></td></tr>
<tr class="separator:a30219b72a2e37fad6ad5dfbcb371a85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3633ac9356d82c0259770ace63ca3d3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3633ac9356d82c0259770ace63ca3d3d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a3633ac9356d82c0259770ace63ca3d3d">isMutated</a></td></tr>
<tr class="memdesc:a3633ac9356d82c0259770ace63ca3d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if the element is mutated. <br /></td></tr>
<tr class="separator:a3633ac9356d82c0259770ace63ca3d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4ab7a9dcb19f182cde416757397b7c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb4ab7a9dcb19f182cde416757397b7c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#afb4ab7a9dcb19f182cde416757397b7c">thereIsGrowthRedistribution</a></td></tr>
<tr class="memdesc:afb4ab7a9dcb19f182cde416757397b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if there is redistribution of growth among mesh elements. <br /></td></tr>
<tr class="separator:afb4ab7a9dcb19f182cde416757397b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7112715f6a436f2500793f67991b612c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7112715f6a436f2500793f67991b612c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a7112715f6a436f2500793f67991b612c">growthRedistributionShrinksElement</a></td></tr>
<tr class="memdesc:a7112715f6a436f2500793f67991b612c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if the growth distribution is taking material out of thes element to redistribute ot others. <br /></td></tr>
<tr class="separator:a7112715f6a436f2500793f67991b612c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7adb65c236a91a84acd9c1add5dc50"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c7adb65c236a91a84acd9c1add5dc50"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a0c7adb65c236a91a84acd9c1add5dc50">growthRedistributionScale</a></td></tr>
<tr class="memdesc:a0c7adb65c236a91a84acd9c1add5dc50"><td class="mdescLeft">&#160;</td><td class="mdescRight">The extent of the redistribution of volume. <br /></td></tr>
<tr class="separator:a0c7adb65c236a91a84acd9c1add5dc50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64f900d51cec3e48a488fdd8a51eacf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af64f900d51cec3e48a488fdd8a51eacf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#af64f900d51cec3e48a488fdd8a51eacf">RotatedElement</a></td></tr>
<tr class="memdesc:af64f900d51cec3e48a488fdd8a51eacf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean stating if the elemetn has rigid body rotation. <br /></td></tr>
<tr class="separator:af64f900d51cec3e48a488fdd8a51eacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1408c3e89b91787fec7e913cac1f58"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc1408c3e89b91787fec7e913cac1f58"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#acc1408c3e89b91787fec7e913cac1f58">GrowthStrainsRotMat</a></td></tr>
<tr class="memdesc:acc1408c3e89b91787fec7e913cac1f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">The rotation matrix needed to correct for the rigid body rotations of the element. <br /></td></tr>
<tr class="separator:acc1408c3e89b91787fec7e913cac1f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e7fb504d13f5d98d75c766e39e0143"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38e7fb504d13f5d98d75c766e39e0143"></a>
std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a38e7fb504d13f5d98d75c766e39e0143">apicalNormalCurrentShape</a></td></tr>
<tr class="memdesc:a38e7fb504d13f5d98d75c766e39e0143"><td class="mdescLeft">&#160;</td><td class="mdescRight">The apical normal of the current shape. <br /></td></tr>
<tr class="separator:a38e7fb504d13f5d98d75c766e39e0143"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a4cc6c721ed24f27baa71fe9398edd87a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a4cc6c721ed24f27baa71fe9398edd87a">setShapeType</a> (std::string TypeName)</td></tr>
<tr class="memdesc:a4cc6c721ed24f27baa71fe9398edd87a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function sets the type of the shape.  <a href="#a4cc6c721ed24f27baa71fe9398edd87a">More...</a><br /></td></tr>
<tr class="separator:a4cc6c721ed24f27baa71fe9398edd87a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96dae3d137adec217bb0bc6ed2cace97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a96dae3d137adec217bb0bc6ed2cace97">readNodeIds</a> (const std::vector&lt; int &gt; &amp;inpNodeIds)</td></tr>
<tr class="memdesc:a96dae3d137adec217bb0bc6ed2cace97"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function sets the <a class="el" href="classNode.html#a1bd379569cc1a8b96432e61971aed4d9" title="The unique identification number of the node. ">Node::Id</a> array that constructs the shape.  <a href="#a96dae3d137adec217bb0bc6ed2cace97">More...</a><br /></td></tr>
<tr class="separator:a96dae3d137adec217bb0bc6ed2cace97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474774dd9db4c42990de569b3d8cd52e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a474774dd9db4c42990de569b3d8cd52e">setPositionMatrix</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes)</td></tr>
<tr class="memdesc:a474774dd9db4c42990de569b3d8cd52e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function sets the <a class="el" href="classShapeBase.html#a6a6bd8c65e2a0bfea3a956604bc05cb9" title="The vector storing the positions of the nodes constructing the element. ">ShapeBase::Positions</a> matrix to define the locations of each constructing node.  <a href="#a474774dd9db4c42990de569b3d8cd52e">More...</a><br /></td></tr>
<tr class="separator:a474774dd9db4c42990de569b3d8cd52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3777927e49e4b09bfb524b4f4ac889ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a3777927e49e4b09bfb524b4f4ac889ad">setTissuePlacement</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes)</td></tr>
<tr class="memdesc:a3777927e49e4b09bfb524b4f4ac889ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function sets the placement of the element within the tissue.  <a href="#a3777927e49e4b09bfb524b4f4ac889ad">More...</a><br /></td></tr>
<tr class="separator:a3777927e49e4b09bfb524b4f4ac889ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f0b9431be849133a4eab5484fbb1f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ad5f0b9431be849133a4eab5484fbb1f8">setTissueType</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes)</td></tr>
<tr class="memdesc:ad5f0b9431be849133a4eab5484fbb1f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function sets the tissue type of the element.  <a href="#ad5f0b9431be849133a4eab5484fbb1f8">More...</a><br /></td></tr>
<tr class="separator:ad5f0b9431be849133a4eab5484fbb1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa260269fe9605765f5adb494d1a99737"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aa260269fe9605765f5adb494d1a99737">setReferencePositionMatrix</a> ()</td></tr>
<tr class="memdesc:aa260269fe9605765f5adb494d1a99737"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function sets the RefereneceShapeBase::Positions matrix to define the reference positions of the element.  <a href="#aa260269fe9605765f5adb494d1a99737">More...</a><br /></td></tr>
<tr class="separator:aa260269fe9605765f5adb494d1a99737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dafd8524fe5aa5326173aa49a8f78a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a8dafd8524fe5aa5326173aa49a8f78a0">setIdentificationColour</a> ()</td></tr>
<tr class="memdesc:a8dafd8524fe5aa5326173aa49a8f78a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function sets the unique <a class="el" href="classShapeBase.html#a8c6daae25e30af2e55599b7d1ecfbddb" title="The unique identifier colour of the element, this is used for &quot;picking&quot; in the visual interface...">ShapeBase::IdentifierColour</a> colour for the element, which is used in element picking from the user interface.  <a href="#a8dafd8524fe5aa5326173aa49a8f78a0">More...</a><br /></td></tr>
<tr class="separator:a8dafd8524fe5aa5326173aa49a8f78a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed871c8f50f35cf1e506528583804ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeed871c8f50f35cf1e506528583804ad"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aeed871c8f50f35cf1e506528583804ad">rotateReferenceElementByRotationMatrix</a> (std::array&lt; double, 9 &gt; rotMat)</td></tr>
<tr class="memdesc:aeed871c8f50f35cf1e506528583804ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function rotates the reference of the element (<a class="el" href="classShapeBase.html#a93270dee7f71d075c73d1720c8279a44" title="The pointer to the reference shape object that defines th reference shape of this element...">ShapeBase::ReferenceShape</a>) by input rotation matrix, provided as a double pointer of 9 doubles. <br /></td></tr>
<tr class="separator:aeed871c8f50f35cf1e506528583804ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab887eaa6a0be56e3b50f549326dbe87a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab887eaa6a0be56e3b50f549326dbe87a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ab887eaa6a0be56e3b50f549326dbe87a">InvertMatrix</a> (boost::numeric::ublas::matrix&lt; double &gt; &amp;input, boost::numeric::ublas::matrix&lt; double &gt; &amp;inverse)</td></tr>
<tr class="memdesc:ab887eaa6a0be56e3b50f549326dbe87a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function takes the first input matrix, and writes the inverse on the second input. False is returned if the matrix is not inverted. Input format is ublas matrices (slow). <br /></td></tr>
<tr class="separator:ab887eaa6a0be56e3b50f549326dbe87a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a890c07a2fa8ac45fa50bdbfe6b0d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0a890c07a2fa8ac45fa50bdbfe6b0d9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ab0a890c07a2fa8ac45fa50bdbfe6b0d9">InvertMatrix</a> (gsl_matrix *input, gsl_matrix *inverse)</td></tr>
<tr class="memdesc:ab0a890c07a2fa8ac45fa50bdbfe6b0d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function takes the first input matrix, and writes the inverse on the second input. False is returned if the matrix is not inverted. Input format is gsl matrices (fast). <br /></td></tr>
<tr class="separator:ab0a890c07a2fa8ac45fa50bdbfe6b0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92927e610d4e389c32a023554d805fc7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92927e610d4e389c32a023554d805fc7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a92927e610d4e389c32a023554d805fc7">updateNodeIdsFromSave</a> (std::ifstream &amp;file)</td></tr>
<tr class="memdesc:a92927e610d4e389c32a023554d805fc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function reads the <a class="el" href="classShapeBase.html#af96e17fa9a23289fb743ff0722a7dc64" title="The vector storing the unique IDs (Node::Id) of nodes constructing this element. Their order is consi...">ShapeBase::NodeIds</a> of the current shape from save file provided as input. <br /></td></tr>
<tr class="separator:a92927e610d4e389c32a023554d805fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a742964154a791aacdae8e783c19c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93a742964154a791aacdae8e783c19c4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a93a742964154a791aacdae8e783c19c4">updateReferencePositionMatrixFromSave</a> (std::ifstream &amp;file)</td></tr>
<tr class="memdesc:a93a742964154a791aacdae8e783c19c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function reads and updates the <a class="el" href="classShapeBase.html#a93270dee7f71d075c73d1720c8279a44" title="The pointer to the reference shape object that defines th reference shape of this element...">ShapeBase::ReferenceShape</a> positions (<a class="el" href="classReferenceShapeBase.html#a6b20aebb733d845a8e2b7cd4f69722cb" title="The pointer to the position matrix of the reference element. The array itself is declared within the ...">ReferenceShapeBase::Positions</a>) of the current shape from save file provided as input. <br /></td></tr>
<tr class="separator:a93a742964154a791aacdae8e783c19c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39adc8589779388b57622489f370f445"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39adc8589779388b57622489f370f445"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a39adc8589779388b57622489f370f445">calculateReferenceVolume</a> ()</td></tr>
<tr class="memdesc:a39adc8589779388b57622489f370f445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function of the <a class="el" href="classShapeBase.html">ShapeBase</a> class to calculate volume of the <a class="el" href="classShapeBase.html#a93270dee7f71d075c73d1720c8279a44" title="The pointer to the reference shape object that defines th reference shape of this element...">ShapeBase::ReferenceShape</a>. <br /></td></tr>
<tr class="separator:a39adc8589779388b57622489f370f445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf9c7c8ae6a3195ec9c6b6bdaf847ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bf9c7c8ae6a3195ec9c6b6bdaf847ab"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a8bf9c7c8ae6a3195ec9c6b6bdaf847ab">calculateGrowthStrainsRotMat</a> (double *<a class="el" href="classShapeBase.html#a8b4c2d3bfbc6c9785c5181a56f929151">v</a>)</td></tr>
<tr class="memdesc:a8bf9c7c8ae6a3195ec9c6b6bdaf847ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function calculates the rotation matrix to apply on growth strains to align growth with the current x axis of the tissue. <br /></td></tr>
<tr class="separator:a8bf9c7c8ae6a3195ec9c6b6bdaf847ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1afbb15d92215f337090262753eb24ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a1afbb15d92215f337090262753eb24ab">calculateForces3D</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes, gsl_matrix *displacementPerDt)</td></tr>
<tr class="memdesc:a1afbb15d92215f337090262753eb24ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function calculates the viscous and elastic forces generated by the element.  <a href="#a1afbb15d92215f337090262753eb24ab">More...</a><br /></td></tr>
<tr class="separator:a1afbb15d92215f337090262753eb24ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347fb2687678294a252a12820842cb0d"><td class="memItemLeft" align="right" valign="top">gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a347fb2687678294a252a12820842cb0d">calculateEForNodalForcesKirshoff</a> (gsl_matrix *C)</td></tr>
<tr class="memdesc:a347fb2687678294a252a12820842cb0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the green strains for a Kirshoff material model.  <a href="#a347fb2687678294a252a12820842cb0d">More...</a><br /></td></tr>
<tr class="separator:a347fb2687678294a252a12820842cb0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09cb91359e10677889c3f59c3f5d70a"><td class="memItemLeft" align="right" valign="top">gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ae09cb91359e10677889c3f59c3f5d70a">calculateCauchyGreenDeformationTensor</a> (gsl_matrix *Fe)</td></tr>
<tr class="memdesc:ae09cb91359e10677889c3f59c3f5d70a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the Caucy-Green deformation tensor, from the elastic part of the deformation gradient.  <a href="#ae09cb91359e10677889c3f59c3f5d70a">More...</a><br /></td></tr>
<tr class="separator:ae09cb91359e10677889c3f59c3f5d70a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c79b3bced80eac8af18a0a81d3898ab"><td class="memItemLeft" align="right" valign="top">gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a9c79b3bced80eac8af18a0a81d3898ab">calculateSForNodalForcesKirshoff</a> (gsl_matrix *<a class="el" href="classShapeBase.html#a6c1a3a0173841d6072a5268978463ff2">E</a>)</td></tr>
<tr class="memdesc:a9c79b3bced80eac8af18a0a81d3898ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the Secons order Piola-Kirshoff stress tensor for Kirshoff material model.  <a href="#a9c79b3bced80eac8af18a0a81d3898ab">More...</a><br /></td></tr>
<tr class="separator:a9c79b3bced80eac8af18a0a81d3898ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697f24754441df216b4245e7eb467b13"><td class="memItemLeft" align="right" valign="top">gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a697f24754441df216b4245e7eb467b13">calculateSForNodalForcesNeoHookean</a> (gsl_matrix *invC, double lnJ)</td></tr>
<tr class="memdesc:a697f24754441df216b4245e7eb467b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the Secons order Piola-Kirshoff stress tensor for Neo-Hookean material model.v.  <a href="#a697f24754441df216b4245e7eb467b13">More...</a><br /></td></tr>
<tr class="separator:a697f24754441df216b4245e7eb467b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606ddc7f909062e9faae9f4a311ccd8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a606ddc7f909062e9faae9f4a311ccd8a">updateLagrangianElasticityTensorNeoHookean</a> (gsl_matrix *invC, double lnJ, int pointNo)</td></tr>
<tr class="memdesc:a606ddc7f909062e9faae9f4a311ccd8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calcualtes the Lagrangian elasticity tensor for Neo-Hookean material model.  <a href="#a606ddc7f909062e9faae9f4a311ccd8a">More...</a><br /></td></tr>
<tr class="separator:a606ddc7f909062e9faae9f4a311ccd8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e588bb8d290158200c6e35826f7566"><td class="memItemLeft" align="right" valign="top">gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a56e588bb8d290158200c6e35826f7566">calculateCompactStressForNodalForces</a> (double detFe, gsl_matrix *Fe, gsl_matrix *S, gsl_matrix *Stress)</td></tr>
<tr class="memdesc:a56e588bb8d290158200c6e35826f7566"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates elemental stress in Voigt notation.  <a href="#a56e588bb8d290158200c6e35826f7566">More...</a><br /></td></tr>
<tr class="separator:a56e588bb8d290158200c6e35826f7566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9eaa594e8955de91b2f4b0368c85bae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9eaa594e8955de91b2f4b0368c85bae"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ac9eaa594e8955de91b2f4b0368c85bae">calculateInverseJacobianStackForNodalForces</a> (gsl_matrix *Jacobian)</td></tr>
<tr class="memdesc:ac9eaa594e8955de91b2f4b0368c85bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the stack matrix of inverse Jacobians, used to calculate the nodal forces. <br /></td></tr>
<tr class="separator:ac9eaa594e8955de91b2f4b0368c85bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67919694a1d780e31f6d539781377be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad67919694a1d780e31f6d539781377be"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ad67919694a1d780e31f6d539781377be">calculateBTforNodalForces</a> (gsl_matrix *InvJacobianStack, gsl_matrix *ShapeFuncDerStack, gsl_matrix *B, gsl_matrix *invJShFuncDerS)</td></tr>
<tr class="memdesc:ad67919694a1d780e31f6d539781377be"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the B matrix, to calculate the nodal force. <br /></td></tr>
<tr class="separator:ad67919694a1d780e31f6d539781377be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d984ddba5bbeae91cb3180897a5a3e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d984ddba5bbeae91cb3180897a5a3e7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a8d984ddba5bbeae91cb3180897a5a3e7">calculateInvJShFuncDerSWithFe</a> (gsl_matrix *currFe, gsl_matrix *InvDXde, gsl_matrix *ShapeFuncDerStack, gsl_matrix *invJShFuncDerSWithF)</td></tr>
<tr class="memdesc:a8d984ddba5bbeae91cb3180897a5a3e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the collated matrix from inverse jaconians and shape function derivatives. <br /></td></tr>
<tr class="separator:a8d984ddba5bbeae91cb3180897a5a3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb0d14adc7ac116191bcff4a7837e98"><td class="memItemLeft" align="right" valign="top">gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aafb0d14adc7ac116191bcff4a7837e98">calculateVelocityGradientTensor</a> (gsl_matrix *B, gsl_matrix *displacementPerDt)</td></tr>
<tr class="memdesc:aafb0d14adc7ac116191bcff4a7837e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the velocity gradient tensor.  <a href="#aafb0d14adc7ac116191bcff4a7837e98">More...</a><br /></td></tr>
<tr class="separator:aafb0d14adc7ac116191bcff4a7837e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcdbbe37a746ade52a1af70a9aa12b9f"><td class="memItemLeft" align="right" valign="top">gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#afcdbbe37a746ade52a1af70a9aa12b9f">constructElementalDisplacementMatrix</a> (gsl_matrix *displacement)</td></tr>
<tr class="memdesc:afcdbbe37a746ade52a1af70a9aa12b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will assemble elemental node displacement matrix from the input displacement matrix for the whole system.  <a href="#afcdbbe37a746ade52a1af70a9aa12b9f">More...</a><br /></td></tr>
<tr class="separator:afcdbbe37a746ade52a1af70a9aa12b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbf191777e8787a0e8307d30ce0aa9d"><td class="memItemLeft" align="right" valign="top">gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#afbbf191777e8787a0e8307d30ce0aa9d">calculateRateOfDeformationTensor</a> (gsl_matrix *l)</td></tr>
<tr class="memdesc:afbbf191777e8787a0e8307d30ce0aa9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will calculate rate of deformation tensor from velocity gradient tensor.  <a href="#afbbf191777e8787a0e8307d30ce0aa9d">More...</a><br /></td></tr>
<tr class="separator:afbbf191777e8787a0e8307d30ce0aa9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ffae25fafb0fa584a3a4d0196af7aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a22ffae25fafb0fa584a3a4d0196af7aa">calculateViscousStress</a> (gsl_matrix *d, gsl_matrix *<a class="el" href="classShapeBase.html#a29f180dc41c5b6e12b9468dd557bb524">viscousStress</a>)</td></tr>
<tr class="memdesc:a22ffae25fafb0fa584a3a4d0196af7aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will calculate internal viscous stress of the element from rate of deformation matrix.  <a href="#a22ffae25fafb0fa584a3a4d0196af7aa">More...</a><br /></td></tr>
<tr class="separator:a22ffae25fafb0fa584a3a4d0196af7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d10225f251fa1bd8a2e6ffc8feb5326"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a4d10225f251fa1bd8a2e6ffc8feb5326">calculateViscousForces</a> (gsl_matrix *gv, gsl_matrix *BTdetFdetdXde, gsl_matrix *<a class="el" href="classShapeBase.html#a29f180dc41c5b6e12b9468dd557bb524">viscousStress</a>)</td></tr>
<tr class="memdesc:a4d10225f251fa1bd8a2e6ffc8feb5326"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will calculate the elemental viscous forces from viscous stress.  <a href="#a4d10225f251fa1bd8a2e6ffc8feb5326">More...</a><br /></td></tr>
<tr class="separator:a4d10225f251fa1bd8a2e6ffc8feb5326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae9fb15fa6e3f99173841ea910710c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ae9fb15fa6e3f99173841ea910710c1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a7ae9fb15fa6e3f99173841ea910710c1">consturctBaTBb</a> (gsl_matrix *B, gsl_matrix *BaT, gsl_matrix *Bb, int a, int b)</td></tr>
<tr class="memdesc:a7ae9fb15fa6e3f99173841ea910710c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function constructs nodal subrange of B matrix for node couple a &amp; b. <br /></td></tr>
<tr class="separator:a7ae9fb15fa6e3f99173841ea910710c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb02278c3894e00fdbc0cd2e379111ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb02278c3894e00fdbc0cd2e379111ce"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#abb02278c3894e00fdbc0cd2e379111ce">calculateElasticKIntegral1</a> (gsl_matrix *currElementalK, int pointNo)</td></tr>
<tr class="memdesc:abb02278c3894e00fdbc0cd2e379111ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calcultes the first part of the integral for the stiffness matirx, the elastic part of the system Jacobian. <br /></td></tr>
<tr class="separator:abb02278c3894e00fdbc0cd2e379111ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a5f7382e5d4038e4396d3f4a198105"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74a5f7382e5d4038e4396d3f4a198105"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a74a5f7382e5d4038e4396d3f4a198105">calculateElasticKIntegral2</a> (gsl_matrix *currElementalK, int pointNo)</td></tr>
<tr class="memdesc:a74a5f7382e5d4038e4396d3f4a198105"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calcultes the second part of the integral for the stiffness matirx, the elastic part of the system Jacobian. <br /></td></tr>
<tr class="separator:a74a5f7382e5d4038e4396d3f4a198105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cdcb5b445291f28d3ed3d83c582f534"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5cdcb5b445291f28d3ed3d83c582f534"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a5cdcb5b445291f28d3ed3d83c582f534">calculateViscousKIntegral1</a> (gsl_matrix *currElementalK, gsl_matrix *paranthesisTermForKv1, int pointNo)</td></tr>
<tr class="memdesc:a5cdcb5b445291f28d3ed3d83c582f534"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calcultes the first part of the integral for the internal viscous part of the system Jacobian. <br /></td></tr>
<tr class="separator:a5cdcb5b445291f28d3ed3d83c582f534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9795e5aad1361070df5ecdd735d9361b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9795e5aad1361070df5ecdd735d9361b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a9795e5aad1361070df5ecdd735d9361b">calculateViscousKIntegral2</a> (gsl_matrix *currElementalK, int pointNo)</td></tr>
<tr class="memdesc:a9795e5aad1361070df5ecdd735d9361b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calcultes the second part of the integral for the viscous part of the system Jacobian. <br /></td></tr>
<tr class="separator:a9795e5aad1361070df5ecdd735d9361b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858ee3ff9bc490dc6584741f786c9478"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a858ee3ff9bc490dc6584741f786c9478"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a858ee3ff9bc490dc6584741f786c9478">calculateVelocityGradient</a> (gsl_matrix *velocityGradient, gsl_matrix *displacementPerDt, int pointNo)</td></tr>
<tr class="memdesc:a858ee3ff9bc490dc6584741f786c9478"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the velocity gradient. <br /></td></tr>
<tr class="separator:a858ee3ff9bc490dc6584741f786c9478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a71f51dacb8bdf18e1a9914e763016"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4a71f51dacb8bdf18e1a9914e763016"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ac4a71f51dacb8bdf18e1a9914e763016">calculateOuterProduct</a> (gsl_matrix *a, gsl_matrix *b, gsl_matrix *outerProduct)</td></tr>
<tr class="memdesc:ac4a71f51dacb8bdf18e1a9914e763016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the outer product, maths helper function. <br /></td></tr>
<tr class="separator:ac4a71f51dacb8bdf18e1a9914e763016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5eefd4db5c7a4e8495a197f76446a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e5eefd4db5c7a4e8495a197f76446a8"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a2e5eefd4db5c7a4e8495a197f76446a8">calculateSymmetricisedTensorProduct</a> (gsl_matrix *a, gsl_matrix *b)</td></tr>
<tr class="memdesc:a2e5eefd4db5c7a4e8495a197f76446a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the symetricised tensor product, maths helper function. <br /></td></tr>
<tr class="separator:a2e5eefd4db5c7a4e8495a197f76446a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a660608ede71c5bfdd1c4956843760"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a91a660608ede71c5bfdd1c4956843760">disassembleRotationMatrixForZ</a> (gsl_matrix *rotMat)</td></tr>
<tr class="memdesc:a91a660608ede71c5bfdd1c4956843760"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function extracts the z rotation from a rotation matrix.  <a href="#a91a660608ede71c5bfdd1c4956843760">More...</a><br /></td></tr>
<tr class="separator:a91a660608ede71c5bfdd1c4956843760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b249ac3da27e7eeb6e0604a76f15faf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a9b249ac3da27e7eeb6e0604a76f15faf">calculate3DRotMatFromF</a> (gsl_matrix *rotMat)</td></tr>
<tr class="memdesc:a9b249ac3da27e7eeb6e0604a76f15faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function dissects the deformation gradient of the element into the rigid body rotation and deformation.  <a href="#a9b249ac3da27e7eeb6e0604a76f15faf">More...</a><br /></td></tr>
<tr class="separator:a9b249ac3da27e7eeb6e0604a76f15faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a36aedd41e8465a186a0b0c454b5b76f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36aedd41e8465a186a0b0c454b5b76f3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a36aedd41e8465a186a0b0c454b5b76f3">ShapeType</a></td></tr>
<tr class="memdesc:a36aedd41e8465a186a0b0c454b5b76f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The integer defining the type of the shape, Prisms shape type = 1;. <br /></td></tr>
<tr class="separator:a36aedd41e8465a186a0b0c454b5b76f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0daa5629b1335ca3e1be089a006fe897"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0daa5629b1335ca3e1be089a006fe897"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a0daa5629b1335ca3e1be089a006fe897">nNodes</a></td></tr>
<tr class="memdesc:a0daa5629b1335ca3e1be089a006fe897"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of nodes of the element, it is based on <a class="el" href="classShapeBase.html#a36aedd41e8465a186a0b0c454b5b76f3" title="The integer defining the type of the shape, Prisms shape type = 1;. ">ShapeBase::ShapeType</a>. <br /></td></tr>
<tr class="separator:a0daa5629b1335ca3e1be089a006fe897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae4246d158f4d66b5bd1644df40f150"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ae4246d158f4d66b5bd1644df40f150"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a0ae4246d158f4d66b5bd1644df40f150">nDim</a></td></tr>
<tr class="memdesc:a0ae4246d158f4d66b5bd1644df40f150"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of dimensions for the positions of each of the nodes of the element. <br /></td></tr>
<tr class="separator:a0ae4246d158f4d66b5bd1644df40f150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6daae25e30af2e55599b7d1ecfbddb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c6daae25e30af2e55599b7d1ecfbddb"></a>
std::array&lt; int, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a8c6daae25e30af2e55599b7d1ecfbddb">IdentifierColour</a></td></tr>
<tr class="memdesc:a8c6daae25e30af2e55599b7d1ecfbddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unique identifier colour of the element, this is used for "picking" in the visual interface. <br /></td></tr>
<tr class="separator:a8c6daae25e30af2e55599b7d1ecfbddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af537b85b81aa4f0812508e7a95b8b67a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af537b85b81aa4f0812508e7a95b8b67a"></a>
std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#af537b85b81aa4f0812508e7a95b8b67a">GrowthRate</a></td></tr>
<tr class="memdesc:af537b85b81aa4f0812508e7a95b8b67a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Growth rate recording for display purposes only. The recorded growth rate in x, y, and z coordinates, does not record shear deformation induced in growth. Recorded in exponential form through time step, converted to rate per hour for display within the visual interface. <br /></td></tr>
<tr class="separator:af537b85b81aa4f0812508e7a95b8b67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af553856335d7344ea67ab10f9cc3babf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af553856335d7344ea67ab10f9cc3babf"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#af553856335d7344ea67ab10f9cc3babf">growthIncrement</a></td></tr>
<tr class="memdesc:af553856335d7344ea67ab10f9cc3babf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matrix (3,3) representing the incremental growth in current time step. Reset to identity at the beginning of each time step, updated in growth functions, and utilised to update Fg. <br /></td></tr>
<tr class="separator:af553856335d7344ea67ab10f9cc3babf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61c4a1f4132f54c362ea6296389abf6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab61c4a1f4132f54c362ea6296389abf6"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ab61c4a1f4132f54c362ea6296389abf6">plasticDeformationIncrement</a></td></tr>
<tr class="memdesc:ab61c4a1f4132f54c362ea6296389abf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matrix (3,3) representing the incremental plastic deformation (treated as growth) in current time step. Set in plastic deformation calculation at each step, and utilised to update Fg. <br /></td></tr>
<tr class="separator:ab61c4a1f4132f54c362ea6296389abf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db4859942429aa4e3efc26a119a5aa3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2db4859942429aa4e3efc26a119a5aa3"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a2db4859942429aa4e3efc26a119a5aa3">shapeChangeIncrement</a></td></tr>
<tr class="memdesc:a2db4859942429aa4e3efc26a119a5aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matrix (3,3) representing the incremental shape change in current time step. Reset to identity at the beginning of each time step, updated in shape change functions, and utilised to update Fg. <br /></td></tr>
<tr class="separator:a2db4859942429aa4e3efc26a119a5aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc566eb70e64da9fc3fa222b16999da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0dc566eb70e64da9fc3fa222b16999da"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a0dc566eb70e64da9fc3fa222b16999da">zRemodellingSoFar</a></td></tr>
<tr class="memdesc:a0dc566eb70e64da9fc3fa222b16999da"><td class="mdescLeft">&#160;</td><td class="mdescRight">The z remodelling that have been applied to elemetn up to the current time step. This parameter is used to limit extreme thinning or elongation of elements. <br /></td></tr>
<tr class="separator:a0dc566eb70e64da9fc3fa222b16999da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134d82ba500ef829b6aa3e3a83783c9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a134d82ba500ef829b6aa3e3a83783c9a"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a134d82ba500ef829b6aa3e3a83783c9a">columnarGrowthWeight</a></td></tr>
<tr class="memdesc:a134d82ba500ef829b6aa3e3a83783c9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fraction defining how close to the columnar layer the element is. 1.0 for columnar layer, 0.0 for peripodial membrane elements, and scaled according to position in the elements surrounding the lumen. <br /></td></tr>
<tr class="separator:a134d82ba500ef829b6aa3e3a83783c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3663f3220016756b1bd5a92477325ec2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3663f3220016756b1bd5a92477325ec2"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a3663f3220016756b1bd5a92477325ec2">peripodialGrowthWeight</a></td></tr>
<tr class="memdesc:a3663f3220016756b1bd5a92477325ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fraction defining how close to the peripodial membrane the element is. 0.0 for columnar layer, 1.0 for peripodial membrane elements, and scaled according to position in the elements surrounding the lumen. <br /></td></tr>
<tr class="separator:a3663f3220016756b1bd5a92477325ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3b7ef81761fc22f3bad866570f3d13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb3b7ef81761fc22f3bad866570f3d13"></a>
std::array&lt; double, 6 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#acb3b7ef81761fc22f3bad866570f3d13">ShapeChangeRate</a></td></tr>
<tr class="memdesc:acb3b7ef81761fc22f3bad866570f3d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shape change rate of the elements, only orthagonal shape changes are allowed (x, y, z). Shape changes will be scaled to conserve volume, thus three values will not be independent. <br /></td></tr>
<tr class="separator:acb3b7ef81761fc22f3bad866570f3d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6a2cd267d49404f5442a48c867860f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee6a2cd267d49404f5442a48c867860f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aee6a2cd267d49404f5442a48c867860f">rotatedGrowth</a></td></tr>
<tr class="memdesc:aee6a2cd267d49404f5442a48c867860f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean stating if the element has rotated from the growth axis, hence the calculated growth requires further rotation to follow tissue axes. <br /></td></tr>
<tr class="separator:aee6a2cd267d49404f5442a48c867860f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e2ed2804c9d949810f2b9288c1d6ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1e2ed2804c9d949810f2b9288c1d6ba"></a>
std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#af1e2ed2804c9d949810f2b9288c1d6ba">relativePosInBoundingBox</a></td></tr>
<tr class="memdesc:af1e2ed2804c9d949810f2b9288c1d6ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">The relative position on x-y plane, within the bounding box of the tissue(x,y). <br /></td></tr>
<tr class="separator:af1e2ed2804c9d949810f2b9288c1d6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37eecd113e033c1b5cd64c5a6fefedc1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37eecd113e033c1b5cd64c5a6fefedc1"></a>
std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a37eecd113e033c1b5cd64c5a6fefedc1">initialRelativePosInBoundingBox</a></td></tr>
<tr class="memdesc:a37eecd113e033c1b5cd64c5a6fefedc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The relative position on x-y plane, within the bounding box of the tissue(x,y) at the beginning of simulation. This is used when growth rates are pinned to the initial structure of the tissue. <br /></td></tr>
<tr class="separator:a37eecd113e033c1b5cd64c5a6fefedc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6847e4087010221acd07ad298c5c0bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6847e4087010221acd07ad298c5c0bd"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ab6847e4087010221acd07ad298c5c0bd">initialRelativePositionInZ</a></td></tr>
<tr class="memdesc:ab6847e4087010221acd07ad298c5c0bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The relative position on z-height of tissue, taken not in z direction but in tissue layers, 0 being on the apical surface and 1 being on the basal surface. <br /></td></tr>
<tr class="separator:ab6847e4087010221acd07ad298c5c0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c80fec4188317146cb31b74c36c7640"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c80fec4188317146cb31b74c36c7640"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a5c80fec4188317146cb31b74c36c7640">numberOfGaussPoints</a></td></tr>
<tr class="memdesc:a5c80fec4188317146cb31b74c36c7640"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of Gauss points used in numerical deforamtion calculation. <br /></td></tr>
<tr class="separator:a5c80fec4188317146cb31b74c36c7640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f6b579cace44139825e3105c101431"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9f6b579cace44139825e3105c101431"></a>
std::array&lt; std::array&lt; double, 3 &gt;, 6 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ad9f6b579cace44139825e3105c101431">gaussPoints</a></td></tr>
<tr class="memdesc:ad9f6b579cace44139825e3105c101431"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array contianing all the Gauss points for element. Set up is for 6, can work for any number as loops are kept indexed up to numberOfGaussPoints. <br /></td></tr>
<tr class="separator:ad9f6b579cace44139825e3105c101431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ec0d74748313a30a280258bd1e1827"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50ec0d74748313a30a280258bd1e1827"></a>
std::array&lt; double, 6 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a50ec0d74748313a30a280258bd1e1827">gaussWeights</a></td></tr>
<tr class="memdesc:a50ec0d74748313a30a280258bd1e1827"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array for storing the weights of each Gauss point for element. <br /></td></tr>
<tr class="separator:a50ec0d74748313a30a280258bd1e1827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9451400710c0458e286c9183b8014a71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9451400710c0458e286c9183b8014a71"></a>
std::vector&lt; gsl_matrix * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a9451400710c0458e286c9183b8014a71">ShapeFuncDerivatives</a></td></tr>
<tr class="memdesc:a9451400710c0458e286c9183b8014a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array of matrices for shape function derivatives. The array stores a <a class="el" href="classShapeBase.html#a0ae4246d158f4d66b5bd1644df40f150" title="The number of dimensions for the positions of each of the nodes of the element. ">ShapeBase::nDim</a> by <a class="el" href="classShapeBase.html#a0daa5629b1335ca3e1be089a006fe897" title="The number of nodes of the element, it is based on ShapeBase::ShapeType. ">ShapeBase::nNodes</a> matrix for each gauss point (there are 3 Gauss points for prisms). <br /></td></tr>
<tr class="separator:a9451400710c0458e286c9183b8014a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21657fc100e70eaec475616adf308f81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21657fc100e70eaec475616adf308f81"></a>
std::vector&lt; gsl_matrix * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a21657fc100e70eaec475616adf308f81">ShapeFuncDerStacks</a></td></tr>
<tr class="memdesc:a21657fc100e70eaec475616adf308f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array of matrices of shape function derivatives in stacked format for ease of matrix operations. The array stores a (<a class="el" href="classShapeBase.html#a0ae4246d158f4d66b5bd1644df40f150" title="The number of dimensions for the positions of each of the nodes of the element. ">ShapeBase::nDim</a> * <a class="el" href="classShapeBase.html#a0ae4246d158f4d66b5bd1644df40f150" title="The number of dimensions for the positions of each of the nodes of the element. ">ShapeBase::nDim</a>) by (<a class="el" href="classShapeBase.html#a0ae4246d158f4d66b5bd1644df40f150" title="The number of dimensions for the positions of each of the nodes of the element. ">ShapeBase::nDim</a> * <a class="el" href="classShapeBase.html#a0daa5629b1335ca3e1be089a006fe897" title="The number of nodes of the element, it is based on ShapeBase::ShapeType. ">ShapeBase::nNodes</a>) matrix for each gauss point (there are 3 Gauss points for prisms). <br /></td></tr>
<tr class="separator:a21657fc100e70eaec475616adf308f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad96a4f7ac584f37627a341f1c6a6156"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad96a4f7ac584f37627a341f1c6a6156"></a>
std::vector&lt; gsl_matrix * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aad96a4f7ac584f37627a341f1c6a6156">InvdXdes</a></td></tr>
<tr class="memdesc:aad96a4f7ac584f37627a341f1c6a6156"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array stores inverse of the matrix for derivatives of world coordinates with respect to barycentric coordinates (dX / de). The array stores an <a class="el" href="classShapeBase.html#a0ae4246d158f4d66b5bd1644df40f150" title="The number of dimensions for the positions of each of the nodes of the element. ">ShapeBase::nDim</a> by <a class="el" href="classShapeBase.html#a0ae4246d158f4d66b5bd1644df40f150" title="The number of dimensions for the positions of each of the nodes of the element. ">ShapeBase::nDim</a> matrix for each gauss point (there are 3 Gauss points for prisms). <br /></td></tr>
<tr class="separator:aad96a4f7ac584f37627a341f1c6a6156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f25110de54965266cb29b66eaf5b81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37f25110de54965266cb29b66eaf5b81"></a>
std::array&lt; double, 6 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a37f25110de54965266cb29b66eaf5b81">detdXdes</a></td></tr>
<tr class="memdesc:a37f25110de54965266cb29b66eaf5b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array stores the determinants of the matrices for derivatives of world coordinates with respect to barycentric coordinates (dX / de). The array stores a double value for each gauss point (there are 3 Gauss points for prisms). <br /></td></tr>
<tr class="separator:a37f25110de54965266cb29b66eaf5b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04079b2f81481d44a9b3efb8916c8423"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04079b2f81481d44a9b3efb8916c8423"></a>
std::vector&lt; gsl_matrix * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a04079b2f81481d44a9b3efb8916c8423">Bmatrices</a></td></tr>
<tr class="memdesc:a04079b2f81481d44a9b3efb8916c8423"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array stores the B matrix for the calculation of stiffness matrix, see for <a class="el" href="classShapeBase.html#ad67919694a1d780e31f6d539781377be" title="This function calculates the B matrix, to calculate the nodal force. ">ShapeBase::calculateBTforNodalForces</a> calculation. The array stores an <a class="el" href="classShapeBase.html#a0daa5629b1335ca3e1be089a006fe897" title="The number of nodes of the element, it is based on ShapeBase::ShapeType. ">ShapeBase::nNodes</a> by (<a class="el" href="classShapeBase.html#a0ae4246d158f4d66b5bd1644df40f150" title="The number of dimensions for the positions of each of the nodes of the element. ">ShapeBase::nDim</a>*ShapeBase<a class="el" href="classShapeBase.html#a0daa5629b1335ca3e1be089a006fe897" title="The number of nodes of the element, it is based on ShapeBase::ShapeType. ">nNodes</a>) matrix for each Gauss point (there are 3 Gauss points for prisms). <br /></td></tr>
<tr class="separator:a04079b2f81481d44a9b3efb8916c8423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6b0d0bc99f2c07986522fd866312ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae6b0d0bc99f2c07986522fd866312ea"></a>
std::vector&lt; gsl_matrix * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aae6b0d0bc99f2c07986522fd866312ea">FeMatrices</a></td></tr>
<tr class="memdesc:aae6b0d0bc99f2c07986522fd866312ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array stores the elastic part of the deformation matrix. The array stores an <a class="el" href="classShapeBase.html#a0ae4246d158f4d66b5bd1644df40f150" title="The number of dimensions for the positions of each of the nodes of the element. ">ShapeBase::nDim</a> by <a class="el" href="classShapeBase.html#a0ae4246d158f4d66b5bd1644df40f150" title="The number of dimensions for the positions of each of the nodes of the element. ">ShapeBase::nDim</a> matrix for each Gauss point (there are 6 Gauss points for prisms). <br /></td></tr>
<tr class="separator:aae6b0d0bc99f2c07986522fd866312ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ef46748c8632768c6be10987f1c0e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18ef46748c8632768c6be10987f1c0e3"></a>
std::vector&lt; gsl_matrix * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a18ef46748c8632768c6be10987f1c0e3">invJShapeFuncDerStack</a></td></tr>
<tr class="memdesc:a18ef46748c8632768c6be10987f1c0e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array stores the shape function derivatives multiplied by the inverse Jacobian stack, for each Gauss point. See <a class="el" href="classShapeBase.html#ad67919694a1d780e31f6d539781377be" title="This function calculates the B matrix, to calculate the nodal force. ">ShapeBase::calculateBTforNodalForces</a> for calculation. <br /></td></tr>
<tr class="separator:a18ef46748c8632768c6be10987f1c0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90987ba8732360351b3994e6566c6093"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90987ba8732360351b3994e6566c6093"></a>
std::vector&lt; gsl_matrix * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a90987ba8732360351b3994e6566c6093">invJShapeFuncDerStackwithFe</a></td></tr>
<tr class="memdesc:a90987ba8732360351b3994e6566c6093"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classShapeBase.html#a8d984ddba5bbeae91cb3180897a5a3e7" title="This function calculates the collated matrix from inverse jaconians and shape function derivatives...">ShapeBase::calculateInvJShFuncDerSWithFe</a> for calculation. <br /></td></tr>
<tr class="separator:a90987ba8732360351b3994e6566c6093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec28da3cbed6bf4aad8370bd5cdad81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adec28da3cbed6bf4aad8370bd5cdad81"></a>
std::vector&lt; gsl_matrix * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#adec28da3cbed6bf4aad8370bd5cdad81">elasticStress</a></td></tr>
<tr class="memdesc:adec28da3cbed6bf4aad8370bd5cdad81"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array of matrices for elastic stress of the element. The array stores a 6 by 6 matrix for each Gauss point (there are 6 Gauss points for prisms). <br /></td></tr>
<tr class="separator:adec28da3cbed6bf4aad8370bd5cdad81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f180dc41c5b6e12b9468dd557bb524"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29f180dc41c5b6e12b9468dd557bb524"></a>
std::vector&lt; gsl_matrix * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a29f180dc41c5b6e12b9468dd557bb524">viscousStress</a></td></tr>
<tr class="memdesc:a29f180dc41c5b6e12b9468dd557bb524"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array of matrices for internal viscous stress of the element. The array stores a 6 by 6 matrix for each Gauss point (there are 6 Gauss points for prisms). <br /></td></tr>
<tr class="separator:a29f180dc41c5b6e12b9468dd557bb524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ac8f14929ab37e8eae5fcaf93b18a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7ac8f14929ab37e8eae5fcaf93b18a8"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ab7ac8f14929ab37e8eae5fcaf93b18a8">TriPointF</a></td></tr>
<tr class="memdesc:ab7ac8f14929ab37e8eae5fcaf93b18a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The deformation matrix of the element resulting from iteration over all Gauss points. The dimensions of the matrix is <a class="el" href="classShapeBase.html#a0ae4246d158f4d66b5bd1644df40f150" title="The number of dimensions for the positions of each of the nodes of the element. ">ShapeBase::nDim</a> by <a class="el" href="classShapeBase.html#a0ae4246d158f4d66b5bd1644df40f150" title="The number of dimensions for the positions of each of the nodes of the element. ">ShapeBase::nDim</a>. <br /></td></tr>
<tr class="separator:ab7ac8f14929ab37e8eae5fcaf93b18a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d201c88c73283f2e9711d1cc038e02"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94d201c88c73283f2e9711d1cc038e02"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a94d201c88c73283f2e9711d1cc038e02">ElementalElasticSystemForces</a></td></tr>
<tr class="memdesc:a94d201c88c73283f2e9711d1cc038e02"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matrix stores the elemental elastic forces. The dimensions of the matrix is <a class="el" href="classShapeBase.html#a0daa5629b1335ca3e1be089a006fe897" title="The number of nodes of the element, it is based on ShapeBase::ShapeType. ">ShapeBase::nNodes</a> by <a class="el" href="classShapeBase.html#a0ae4246d158f4d66b5bd1644df40f150" title="The number of dimensions for the positions of each of the nodes of the element. ">ShapeBase::nDim</a>. <br /></td></tr>
<tr class="separator:a94d201c88c73283f2e9711d1cc038e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b5ebd33ad4ed5739c0431bf0d4346d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54b5ebd33ad4ed5739c0431bf0d4346d"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a54b5ebd33ad4ed5739c0431bf0d4346d">ElementalInternalViscousSystemForces</a></td></tr>
<tr class="memdesc:a54b5ebd33ad4ed5739c0431bf0d4346d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matrix stores the elemental internal viscous forces. The dimensions of the matrix is <a class="el" href="classShapeBase.html#a0daa5629b1335ca3e1be089a006fe897" title="The number of nodes of the element, it is based on ShapeBase::ShapeType. ">ShapeBase::nNodes</a> by <a class="el" href="classShapeBase.html#a0ae4246d158f4d66b5bd1644df40f150" title="The number of dimensions for the positions of each of the nodes of the element. ">ShapeBase::nDim</a>. <br /></td></tr>
<tr class="separator:a54b5ebd33ad4ed5739c0431bf0d4346d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d3d2738b44a003e08a6a6b96c0b91e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01d3d2738b44a003e08a6a6b96c0b91e"></a>
std::array&lt; double, 6 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a01d3d2738b44a003e08a6a6b96c0b91e">detFs</a></td></tr>
<tr class="memdesc:a01d3d2738b44a003e08a6a6b96c0b91e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array stores the determinant of the deformation matrix for each Gauss point. <br /></td></tr>
<tr class="separator:a01d3d2738b44a003e08a6a6b96c0b91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a8101057e2771172a4716c128705d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51a8101057e2771172a4716c128705d7"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a51a8101057e2771172a4716c128705d7">ZProjectedBasalArea</a></td></tr>
<tr class="memdesc:a51a8101057e2771172a4716c128705d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The z-projected area of the basal surface of the element. <br /></td></tr>
<tr class="separator:a51a8101057e2771172a4716c128705d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7043ddacbcd92480cb54467a2777627"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7043ddacbcd92480cb54467a2777627"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aa7043ddacbcd92480cb54467a2777627">ZProjectedApicalArea</a></td></tr>
<tr class="memdesc:aa7043ddacbcd92480cb54467a2777627"><td class="mdescLeft">&#160;</td><td class="mdescRight">The z-projected area of the apical surface of the element. <br /></td></tr>
<tr class="separator:aa7043ddacbcd92480cb54467a2777627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae2b0b1dfd0672a39897e780d861254"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ae2b0b1dfd0672a39897e780d861254"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a2ae2b0b1dfd0672a39897e780d861254">BasalArea</a></td></tr>
<tr class="memdesc:a2ae2b0b1dfd0672a39897e780d861254"><td class="mdescLeft">&#160;</td><td class="mdescRight">The area of the basal surface of the element. <br /></td></tr>
<tr class="separator:a2ae2b0b1dfd0672a39897e780d861254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4227c13db7e34dd1af182d143af47b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb4227c13db7e34dd1af182d143af47b"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#adb4227c13db7e34dd1af182d143af47b">ApicalArea</a></td></tr>
<tr class="memdesc:adb4227c13db7e34dd1af182d143af47b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The area of the apical surface of the element. <br /></td></tr>
<tr class="separator:adb4227c13db7e34dd1af182d143af47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29dcfc319798bd21b3bc2b50ac401c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac29dcfc319798bd21b3bc2b50ac401c8"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ac29dcfc319798bd21b3bc2b50ac401c8">exposedLateralAreaApicalSide</a></td></tr>
<tr class="memdesc:ac29dcfc319798bd21b3bc2b50ac401c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The area of the element on a linker position, and has lateral sides exposed to outside of the tissue, on the apical side, therefore should feel external viscosity. <br /></td></tr>
<tr class="separator:ac29dcfc319798bd21b3bc2b50ac401c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba637ddf764ae673d616f7318270866"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ba637ddf764ae673d616f7318270866"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a3ba637ddf764ae673d616f7318270866">exposedLateralAreaBasalSide</a></td></tr>
<tr class="memdesc:a3ba637ddf764ae673d616f7318270866"><td class="mdescLeft">&#160;</td><td class="mdescRight">The area of the element on a linker position, and has lateral sides exposed to outside of the tissue, on the basal side, therefore should feel external viscosity. <br /></td></tr>
<tr class="separator:a3ba637ddf764ae673d616f7318270866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5dfa04e7a8c7f2c33bea431ca441674"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5dfa04e7a8c7f2c33bea431ca441674"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ab5dfa04e7a8c7f2c33bea431ca441674">elementHasExposedApicalSurface</a></td></tr>
<tr class="memdesc:ab5dfa04e7a8c7f2c33bea431ca441674"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean stating if the element has any apical surface exposed to the environment. <br /></td></tr>
<tr class="separator:ab5dfa04e7a8c7f2c33bea431ca441674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194437fa296d9e12e58cc14fa8d66931"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a194437fa296d9e12e58cc14fa8d66931"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a194437fa296d9e12e58cc14fa8d66931">elementHasExposedBasalSurface</a></td></tr>
<tr class="memdesc:a194437fa296d9e12e58cc14fa8d66931"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean stating if the element has any basal surface exposed to the environment. <br /></td></tr>
<tr class="separator:a194437fa296d9e12e58cc14fa8d66931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7987e6fc21a5035fc04558f1b366406a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7987e6fc21a5035fc04558f1b366406a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a7987e6fc21a5035fc04558f1b366406a">exposedApicalSurfaceNodeIds</a> [3]</td></tr>
<tr class="memdesc:a7987e6fc21a5035fc04558f1b366406a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The int array of size 3, listing the node IDs of element that form the exposed apical surface. The IDs are the node IDs on the element (0-5 for prism), not the actual <a class="el" href="classNode.html#a1bd379569cc1a8b96432e61971aed4d9" title="The unique identification number of the node. ">Node::Id</a>. <br /></td></tr>
<tr class="separator:a7987e6fc21a5035fc04558f1b366406a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc7714f5622b21ec7fba51e1136803f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7bc7714f5622b21ec7fba51e1136803f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a7bc7714f5622b21ec7fba51e1136803f">exposedBasalSurfaceNodeIds</a> [3]</td></tr>
<tr class="memdesc:a7bc7714f5622b21ec7fba51e1136803f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The int array of size 3, listing the node IDs of element that form the exposed basal surface. The IDs are the node IDs on the element (0-5 for prism), not the actual <a class="el" href="classNode.html#a1bd379569cc1a8b96432e61971aed4d9" title="The unique identification number of the node. ">Node::Id</a>. <br /></td></tr>
<tr class="separator:a7bc7714f5622b21ec7fba51e1136803f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2724f82bbf8c657c075826f953f0b7f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2724f82bbf8c657c075826f953f0b7f2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a2724f82bbf8c657c075826f953f0b7f2">exposedLateralAreaApicalSideNodeIds</a> [4]</td></tr>
<tr class="memdesc:a2724f82bbf8c657c075826f953f0b7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The int array of size 4, listing the node IDs of element that form the lateral surface exposed apically. The IDs are the node IDs on the element (0-5 for prism), not the actual <a class="el" href="classNode.html#a1bd379569cc1a8b96432e61971aed4d9" title="The unique identification number of the node. ">Node::Id</a>. <br /></td></tr>
<tr class="separator:a2724f82bbf8c657c075826f953f0b7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b58f2840dd8ffd571c647534ad9f0b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28b58f2840dd8ffd571c647534ad9f0b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a28b58f2840dd8ffd571c647534ad9f0b">exposedLateralAreaBasalSideNodeIds</a> [4]</td></tr>
<tr class="memdesc:a28b58f2840dd8ffd571c647534ad9f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The int array of size 4, listing the node IDs of element that form the lateral surface exposed basally. The IDs are the node IDs on the element (0-5 for prism), not the actual <a class="el" href="classNode.html#a1bd379569cc1a8b96432e61971aed4d9" title="The unique identification number of the node. ">Node::Id</a>. <br /></td></tr>
<tr class="separator:a28b58f2840dd8ffd571c647534ad9f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433035a8df676eec3fbac2e510d483b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a433035a8df676eec3fbac2e510d483b4"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a433035a8df676eec3fbac2e510d483b4">nLateralSurfaceAreaNodeNumber</a></td></tr>
<tr class="memdesc:a433035a8df676eec3fbac2e510d483b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nodes that form the lateral surfaces for the element. <br /></td></tr>
<tr class="separator:a433035a8df676eec3fbac2e510d483b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3795d719f61808a05327aa4e3cf0355"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3795d719f61808a05327aa4e3cf0355"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ad3795d719f61808a05327aa4e3cf0355">nSurfaceAreaNodeNumber</a></td></tr>
<tr class="memdesc:ad3795d719f61808a05327aa4e3cf0355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nodes that form the apical/basal surfaces for the element. <br /></td></tr>
<tr class="separator:ad3795d719f61808a05327aa4e3cf0355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525290b7f6921e964666d946b5d6774d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a525290b7f6921e964666d946b5d6774d"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a525290b7f6921e964666d946b5d6774d">stiffnessPerturbationRateInSec</a></td></tr>
<tr class="memdesc:a525290b7f6921e964666d946b5d6774d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The rate at which the stiffness of the element will be perturbed, used with the model inputs from "Stiffness_Perturbation:" header in model input file. <br /></td></tr>
<tr class="separator:a525290b7f6921e964666d946b5d6774d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9988f025f39118d8d29696709e6660d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9988f025f39118d8d29696709e6660d6"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a9988f025f39118d8d29696709e6660d6">minimumValueOfStiffnessMultiplier</a></td></tr>
<tr class="memdesc:a9988f025f39118d8d29696709e6660d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lower bound of stiffness modification multiplier, exists to prevent elements reaching unintended zero or negative stiffness values. <br /></td></tr>
<tr class="separator:a9988f025f39118d8d29696709e6660d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915634dcedd74abf27fd746758bfe935"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a915634dcedd74abf27fd746758bfe935"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a915634dcedd74abf27fd746758bfe935">maximumValueOfStiffnessMultiplier</a></td></tr>
<tr class="memdesc:a915634dcedd74abf27fd746758bfe935"><td class="mdescLeft">&#160;</td><td class="mdescRight">The upper bound of stiffness modification multiplier, exists to prevent elements reaching unrealistic hard stiffness values. <br /></td></tr>
<tr class="separator:a915634dcedd74abf27fd746758bfe935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ee77fed372f7702889bebb67875136"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35ee77fed372f7702889bebb67875136"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a35ee77fed372f7702889bebb67875136">mutationGrowthRatePerSec</a></td></tr>
<tr class="memdesc:a35ee77fed372f7702889bebb67875136"><td class="mdescLeft">&#160;</td><td class="mdescRight">The growth rate set by a mutant clone covering this element. <br /></td></tr>
<tr class="separator:a35ee77fed372f7702889bebb67875136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b83cb76a8f4ec11a4a6292c2899ba2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7b83cb76a8f4ec11a4a6292c2899ba2"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ac7b83cb76a8f4ec11a4a6292c2899ba2">mutationGrowthFold</a></td></tr>
<tr class="memdesc:ac7b83cb76a8f4ec11a4a6292c2899ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The rate of fold change in growth rate set by a mutant clone covering this element. <br /></td></tr>
<tr class="separator:ac7b83cb76a8f4ec11a4a6292c2899ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1878efccfc629e53748e8907386825b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1878efccfc629e53748e8907386825b0"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a1878efccfc629e53748e8907386825b0">D</a></td></tr>
<tr class="memdesc:a1878efccfc629e53748e8907386825b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">elasticity tensor for Kirshoff material <br /></td></tr>
<tr class="separator:a1878efccfc629e53748e8907386825b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7266beef6c849298c3786a53259bd467"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7266beef6c849298c3786a53259bd467"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a7266beef6c849298c3786a53259bd467">CoeffMat</a></td></tr>
<tr class="memdesc:a7266beef6c849298c3786a53259bd467"><td class="mdescLeft">&#160;</td><td class="mdescRight">The coefficient matrix relating the shape function derivative stack to the Voigt notation of elemental stress nad strain. <br /></td></tr>
<tr class="separator:a7266beef6c849298c3786a53259bd467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90cb382c78aa293d53bb027f84fe04b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad90cb382c78aa293d53bb027f84fe04b"></a>
std::vector&lt; std::array&lt; std::array&lt; std::array&lt; std::array&lt; double, 3 &gt;, 3 &gt;, 3 &gt;, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ad90cb382c78aa293d53bb027f84fe04b">D81</a></td></tr>
<tr class="memdesc:ad90cb382c78aa293d53bb027f84fe04b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lagrangian elasticity tensor, vector for the number of Gauss points in simulaiton. <br /></td></tr>
<tr class="separator:ad90cb382c78aa293d53bb027f84fe04b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1a3a0173841d6072a5268978463ff2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c1a3a0173841d6072a5268978463ff2"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a6c1a3a0173841d6072a5268978463ff2">E</a></td></tr>
<tr class="memdesc:a6c1a3a0173841d6072a5268978463ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Young's modulus of the element. <br /></td></tr>
<tr class="separator:a6c1a3a0173841d6072a5268978463ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4c2d3bfbc6c9785c5181a56f929151"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b4c2d3bfbc6c9785c5181a56f929151"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a8b4c2d3bfbc6c9785c5181a56f929151">v</a></td></tr>
<tr class="memdesc:a8b4c2d3bfbc6c9785c5181a56f929151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poisson's ratio of the element. <br /></td></tr>
<tr class="separator:a8b4c2d3bfbc6c9785c5181a56f929151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd0830ee5d4e64bb68e58aa77736757"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fd0830ee5d4e64bb68e58aa77736757"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a7fd0830ee5d4e64bb68e58aa77736757">internalViscosity</a></td></tr>
<tr class="memdesc:a7fd0830ee5d4e64bb68e58aa77736757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current internal viscosity of the element. <br /></td></tr>
<tr class="separator:a7fd0830ee5d4e64bb68e58aa77736757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5abc42a65cd840e1c65a1a026aa3bb65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5abc42a65cd840e1c65a1a026aa3bb65"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a5abc42a65cd840e1c65a1a026aa3bb65">originalInternalViscosity</a></td></tr>
<tr class="memdesc:a5abc42a65cd840e1c65a1a026aa3bb65"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal viscosity of the element at the beginning of the simulation, prior to physical property perturbations. <br /></td></tr>
<tr class="separator:a5abc42a65cd840e1c65a1a026aa3bb65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16b41d5791fc15531cbee067c502a5d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa16b41d5791fc15531cbee067c502a5d"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aa16b41d5791fc15531cbee067c502a5d">lambda</a></td></tr>
<tr class="memdesc:aa16b41d5791fc15531cbee067c502a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lame's second parameter, driven from Young's modulus and Poisson's ratio of the element. <br /></td></tr>
<tr class="separator:aa16b41d5791fc15531cbee067c502a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5819d0d117e5510611259177c477af8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5819d0d117e5510611259177c477af8"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ac5819d0d117e5510611259177c477af8">mu</a></td></tr>
<tr class="memdesc:ac5819d0d117e5510611259177c477af8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sheer modulus of the element. <br /></td></tr>
<tr class="separator:ac5819d0d117e5510611259177c477af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7cb600a9316597a16512ab7b6fcd6f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe7cb600a9316597a16512ab7b6fcd6f"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#afe7cb600a9316597a16512ab7b6fcd6f">InvFg</a></td></tr>
<tr class="memdesc:afe7cb600a9316597a16512ab7b6fcd6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse of growth matrix. <br /></td></tr>
<tr class="separator:afe7cb600a9316597a16512ab7b6fcd6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d7f6e8f098a7b5985c615842062014"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08d7f6e8f098a7b5985c615842062014"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a08d7f6e8f098a7b5985c615842062014">Fsc</a></td></tr>
<tr class="memdesc:a08d7f6e8f098a7b5985c615842062014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shape change matrix. <br /></td></tr>
<tr class="separator:a08d7f6e8f098a7b5985c615842062014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72828aab0668c993f57727123aa96be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad72828aab0668c993f57727123aa96be"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ad72828aab0668c993f57727123aa96be">InvFsc</a></td></tr>
<tr class="memdesc:ad72828aab0668c993f57727123aa96be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse of shape change matrix. <br /></td></tr>
<tr class="separator:ad72828aab0668c993f57727123aa96be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace20710f27099833509c474b221c25df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace20710f27099833509c474b221c25df"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ace20710f27099833509c474b221c25df">TriPointKe</a></td></tr>
<tr class="memdesc:ace20710f27099833509c474b221c25df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current elastic part of the Jacobian (stiffness matrix) of the system, averaged over all Gauss Points. <br /></td></tr>
<tr class="separator:ace20710f27099833509c474b221c25df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa5b1338e405a2c75c8d010f4153b05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fa5b1338e405a2c75c8d010f4153b05"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a7fa5b1338e405a2c75c8d010f4153b05">TriPointKv</a></td></tr>
<tr class="memdesc:a7fa5b1338e405a2c75c8d010f4153b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current viscous part of the Jacobian of the system, averaged over all Gauss Points. <br /></td></tr>
<tr class="separator:a7fa5b1338e405a2c75c8d010f4153b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af919db3ff5e6a6d4a137cf4625189c23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ShapeBase::~ShapeBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The <a class="el" href="classShapeBase.html">ShapeBase</a> destructor. This destructor should not be called uner healthy conditions. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2e8e11261fb35bc925259151218eebf3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShapeBase::addToTriPointKe </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is to add the input value, to the (i,j)th element of the ElementalElasticSystemForces. </p>
<p>This funciton adds the input value to the elemental stiffness matrix, elastic part of the elemental Jacobian, <a class="el" href="classShapeBase.html#ace20710f27099833509c474b221c25df" title="Current elastic part of the Jacobian (stiffness matrix) of the system, averaged over all Gauss Points...">ShapeBase::TriPointKe</a>, at the input indices (i,j).</p>

</div>
</div>
<a class="anchor" id="a9b249ac3da27e7eeb6e0604a76f15faf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ShapeBase::calculate3DRotMatFromF </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>rotMat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function dissects the deformation gradient of the element into the rigid body rotation and deformation. </p>
<p>The rigid body rotation is extracted via single value decomposition.</p>
<p>The decomposition isdone by the gsl routine gsl_linalg_SV_decomp, and here, the output gives Sgsl as \( \mathbf{U} \) , the rotation matrix \( \mathbf{U} \mathbf{V}^{T} \) in the decomposition \( \mathbf{A} = \mathbf{U} \mathbf{S} \mathbf{V}^{T} \)</p>

</div>
</div>
<a class="anchor" id="ae09cb91359e10677889c3f59c3f5d70a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix * ShapeBase::calculateCauchyGreenDeformationTensor </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>Fe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function calculates the Caucy-Green deformation tensor, from the elastic part of the deformation gradient. </p>
<p>The Cauchy Green deformation Tensor \( \mathbf{C} \) is defned as: <br />
 \( \mathbf{C} = \left( \mathbf{F}^{eT} \mathbf{F}^{e} \right) \) where \( \mathbf{F}^{e} \) is the elastic part of the deformation gradient.</p>

</div>
</div>
<a class="anchor" id="a56e588bb8d290158200c6e35826f7566"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix * ShapeBase::calculateCompactStressForNodalForces </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>detFe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>Fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>Stress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function calculates elemental stress in Voigt notation. </p>
<p>Stress is calculated via: <br />
 \( \mathbf{\sigma}^e = J^{e-1} \mathbf{F}^{e} \mathbf{S}^{e} \mathbf{F}^{eT} \)</p>

</div>
</div>
<a class="anchor" id="a58ffd31ed76797d558b085fe754cc4b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ShapeBase::calculateCurrentGrownAndEmergentVolumes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the function to calculate hte current ideal volume of the element and its current apparent volume. </p>
<p>Once the reference volume is calculated, the current prefered volume is obtained by scaling the reference shape volume by the determinant of the growth deformation gradinet <a class="el" href="classShapeBase.html#a4156d7c7f91f0b528214b74277279df0" title="Growth deformation gradient. ">ShapeBase::Fg</a>. On the other hand, current emergent volume is the deformed volume and should be obtained by scaling the reference volume with the determinant of the total deformation gradient, including both growth and deformation.</p>

</div>
</div>
<a class="anchor" id="a347fb2687678294a252a12820842cb0d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix * ShapeBase::calculateEForNodalForcesKirshoff </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>C</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function calculates the green strains for a Kirshoff material model. </p>
<p>\( \mathbf{E} \) for Kirshoff material is: <br />
 \( \mathbf{E} = \frac{1}{2} \times \left( \mathbf{C}- \mathbf{I} \right) \) where \( \mathbf{C} \) is the Cauchy Green deformation Tensor calculated in <a class="el" href="classShapeBase.html#ae09cb91359e10677889c3f59c3f5d70a" title="This function calculates the Caucy-Green deformation tensor, from the elastic part of the deformation...">ShapeBase::calculateCauchyGreenDeformationTensor</a> and \( \mathbf{I} \) is identity.</p>

</div>
</div>
<a class="anchor" id="a3eecbff8db98871f4b5f1ee0992f3d6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ShapeBase::calculateEmergentShapeOrientation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This fucntion calculates the orientation of the emergent shape of an element in the xy plane of the tissue. </p>
<p>The function calculates in which direction the emergent shape is oriented. We need to have the combination of growth gradient and deformation gradient. It will reflect how the clones would "look":</p>
<p>We keep a copy of the original <a class="el" href="classShapeBase.html#a4bda00f80968d836c647afe5f6d1fb36" title="The gsl_matrix pointer, storing the address of the current strains on the element. ">ShapeBase::Strain</a> to utilise the Strain matrix in eigen value decomposition.</p>
<p>Calculated by the funciton <a class="el" href="classShapeBase.html#a6fe833f9684db5cc1847761b6bbd9aa9" title="This function calculates the principal components of the strains through eigen values and eigen vecto...">ShapeBase::calculatePrincipalStrains2D</a>, the Eigen vector matrix is a 3 by 3 matrix, but only stores the 2D vectors in its upper corner 2x2 terms. The vectors are written in columns of the matrix. The strain I have here is Green strain, I would like to convert it back to deformation gradient terms. Since \( E = 1/2 *(Fe^T*Fe-I): \) \( F_{ii} = \sqrt{e_{i} \times 2 + 1} \)</p>
<p>Then with the aspect ratio, the emergent long and short axes are calculated.</p>
<p>Finally, the original <a class="el" href="classShapeBase.html#a4bda00f80968d836c647afe5f6d1fb36" title="The gsl_matrix pointer, storing the address of the current strains on the element. ">ShapeBase::Strain</a> are copied over back to the Strains matrix</p>
<p>The function returns the volumentric strain (ratio of emergent volume to reference shape volume) as autput.</p>

</div>
</div>
<a class="anchor" id="a23ed61e92393b0d7364a4a99ac0f77f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShapeBase::calculateFgFromGridCorners </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gridGrowthsInterpolationType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGrowthFunctionBase.html">GrowthFunctionBase</a> *&#160;</td>
          <td class="paramname"><em>currGF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>increment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sourceTissue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>IndexX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>IndexY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>FracX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dFracY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This fucntion will calculate the incremental growth deformation gradient change for the current time step by reading it from the grid, and interpolating on 4 corners. </p>
<p>The current growth deformation gradient increment is calculated from the input growth magnitude and rotations map in a grid <br />
 First check point is for cheking if the growth function is applicable to the element, via <a class="el" href="classShapeBase.html#aa0f0cc5b33f3e12d91a246cc591c346c" title="The function checks if the element if affected by the current growth functions. ">ShapeBase::isGrowthRateApplicable</a>. If the element is growing, the four corners of the grid that are closest to the relative position of the element are extracted from the input grid. The growth rates are obtained at four the corners via the function GrowthBase::getGrowthProfileAt4Corners. Depending on th einterpolation method chosen, the growth of the point can be mapped to the closest corner, or can be interpolated between the points depending on the distance the relative position of the element centre falls within the grid: <br />
</p><pre class="fragment">       [point 2] ------------- [point 3]
          |                        |
          |&lt;--fracX----&gt; (o)       |
          |               |        |
          |               |        |
          |             fracY      |
          |               |        |
       [point 0] ------------- [point 1]
</pre><p>In the interpolation schenario, the angles are checked and for the corners that have an aspect ratio over the threshold the angle is included in the averaging.</p>
<p>A linera interpolation with the distances are carried out for teh growth rates and orientation angles:</p>
<p>If the element is <a class="el" href="classShapeBase.html#a892e478508ed8a375f0816b330e36ac1" title="Boolean stating if the element is forming the actin dense layer on the apical surface. ">ShapeBase::isActinMimicing</a>, then growth in the tissue height is ignored.</p>
<p>Then growth is scaled if there is any distribution of tissue volume in z axis, thourgh <a class="el" href="classShapeBase.html#aace7f6727db271b84db82d0560d26b86" title="This function will modify the incremental growth deformation gradient of the element to reflect the v...">ShapeBase::scaleGrowthForZRedistribution</a>.</p>

</div>
</div>
<a class="anchor" id="a45508a35016a845b9c3b2d8f7d51479a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShapeBase::calculateFgFromRates </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>rotMat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>increment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sourceTissue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>zMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>zMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This fucntion will calculate the incremental growth deformation gradient change for the current time step, from input growth rates. </p>
<p>The current growth deformation gradient increment is calculated from rates and rotation.<br />
First check point is for cheking if the growth function is applicable to the element, via <a class="el" href="classShapeBase.html#aa0f0cc5b33f3e12d91a246cc591c346c" title="The function checks if the element if affected by the current growth functions. ">ShapeBase::isGrowthRateApplicable</a>. If the element is growing, the diagonal of the growth increment is obtained. Then the increment is rotated with a tensor rotation (M' = R M R^T), using the input rotation matrix.</p>

</div>
</div>
<a class="anchor" id="a1afbb15d92215f337090262753eb24ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ShapeBase::calculateForces3D </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>Nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>displacementPerDt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function calculates the viscous and elastic forces generated by the element. </p>
<p>The nodal forces are calculated as an average of all Gauss Points. The number of Gauss Points and their weights are stored in <a class="el" href="classShapeBase.html#a5c80fec4188317146cb31b74c36c7640" title="The number of Gauss points used in numerical deforamtion calculation. ">ShapeBase::numberOfGaussPoints</a> and <a class="el" href="classShapeBase.html#a50ec0d74748313a30a280258bd1e1827" title="The array for storing the weights of each Gauss point for element. ">ShapeBase::gaussWeights</a>, respectively. The order of points weights should be consistent with point definition order in shape function derivative calculation. The nodal forces for the selected Gauss point are calculated via <a class="el" href="classShapeBase.html#acca6ea9484bbc995d941f1a7bb25e1db" title="The virtual function to calculate nodal force. This is topology dependent and implemented in each chi...">ShapeBase::calculateCurrNodalForces</a>. Then the output nodal elastic forces, viscous forces, and the deformation gradient are scaled with weights.</p>
<p>Then the elemental forces are written on the system forces.</p>

</div>
</div>
<a class="anchor" id="a9ae4c5fc8817528493502e3f75c9a984"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShapeBase::CalculateGrowthRotationByF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates the rigid body rotation of the element around the z axis of the tissue from hte fecormation gradient. </p>
<p>The rigid body rotation is extracted from the deformation gradient, and the rotation around the z-axis is stored. The disassembling of the rigid body rotation is carried out via <a class="el" href="classShapeBase.html#a91a660608ede71c5bfdd1c4956843760" title="This function extracts the z rotation from a rotation matrix. ">ShapeBase::disassembleRotationMatrixForZ</a>.</p>

</div>
</div>
<a class="anchor" id="a20c23d30b7f9f3bc7ed2fde542401aeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShapeBase::calculateImplicitKViscous </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>displacementPerDt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates the elemental viscous component of the Jacobian for implicit NR itaration. </p>
<p>The viscous part of the elemental Jacobian will be calculated over the sum of two integrals, via <a class="el" href="classShapeBase.html#a5cdcb5b445291f28d3ed3d83c582f534" title="This function calcultes the first part of the integral for the internal viscous part of the system Ja...">ShapeBase::calculateViscousKIntegral1</a> and <a class="el" href="classShapeBase.html#a9795e5aad1361070df5ecdd735d9361b" title="This function calcultes the second part of the integral for the viscous part of the system Jacobian...">ShapeBase::calculateViscousKIntegral2</a>. The inputs are: <br />
1) the displacement between the current N-R iteration positions \( \mathbf{u}_k^{t+\Delta t} \) and the nodal positions at teh end of previous step \( \mathbf{u}_n^{t} \). <br />
2) the time step, \( \Delta t \). <br />
The calculation is carried out over all Gauss Points.</p>

</div>
</div>
<a class="anchor" id="aa1c9eda4ef1eb0b23620235039bab921"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShapeBase::calculatePlasticDeformation3D </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>volumeConserved</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>plasticDeformationHalfLife</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>zRemodellingLowerThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>zRemodellingUpperThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates the plastic deformation (remodelling) from the current elastic deformation gradient. </p>
<p>This function calculates the plastic deformation (remodelling) from the current elastic deformation gradient. First check is against tissue specific compartments and z remodelling capping. The linker zone of the tissue and ECM mimicking elements should be able to remodell in z regardless of currently active caps.</p>
<p>The princiapl starins on the element are then calculated bie eigen vsalue decomposition via <a class="el" href="classShapeBase.html#a3cde54fe712bac297fa73949d07c1bd4" title="This function calculates the principal components of the strains through eigen values and eigen vecto...">ShapeBase::calculatePrincipalStrains3D</a>.</p>
<p>This gives the green strain in principal direction in the orientation of the element internal coordinates. One can simply grow the element in this axis, to obtain some form of plastic deformation/remodelling. Now the Green stains need to be converted to deformation gradient terms. Since \( E = 1/2 *(Fe^T*Fe-I): \) \( F_{ii} = \sqrt{e_{i} \times 2 + 1} \)</p>
<p>Then remodelling with a decay half-life ShapeBase::plasticDeformationHalfLife becomes: <br />
 \( N(t+\Delta t) = N(t) * 2 ^ (-\Delta t/\tau_{1/2}) \) where \( \tau_{1/2} = plasticDeformationHalfLifeMultiplier * plasticDeformationHalfLife/(log(2)) \). Here the multiplier term reflects perturbations.</p>
<p>The obtained remodelling increment is then checked against capping in z remodelling via <a class="el" href="classShapeBase.html#a2e7fdc8e749b8b709b6c80248dc2bc3f" title="This function checks if the remodelling of the element in z axis have reached the specified cap...">ShapeBase::checkZCappingInRemodelling</a>.</p>
<p>If there is z capping the procedure is repeated in 2D, with the strains calculated via <a class="el" href="classShapeBase.html#a6fe833f9684db5cc1847761b6bbd9aa9" title="This function calculates the principal components of the strains through eigen values and eigen vecto...">ShapeBase::calculatePrincipalStrains2D</a>.</p>
<p>If hte volume is conserved, the incremeent is sclaed to have a determinant of unity.</p>
<p>The total z remodelling up to the current time step (<a class="el" href="classShapeBase.html#a0dc566eb70e64da9fc3fa222b16999da" title="The z remodelling that have been applied to elemetn up to the current time step. This parameter is us...">ShapeBase::zRemodellingSoFar</a>) is then updated for z remodelling capping checks in following time points.</p>

</div>
</div>
<a class="anchor" id="afbbf191777e8787a0e8307d30ce0aa9d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix * ShapeBase::calculateRateOfDeformationTensor </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function will calculate rate of deformation tensor from velocity gradient tensor. </p>
<p>Inputs:</p><ol type="1">
<li>The velocity gradient tensor given in Voigt notation (6 x 1).</li>
</ol>
<p>Output:</p><ol type="1">
<li>Rate of deformation tensor (3 x 3).</li>
</ol>
<p>This function primarily rearranges the elements of the velocity gradient tensor given in Voigt notation, to from the rate of deformation tensor</p>
<p>Procedure:</p><ul>
<li>Allocate the memory for rate of deformation tensor</li>
<li>Write the terms of velocity gradient tensor into rate of deformation tensor</li>
<li>Return rate of deformation tensor</li>
</ul>

</div>
</div>
<a class="anchor" id="a9c79b3bced80eac8af18a0a81d3898ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix * ShapeBase::calculateSForNodalForcesKirshoff </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>E</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function calculates the Secons order Piola-Kirshoff stress tensor for Kirshoff material model. </p>
<p>The Second order Piola- Kirshoff Stress Tensor \( \mathbf{S} \) for Kirshoff material is: <br />
 \( \mathbf{S} = \mathbf{D}: \mathbf{E} \) where \( \mathbf{E} \) is calculated in <a class="el" href="classShapeBase.html#a347fb2687678294a252a12820842cb0d" title="This function calculates the green strains for a Kirshoff material model. ">ShapeBase::calculateEForNodalForcesKirshoff</a> and \( \mathbf{D} \) is <a class="el" href="classShapeBase.html#a1878efccfc629e53748e8907386825b0" title="elasticity tensor for Kirshoff material ">ShapeBase::D</a>.</p>

</div>
</div>
<a class="anchor" id="a697f24754441df216b4245e7eb467b13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix * ShapeBase::calculateSForNodalForcesNeoHookean </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>invC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lnJ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function calculates the Secons order Piola-Kirshoff stress tensor for Neo-Hookean material model.v. </p>
<p>The Second order Piola- Kirshoff Stress Tensor for a Neo-Hookean material is: \( \mathbf{S}^e = \mu (\mathbf {I} - \mathbf {C^{-1}}) + \lambda (ln J^e) \mathbf {C^{-1}} \)</p>

</div>
</div>
<a class="anchor" id="aef460b84dc469f89742af7c19411454f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShapeBase::calculateStiffnessPerturbationRate </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ThereIsBasolateralWithApicalRelaxationStiffnessPerturbation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stiffnessPerturbationBeginTimeInSec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stiffnessPerturbationEndTimeInSec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stiffnessChangedToFractionOfOriginal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will calciulate the stiffness perturbation rate. </p>
<p>This function will calciulate the stiffness perturbation rate.</p>
<p>the used rate will be different for apical elements and all the remaining elements. I do not need to check for ECM, as this is called for only the elements that has applied stiffness perturbations, which already excluded ECM elements.</p>
<p>If the element is apical, whatever I am applying to the basal side, I will apply the inverse to the apical side. If the baso-lateral side is doubling, apical surface will halve. Please note this will not be feasible for elements that span the whole disc. You cannot do a baso-lateral change for elements that cover the whole tissue!</p>

</div>
</div>
<a class="anchor" id="aafb0d14adc7ac116191bcff4a7837e98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix * ShapeBase::calculateVelocityGradientTensor </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>displacementPerDt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function calculates the velocity gradient tensor. </p>
<p>Inputs:</p><ol type="1">
<li>The elemental B matrix (6 , <a class="el" href="classShapeBase.html#a0ae4246d158f4d66b5bd1644df40f150" title="The number of dimensions for the positions of each of the nodes of the element. ">ShapeBase::nDim</a> x <a class="el" href="classShapeBase.html#a0daa5629b1335ca3e1be089a006fe897" title="The number of nodes of the element, it is based on ShapeBase::ShapeType. ">ShapeBase::nNodes</a>).</li>
<li>The displacement of all nodes of the system, divided by the time step (<a class="el" href="classShapeBase.html#a0ae4246d158f4d66b5bd1644df40f150" title="The number of dimensions for the positions of each of the nodes of the element. ">ShapeBase::nDim</a> x <a class="el" href="classSimulation.html#ab779ac291bc517de8a598ab72094c1a6" title="The number of nodes of the simulation. ">Simulation::nNodes</a>, 1).</li>
</ol>
<p>Output:</p><ol type="1">
<li>Velocity gradient tensor in Voigt notation (6, 1).</li>
</ol>
<p>This function calculates the velocity gradient tensor from elemental B matrix and elemental displacement. The elemental B matrix is composed of a stack of B matrices for each node of the element: </p><p class="formulaDsp">
\begin{eqnarray*} \textbf{B} &amp;=&amp; \left[ \left[ \textbf{B}_{0} \right] \left[ \textbf{B}_{1} \right] ... \left[ \textbf{B}_{nNode}\right] \right]\\ &amp;=&amp; \left[ \begin{bmatrix} \partial_x N_0 &amp; 0 &amp; 0 \\ 0 &amp; \partial_y N_0 &amp; 0 \\ 0 &amp; 0 &amp; \partial_z N_0 \\ \partial_y N_0 &amp; \partial_x N_0 &amp; 0\\ \partial_z N_0 &amp; 0 &amp; \partial_x N_0 \\ 0 &amp; \partial_z N_0 &amp; \partial_y N_0 \end{bmatrix} \begin{bmatrix} \partial_x N_1 &amp; 0 &amp; 0 \\ 0 &amp; \partial_y N_1 &amp; 0 \\ 0 &amp; 0 &amp; \partial_z N_1 \\ \partial_y N_1 &amp; \partial_x N_1 &amp; 0\\ \partial_z N_1 &amp; 0 &amp; \partial_x N_1 \\ 0 &amp; \partial_z N_1 &amp; \partial_y N_1 \end{bmatrix} ... \begin{bmatrix} \partial_x N_{nNode} &amp; 0 &amp; 0 \\ 0 &amp; \partial_y N_{nNode} &amp; 0 \\ 0 &amp; 0 &amp; \partial_z N_{nNode} \\ \partial_y N_{nNode} &amp; \partial_x N_{nNode} &amp; 0\\ \partial_z N_{nNode} &amp; 0 &amp; \partial_x N_{nNode} \\ 0 &amp; \partial_z N_{nNode} &amp; \partial_y N_{nNode} \end{bmatrix} \right] \end{eqnarray*}
</p>
<p> The elemental displacement matrix is extracted from the system displacement matrix via the function <a class="el" href="classShapeBase.html#afcdbbe37a746ade52a1af70a9aa12b9f" title="This function will assemble elemental node displacement matrix from the input displacement matrix for...">ShapeBase::constructElementalDisplacementMatrix</a>. The displacement is calculated as the displacement of a node from its position at the end of last time step, \( u_{n}\) to the position at the current Newton-Raphson iteration \( u_{k}\). With the velocities (displacement per time step), and the \(\textbf{B}\) matrix, velocity gradient tensor can be calculated through: </p><p class="formulaDsp">
\begin{eqnarray*} \boldsymbol{l} &amp; = \boldsymbol{B} \boldsymbol{v_{n+1}}\nonumber \\ &amp; = \boldsymbol{B} \frac{{u_{n+1}^{k} - u_{n}}} {\delta t}. \end{eqnarray*}
</p>
<p>Procedure:</p><ul>
<li>construct the ElementalDisplacementMatrix.</li>
<li>Allocate the velocity gradient tensor in Voigt notation.</li>
<li>calculate velocity gradient tensor.</li>
<li>free allocated memory.</li>
<li>return velocity gradient tensor.</li>
</ul>

</div>
</div>
<a class="anchor" id="a4d10225f251fa1bd8a2e6ffc8feb5326"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ShapeBase::calculateViscousForces </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>gv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>BTdetFdetdXde</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>viscousStress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function will calculate the elemental viscous forces from viscous stress. </p>
<p>Inputs:</p><ol type="1">
<li>Elemental matrix for internal viscous forces (<a class="el" href="classShapeBase.html#a0ae4246d158f4d66b5bd1644df40f150" title="The number of dimensions for the positions of each of the nodes of the element. ">ShapeBase::nDim</a> x <a class="el" href="classShapeBase.html#a0daa5629b1335ca3e1be089a006fe897" title="The number of nodes of the element, it is based on ShapeBase::ShapeType. ">ShapeBase::nNodes</a>, 1) the resulting forces will be written on this matrix</li>
<li>Transpose of elemental B matrix, multiplied by the determinant of the deformation gradient, \(\textbf{F}\), and the determinant of \( \delta \textbf{X}/\delta \boldsymbol{\xi}\)</li>
<li>The viscous stresses calculated in <a class="el" href="classShapeBase.html#a22ffae25fafb0fa584a3a4d0196af7aa" title="This function will calculate internal viscous stress of the element from rate of deformation matrix...">ShapeBase::calculateViscousStress</a></li>
</ol>
<p>This function will calculate the elemental viscous forces from viscous stress, via: </p><p class="formulaDsp">
\begin{eqnarray*} \textbf{g}^v &amp;=&amp; \int_{V} \textbf{B}^{T} \sigma^{v} dV \\ &amp;=&amp; det(\textbf{F})det\left( \frac{\delta \textbf{X} }{\delta \boldsymbol{\xi}} \right) \textbf{B}^{T} \sigma^{v} \end{eqnarray*}
</p>
<p> Procedure:</p><ul>
<li>Allocate the memory for stress in Voigt notation</li>
<li>Write stress in Voigt notation</li>
<li>Calculate nodal forces</li>
<li>Free memory</li>
</ul>

</div>
</div>
<a class="anchor" id="a22ffae25fafb0fa584a3a4d0196af7aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ShapeBase::calculateViscousStress </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>viscousStress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function will calculate internal viscous stress of the element from rate of deformation matrix. </p>
<p>Inputs:</p><ol type="1">
<li>The rate of deformation matrix (<a class="el" href="classShapeBase.html#a0ae4246d158f4d66b5bd1644df40f150" title="The number of dimensions for the positions of each of the nodes of the element. ">ShapeBase::nDim</a> x <a class="el" href="classShapeBase.html#a0ae4246d158f4d66b5bd1644df40f150" title="The number of dimensions for the positions of each of the nodes of the element. ">ShapeBase::nDim</a>).</li>
<li>the viscous stress of current Gauss point, the result will be written on this matrix</li>
</ol>
<p>This function will calculate the internal viscous stress of the element using rate of deformation matrix and <a class="el" href="classShapeBase.html#a7fd0830ee5d4e64bb68e58aa77736757" title="Current internal viscosity of the element. ">ShapeBase::internalViscosity</a>, \(\eta\) , via: </p><p class="formulaDsp">
\[\sigma^{v} = \eta \textbf{d} \]
</p>
<p>Procedure:</p><ul>
<li>Copy rate of deformation tensor over to viscous stress tensor.</li>
<li>Scale with the internal viscosity to obtain viscous stress tensor</li>
</ul>

</div>
</div>
<a class="anchor" id="a5409de18ee9e47af0bb977f4a1e608fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShapeBase::changeShapeByFsc </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates the shape change increment from shape change rates. </p>
<p>&lt; The increment of shape change that will be induced this step </p>

</div>
</div>
<a class="anchor" id="a346f4ec76554bea282a5cab7ea28dfa2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShapeBase::checkForCollapsedNodes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>TissueHeightDiscretisationLayers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>Nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classShapeBase.html">ShapeBase</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>Elements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks if any of the edges of the element is shortened to the extent that it should be collapsed. </p>
<p>If the element has any nodes that are collapsed with any other node, then the element is considered collapsed. This definition does not make any distinction betwenn elements collapsing on themselves to avoid flips, or the nodal collapse due to adhesion of two elements.</p>

</div>
</div>
<a class="anchor" id="a2e7fdc8e749b8b709b6c80248dc2bc3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ShapeBase::checkZCappingInRemodelling </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>volumeConserved</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>zRemodellingLowerThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>zRemodellingUpperThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>increment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>eigenVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks if the remodelling of the element in z axis have reached the specified cap. </p>
<p>This function checks if the remodelling of the element in z axis have reached the specified cap. First step is to figure out what the gorwth on z axis will be upon the applicatin of perturbation.</p>
<p>Once the gorwth increment in a non is non-volume conserved and non-scaled for z approach, I will have the potential new z deformation. There are limitations to how much z axis can be remodelled. I check those limits provided as inputs to the funciton and cap the z deformation if necessary.</p>

</div>
</div>
<a class="anchor" id="afcdbbe37a746ade52a1af70a9aa12b9f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix * ShapeBase::constructElementalDisplacementMatrix </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>displacement</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function will assemble elemental node displacement matrix from the input displacement matrix for the whole system. </p>
<p>Inputs:</p><ol type="1">
<li>The displacement matrix (<a class="el" href="classShapeBase.html#a0ae4246d158f4d66b5bd1644df40f150" title="The number of dimensions for the positions of each of the nodes of the element. ">ShapeBase::nDim</a> x <a class="el" href="classSimulation.html#ab779ac291bc517de8a598ab72094c1a6" title="The number of nodes of the simulation. ">Simulation::nNodes</a>, 1).</li>
</ol>
<p>This function calculates the elemental displacement matrix from the displacement matrix of the whole system, given as input. In current usage, under normal circumstances, the input matrix is displacement divided by time step. The displacement is calculated by Simulation::calculateDisplacementMatrix Both matrices, the displacement matrix of the whole system and the elemental displacement matrix are in vector form:</p>
<p>\( displacement = \begin{bmatrix} \Delta x_{0}\\ \Delta y_{0}\\ \Delta z_{0}\\ ... ,\\ \Delta x_{N}\\ \Delta y_{N}\\ \Delta z_{N} \end{bmatrix} \)</p>

</div>
</div>
<a class="anchor" id="ac5ea30d81c19c9f7c904af66310c750b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShapeBase::constructRotationMatrix </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rotAx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rotMat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper algebraic function calculates the rotation axis needed to align vector u onto v. </p>
<p>Helper algebraic functio calculates the rotation matrix from input sine, cosine of the rotation angle and the rotation axis. Writes the matrix into the input rotMat </p>

</div>
</div>
<a class="anchor" id="a91a660608ede71c5bfdd1c4956843760"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ShapeBase::disassembleRotationMatrixForZ </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>rotMat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function extracts the z rotation from a rotation matrix. </p>
<p>This function extracts the z rotation from a rotation matrix. From Extracting euler angles from a rotation matrix by Mike Day of insomniac games: <br />
 To extract a rotation of \( \mathbf{R}_{x}(\theta_{1}) \mathbf{R}_{y}(\theta_{2}) \mathbf{R}_{z}(\theta_{3})\) from a matrix M where: </p><p class="formulaDsp">
\begin{eqnarray*} \mathbf{M} = \begin{bmatrix} m_{00} &amp; m_{01} &amp; m_{02} \\ m_{10} &amp; m_{11} &amp; m_{12} \\ m_{20} &amp; m_{21} &amp; m_{22}] \end{bmatrix} \end{eqnarray*}
</p>
<p> and \( c_{1} \) denote \( cos(\theta_{1}) \) and \( s_{1} \) denote \( sin(\theta_{1}) \): </p><p class="formulaDsp">
\begin{eqnarray*} tet_1 &amp; = &amp; atan2(m_{12},m_{22}) = atan2(s_1c_2, c_1c_2) \\ c_2 &amp; = &amp; \sqrt{m_{00}*m_{00} + m_{01}*m_{01}} \\ tet_2 &amp; = &amp; atan2(-m_{02},c_2) \\ tet_3 &amp; = &amp; atan2(m_{01},m_{00}) \end{eqnarray*}
</p>

</div>
</div>
<a class="anchor" id="ab8a7323c50767ecdc82d8d8ce411b264"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShapeBase::displayName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function, display the name of the element. </p>
<p>This function will write the shape type and shape id to standard output.</p>

</div>
</div>
<a class="anchor" id="abb8aa4fb16ea7b545e6b8e13b95d6b6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix * ShapeBase::getCurrentFe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the current elastic part of the deformation gradient. </p>
<p>The current elastic deformation gradient is calculated the average at all Gauss points (<a class="el" href="classShapeBase.html#a5c80fec4188317146cb31b74c36c7640" title="The number of Gauss points used in numerical deforamtion calculation. ">ShapeBase::numberOfGaussPoints</a> with weights in <a class="el" href="classShapeBase.html#a50ec0d74748313a30a280258bd1e1827" title="The array for storing the weights of each Gauss point for element. ">ShapeBase::gaussWeights</a>), as recorded in <a class="el" href="classShapeBase.html#aae6b0d0bc99f2c07986522fd866312ea" title="The array stores the elastic part of the deformation matrix. The array stores an ShapeBase::nDim by S...">ShapeBase::FeMatrices</a> is calculated.</p>

</div>
</div>
<a class="anchor" id="a438155adad0f124efa714b349830437b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ShapeBase::getCurrentVolume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the current volume of the element. </p>
<p>The current volume of the element is calculated from the determinant of the deformation gradient and the initial volume at relaxed state. As the determinants are already recorded, this is cheaper than calculation of a compex deformed shape calculation. First the average of the determinants at all Gauss points (<a class="el" href="classShapeBase.html#a5c80fec4188317146cb31b74c36c7640" title="The number of Gauss points used in numerical deforamtion calculation. ">ShapeBase::numberOfGaussPoints</a> with weights in <a class="el" href="classShapeBase.html#a50ec0d74748313a30a280258bd1e1827" title="The array for storing the weights of each Gauss point for element. ">ShapeBase::gaussWeights</a>), as recorded in <a class="el" href="classShapeBase.html#a01d3d2738b44a003e08a6a6b96c0b91e" title="The array stores the determinant of the deformation matrix for each Gauss point. ">ShapeBase::detFs</a> is calculated. Then the reference shape volume is scaled.</p>

</div>
</div>
<a class="anchor" id="a2e91ece1ff8f6cfa8d8c495a3afc59c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShapeBase::getInitialRelativePositionInTissueInGridIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nGridX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nGridY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>IndexX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>IndexY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>FracX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>FracY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The relative positions of the iitial configuration of the element within the bounding box of the tissue. </p>
<p>This function provides the relative initial position within the bounding box of the tissue, and calculates which point on the growth maps should be read. The relative position is calculated through the function <a class="el" href="classShapeBase.html#a775b57d5074679c6fd4d3f57885e86d8" title="This function will return the initial relative position of the element in the xy bounding box of the ...">ShapeBase::getInitialRelativePosInBoundingBox</a>, and converted to grid indices through <a class="el" href="classShapeBase.html#acde567878e8335d5f3b82042bcf23e5b" title="This function will convert the relative position of the tissue in xy plane bounding box to growth map...">ShapeBase::convertRelativePosToGridIndex</a>.</p>

</div>
</div>
<a class="anchor" id="a13cf955dcc9db425c762053468578d72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShapeBase::getRelativePositionInTissueInGridIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nGridX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nGridY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>IndexX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>IndexY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>FracX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>FracY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the relative position within the bounding box of the tissue, and calculates which point on the growth maps should be read. </p>
<p>This function provides the relative position within the bounding box of the tissue, and calculates which point on the growth maps should be read. The relative position is calculated through the function <a class="el" href="classShapeBase.html#ad50e45399c54ae205ae1adabbc485ff1" title="This function will return the relative position of the element in the xy bounding box of the tissue...">ShapeBase::getRelativePosInBoundingBox</a>, and converted to grid indices through <a class="el" href="classShapeBase.html#acde567878e8335d5f3b82042bcf23e5b" title="This function will convert the relative position of the tissue in xy plane bounding box to growth map...">ShapeBase::convertRelativePosToGridIndex</a>.</p>

</div>
</div>
<a class="anchor" id="a29ee0eeca30fdd381d294b383c3baf0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShapeBase::growShapeByFg </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function updates the current growth deformaiton gradient with the growt/shape change/plastic deformation increments and their respective rotations. </p>
<p>This function updates the current growth deformaiton gradient with the growt/shape change/plastic deformation increments and their respective rotations.</p>
<p>If the growth is rotated (<a class="el" href="classShapeBase.html#aee6a2cd267d49404f5442a48c867860f" title="The boolean stating if the element has rotated from the growth axis, hence the calculated growth requ...">ShapeBase::rotatedGrowth</a>), the current growth increment in rotated with a tensor rotation: \( \mathbf{R}^{T} \mathbf{F}^{G}_{increment} \mathbf{R} \).<br />
 Where \( \mathbf{F}^{G}_{increment} \) is <a class="el" href="classShapeBase.html#af553856335d7344ea67ab10f9cc3babf" title="The matrix (3,3) representing the incremental growth in current time step. Reset to identity at the b...">ShapeBase::growthIncrement</a> and the rotation matrix is <a class="el" href="classShapeBase.html#acc1408c3e89b91787fec7e913cac1f58" title="The rotation matrix needed to correct for the rigid body rotations of the element. ">ShapeBase::GrowthStrainsRotMat</a>. A similar rotation is applied on shape change increment defined in <a class="el" href="classShapeBase.html#a2db4859942429aa4e3efc26a119a5aa3" title="The matrix (3,3) representing the incremental shape change in current time step. Reset to identity at...">ShapeBase::shapeChangeIncrement</a> and <a class="el" href="classShapeBase.html#acc1408c3e89b91787fec7e913cac1f58" title="The rotation matrix needed to correct for the rigid body rotations of the element. ">ShapeBase::GrowthStrainsRotMat</a>.</p>
<p>The plastic deformation increment is already in the correct orientation by definiton. The increments are then merged and added on the current growth deformation gradient \( F^{G} \)</p>
<p>The volumentric change induced by growth is calculated via the determinant of the growth deformation gradient. The current prefered volume is updated accordingly.</p>

</div>
</div>
<a class="anchor" id="ae9cfd1ae56e018477dd3642d4d769d90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ShapeBase::isActinStiffnessChangeAppliedToElement </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ThereIsWholeTissueStiffnessPerturbation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ThereIsApicalStiffnessPerturbation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ThereIsBasalStiffnessPerturbation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ThereIsBasolateralWithApicalRelaxationStiffnessPerturbation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ThereIsBasolateralStiffnessPerturbation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>stiffnessPerturbationEllipseBandIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numberOfStiffnessPerturbationAppliesEllipseBands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function decides if the actin stiffness perturbation is applied to this element. </p>
<p>The function regulating stiffness perturbations to tissue and ECM are distinct. Therefore first chack is tissue specific characterisation, <a class="el" href="classShapeBase.html#a5e442b31d2341cbe477d7c33195a576c" title="Boolean stating if the element is an ECM element. ">ShapeBase::isECMMimicing</a>. If the the element is not, the positional coupling between the input perturbation adn the element tissue properties are checked to see if the perturbation is applied to this element.</p>

</div>
</div>
<a class="anchor" id="a8763ab46f90adb819ec776a5829573c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ShapeBase::isElementFlippedInPotentialNewShape </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>newX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>newY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>newZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks if the element will plip in the case that its node (nodeID) is moved to the new x,y,z coordintes specified in the input. Necessary in node collapsing. </p>
<p>The current positions are taken on a temporary matrix, and the position update is carried out to the new position specified in the funciton input. Then the new elastic deformation gradient is calculated through the standard procedure. If the determinant of the deformation gradient is negative, then the element is flipped and the node position update the the new position should be avoided.</p>
<p>&lt; Removing growth </p>

</div>
</div>
<a class="anchor" id="aa0f0cc5b33f3e12d91a246cc591c346c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ShapeBase::isGrowthRateApplicable </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sourceTissue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>zmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>zmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function checks if the element if affected by the current growth functions. </p>
<p>This function checks if the current growth is appliable tothe element. The input sourceTissue defines which tissue compartment the growth is applicable to. The weight is needed for elements that are in transition zones between compartments, giving the weight of the growth that should be applide to the element, should be below 1.0 by definition. <br />
 The code first chacks if the relative z coordinate of teh elemetn is within the limits of growth application.</p>
<p>Then the tissue type is checked. If compartments match, the weight is zero, if they don't it is 0 and growth is not applied. If the element is in a transition compartment, the weight is assigned dependent on the source tissue type.</p>

</div>
</div>
<a class="anchor" id="a96dae3d137adec217bb0bc6ed2cace97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ShapeBase::readNodeIds </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpNodeIds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function sets the <a class="el" href="classNode.html#a1bd379569cc1a8b96432e61971aed4d9" title="The unique identification number of the node. ">Node::Id</a> array that constructs the shape. </p>
<p>This function will take the input of an int pointer that contains the Ids of the nodes that construct the element, and write them into the int array <a class="el" href="classShapeBase.html#af96e17fa9a23289fb743ff0722a7dc64" title="The vector storing the unique IDs (Node::Id) of nodes constructing this element. Their order is consi...">ShapeBase::NodeIds</a> of size <a class="el" href="classShapeBase.html#a0daa5629b1335ca3e1be089a006fe897" title="The number of nodes of the element, it is based on ShapeBase::ShapeType. ">ShapeBase::nNodes</a>.</p>

</div>
</div>
<a class="anchor" id="a40a3c680c1b96ae81d6bfe21a0127655"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShapeBase::relaxElasticForces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function relaxes all teh accumulated elastic forces in the system. </p>
<p>The current elastic deformation gradient coped over growth deformation gradient to relax all elastic forces.</p>

</div>
</div>
<a class="anchor" id="aace7f6727db271b84db82d0560d26b86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShapeBase::scaleGrowthForZRedistribution </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will modify the incremental growth deformation gradient of the element to reflect the volume redistribution in the height of the tissue. </p>
<p>This function will modify the incremental growth deformation gradient of the element to reflect the volume redistribution in the height of the tissue. First check point id for if there is such redistribution in simulaiton. <br />
</p>
<p>IF there is distribution, hourly xy-plane growth is calculated. z growth is not affected.</p>
<p>If the element should be loosing volume (shrunk) due to redistrtibution, the shrink rate is applied.</p>
<p>Else, the sclae is inverted for growth and applied.</p>

</div>
</div>
<a class="anchor" id="a48f114984fe31a847a9b5485d4622ca1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShapeBase::setECMMimicing </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>IsECMMimicing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This funciton sets the element as an ECM mimicking element (distinct domain in terms of physical characteristics). </p>
<p>While setting the element to ECM mimicking, the Poisson's ratio is also set to zero. The physical definition of the ECM material requires so.</p>

</div>
</div>
<a class="anchor" id="a8dafd8524fe5aa5326173aa49a8f78a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ShapeBase::setIdentificationColour </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function sets the unique <a class="el" href="classShapeBase.html#a8c6daae25e30af2e55599b7d1ecfbddb" title="The unique identifier colour of the element, this is used for &quot;picking&quot; in the visual interface...">ShapeBase::IdentifierColour</a> colour for the element, which is used in element picking from the user interface. </p>
<p>The function sets the unique <a class="el" href="classShapeBase.html#a8c6daae25e30af2e55599b7d1ecfbddb" title="The unique identifier colour of the element, this is used for &quot;picking&quot; in the visual interface...">ShapeBase::IdentifierColour</a>, which on click, will allow the user interface to identify this element as the selected element. <a class="el" href="classShapeBase.html#a8c6daae25e30af2e55599b7d1ecfbddb" title="The unique identifier colour of the element, this is used for &quot;picking&quot; in the visual interface...">ShapeBase::IdentifierColour</a> is an integer array of size 3, and corresponds to rgb channels, in 0-255 range. Therefore, the selection tool works for 255^3 = 16581375 elements. The colour storing is started from b channel moving towards r, and done with element Id</p>

</div>
</div>
<a class="anchor" id="a474774dd9db4c42990de569b3d8cd52e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ShapeBase::setPositionMatrix </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>Nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function sets the <a class="el" href="classShapeBase.html#a6a6bd8c65e2a0bfea3a956604bc05cb9" title="The vector storing the positions of the nodes constructing the element. ">ShapeBase::Positions</a> matrix to define the locations of each constructing node. </p>
<p>This function will take the address of a Nodes pointers vector (It should be the <a class="el" href="classSimulation.html#aa6913c3f238cbf5455955b42bd617f72" title="The vector storing the unique pointers ot the nodes of the simulation. ">Simulation::Nodes</a> vector) It will go through the <a class="el" href="classShapeBase.html#af96e17fa9a23289fb743ff0722a7dc64" title="The vector storing the unique IDs (Node::Id) of nodes constructing this element. Their order is consi...">ShapeBase::NodeIds</a> in a nested loop of <a class="el" href="classShapeBase.html#a0daa5629b1335ca3e1be089a006fe897" title="The number of nodes of the element, it is based on ShapeBase::ShapeType. ">ShapeBase::nNodes</a> and <a class="el" href="classShapeBase.html#a0ae4246d158f4d66b5bd1644df40f150" title="The number of dimensions for the positions of each of the nodes of the element. ">ShapeBase::nDim</a>, read the positions of the corresponding node from the input vector storing the pointers to all the nodes, and write the position information into the <a class="el" href="classShapeBase.html#a6a6bd8c65e2a0bfea3a956604bc05cb9" title="The vector storing the positions of the nodes constructing the element. ">ShapeBase::Positions</a> array. This is a double storing of the same information, yet is practical for elasticity calculations.</p>

</div>
</div>
<a class="anchor" id="aa260269fe9605765f5adb494d1a99737"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ShapeBase::setReferencePositionMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function sets the RefereneceShapeBase::Positions matrix to define the reference positions of the element. </p>
<p>This function will allocate the position array of the ReferenceShape (ReferenceShape::Positions) Then the reference will be equated to the current position of the element. It is essential this function is called at simulation initiation, and after any subsequent modifications made to the reference structure of the tissue. But it should not be called in cases where the current shape of the element has progressed to differ from its reference (such as after loading steps of a save file). In saves, the reference shapes are set at the initiation of the system, and the positions of saves steps are loaded afterwards.</p>

</div>
</div>
<a class="anchor" id="a4cc6c721ed24f27baa71fe9398edd87a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ShapeBase::setShapeType </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>TypeName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function sets the type of the shape. </p>
<p>The function will set the shape type of the element, stored in variable <a class="el" href="classShapeBase.html#a36aedd41e8465a186a0b0c454b5b76f3" title="The integer defining the type of the shape, Prisms shape type = 1;. ">ShapeBase::ShapeType</a>. The mapping is as follows:</p><ul>
<li>1 : <a class="el" href="classPrism.html">Prism</a></li>
<li>2 : PrismLateral</li>
<li>3 : Tetrahedron</li>
<li>4 : Triangle</li>
<li>(-100): Default number if input name is not recognised.</li>
</ul>

</div>
</div>
<a class="anchor" id="a3777927e49e4b09bfb524b4f4ac889ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ShapeBase::setTissuePlacement </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>Nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function sets the placement of the element within the tissue. </p>
<p>This function will take the address of a Nodes pointers vector (It should be the <a class="el" href="classSimulation.html#aa6913c3f238cbf5455955b42bd617f72" title="The vector storing the unique pointers ot the nodes of the simulation. ">Simulation::Nodes</a> vector) Checking the nodes that construct the element, the function will decide the placement of the element within the tissue. The placement of the element within the tissue is defined by the <a class="el" href="classShapeBase.html#aff63b1fcb823bbfdb5b19fe78dea59b8" title="1 -> apical, 0 -> basal, 2->middle, 3 -> lateral ">ShapeBase::tissuePlacement</a> integer such that:</p><ul>
<li>Apical: <a class="el" href="classShapeBase.html#aff63b1fcb823bbfdb5b19fe78dea59b8" title="1 -> apical, 0 -> basal, 2->middle, 3 -> lateral ">ShapeBase::tissuePlacement</a> = 1</li>
<li>Basal: <a class="el" href="classShapeBase.html#aff63b1fcb823bbfdb5b19fe78dea59b8" title="1 -> apical, 0 -> basal, 2->middle, 3 -> lateral ">ShapeBase::tissuePlacement</a> = 0</li>
<li>Mid-line or spans the whole tissue: <a class="el" href="classShapeBase.html#aff63b1fcb823bbfdb5b19fe78dea59b8" title="1 -> apical, 0 -> basal, 2->middle, 3 -> lateral ">ShapeBase::tissuePlacement</a> = 2</li>
<li>Lateral: <a class="el" href="classShapeBase.html#aff63b1fcb823bbfdb5b19fe78dea59b8" title="1 -> apical, 0 -> basal, 2->middle, 3 -> lateral ">ShapeBase::tissuePlacement</a> = 3</li>
</ul>
<p>The function will first decide which type of nodes the element is composed of.</p>
<p>Lateral elements can be composed of any combination of lateral, mid-line, apical and basal nodes. Any element that contains at least one lateral node, must be a lateral element.</p>
<p>Elements that does not contain any lateral nodes, but apical nodes must be apical. The only exception to this when the whole tissue is spanned by a single layer of elements. Then the element will have apical and basal nodes, and it will be defined as a mid-line node, with <a class="el" href="classShapeBase.html#adafe85bbee6173d2a321408cd8b63db3" title="Boolean staing is the element spans the whole tissue. This is used to identify mid-layer tagged tissu...">ShapeBase::spansWholeTissue</a> set to true.</p>
<p>Elements that does not contain any lateral or apical nodes, but does contain basal nodes then must be basal.</p>
<p>If the element does not contain any lateral, apical or basal nodes, it must be that the element is composed wholly of mid-line nodes. Then, the element lies in the mid-layer of tissue.</p>

</div>
</div>
<a class="anchor" id="ad5f0b9431be849133a4eab5484fbb1f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ShapeBase::setTissueType </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>Nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function sets the tissue type of the element. </p>
<p>The tissue can be of columnar epithelum type, peripodial type, or be connecting the two. Depending on the owner nodes of the element, if the element has any linker type nodes, it will be a linker node. If there are no linker elements, but there are peripodial elements, then assign peripodial, as some peripodial elements can contain columnar nodes wehen the mesh does not have linkers. Only when all hte nodes are of columnar type, the element is columnar.</p>

</div>
</div>
<a class="anchor" id="ac4e051a82edb9b987edfbd783076e348"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShapeBase::setViscosity </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>viscosityApical</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>viscosityBasal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>viscosityMid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the viscosity of the element depending on its placement in the tissue. </p>
<p>Start by setting the viscosity to the mid layer value. If the element has a specific node placement (<a class="el" href="classShapeBase.html#aff63b1fcb823bbfdb5b19fe78dea59b8" title="1 -> apical, 0 -> basal, 2->middle, 3 -> lateral ">ShapeBase::tissuePlacement</a> is apical or basal) then alter accordingly.</p>

</div>
</div>
<a class="anchor" id="a8b6ffc8d699795e4efb867efd065a679"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShapeBase::setViscosity </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>viscosityApical</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>viscosityBasal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the viscosity of the element depending on its placement in the tissue. </p>
<p>Start by setting the viscosity to the mid layer value to the average of apical and basal values. If the element has a specific node placement (<a class="el" href="classShapeBase.html#aff63b1fcb823bbfdb5b19fe78dea59b8" title="1 -> apical, 0 -> basal, 2->middle, 3 -> lateral ">ShapeBase::tissuePlacement</a> is apical or basal) then alter accordingly.</p>

</div>
</div>
<a class="anchor" id="a466480b1e7de98250dd22c8cdb092d54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShapeBase::updateGrowthByMutation </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will update the growth growth deformaton gradient increment of the element due to a mutation. </p>
<p>Mutation can be defined in a scaled growth increase, stored in <a class="el" href="classShapeBase.html#ac7b83cb76a8f4ec11a4a6292c2899ba2" title="The rate of fold change in growth rate set by a mutant clone covering this element. ">ShapeBase::mutationGrowthFold</a>, or a direct overwriting of hte growth, with <a class="el" href="classShapeBase.html#a35ee77fed372f7702889bebb67875136" title="The growth rate set by a mutant clone covering this element. ">ShapeBase::mutationGrowthRatePerSec</a>. If the growth fold in non-zero, growth in xy plane is scaled accordingly, and set in the rates <a class="el" href="classShapeBase.html#ac06c53088788e3c1461233623f506dbb" title="This function sets the growth of the element from the tome step and the input rates. ">ShapeBase::setGrowthRate</a>. If the growth is set directly, then the increment is updated directly to the given value. Then the incremnt is updated via <a class="el" href="classShapeBase.html#ad7d7957431a1ae402347efb03ad94d0e" title="This function fills th egrowht increment matirx from the current growth rate matrix. ">ShapeBase::updateGrowthIncrementFromRate</a>.</p>

</div>
</div>
<a class="anchor" id="a009b5aed1c546db5e517f9f33f67b066"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ShapeBase::updateGrowthIncrement </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>columnar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>peripodial</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will update the elemental growth deformation gradient from the current growth deformation gradient increment. </p>
<p>This function will update the elemental growth deformation gradient from the current growth deformation gradient increment. The inputs to the function provides growht for two dostonct tissue types, and the growth is distributed according to the <a class="el" href="classShapeBase.html#a1d56f7eb3fed744adc268bc4da7a790f" title="The tissue type is 000 for columnar layer, 1 for peripodial membrane, and 2 for linker zone...">ShapeBase::tissueType</a>.</p>

</div>
</div>
<a class="anchor" id="a606ddc7f909062e9faae9f4a311ccd8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ShapeBase::updateLagrangianElasticityTensorNeoHookean </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>invC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lnJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pointNo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function calcualtes the Lagrangian elasticity tensor for Neo-Hookean material model. </p>
<p>The voigt notation of the transformed elasticity tensor \( \mathcal D \) is calculated via \( \mathcal{D}_{ijkl} = \lambda \boldsymbol{C}^{-1}_{ij} \boldsymbol{C}^{-1}_{kl} + 2 \left( \mu - \lambda ln(J)\right) \mathcal{I}_{ijkl} \) <br />
where \( \lambda \) Lame's first parameter and \( \mu \) is the shear modulus. Each value at index ijkl is calculated for each Gauss Point and the information is stored in an array of D[gauss points] [system dimension (3D)] [system dimension (3D)] [system dimension (3D)] [system dimension (3D)].</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/melda/Documents/nonAcademic/TissueFoldingFefractor/TissueFoldingRefractor/TissueFoldingLinux/TissueFolding/SourceCode/<a class="el" href="ShapeBase_8h_source.html">ShapeBase.h</a></li>
<li>/home/melda/Documents/nonAcademic/TissueFoldingFefractor/TissueFoldingRefractor/TissueFoldingLinux/TissueFolding/SourceCode/ShapeBase.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classShapeBase.html">ShapeBase</a></li>
    <li class="footer">Generated on Wed May 29 2019 16:14:30 for Tissue Origami by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
