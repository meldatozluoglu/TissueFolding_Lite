<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Tissue Origami: Simulation Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tissue Origami
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classSimulation.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classSimulation-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Simulation Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for Simulation:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classSimulation.png" usemap="#Simulation_map" alt=""/>
  <map id="Simulation_map" name="Simulation_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5b224cc5b36bcc8eb29689aff223de41"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b224cc5b36bcc8eb29689aff223de41"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a5b224cc5b36bcc8eb29689aff223de41">Simulation</a> ()</td></tr>
<tr class="memdesc:a5b224cc5b36bcc8eb29689aff223de41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a5b224cc5b36bcc8eb29689aff223de41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80fad3f57dfaf195a36f7bc49bc88279"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80fad3f57dfaf195a36f7bc49bc88279"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a80fad3f57dfaf195a36f7bc49bc88279">~Simulation</a> ()</td></tr>
<tr class="memdesc:a80fad3f57dfaf195a36f7bc49bc88279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a80fad3f57dfaf195a36f7bc49bc88279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed75e3d044166072754e6e323f3604c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ed75e3d044166072754e6e323f3604c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a7ed75e3d044166072754e6e323f3604c">assignTips</a> ()</td></tr>
<tr class="memdesc:a7ed75e3d044166072754e6e323f3604c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function assigns the nodes marking the tips of the tissue in xy plane. <br /></td></tr>
<tr class="separator:a7ed75e3d044166072754e6e323f3604c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c031b9d4c6b3d74f636adec0b695ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#aa5c031b9d4c6b3d74f636adec0b695ed">readExecutableInputs</a> (int argc, char **argv)</td></tr>
<tr class="memdesc:aa5c031b9d4c6b3d74f636adec0b695ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads the input executables from user input.  <a href="#aa5c031b9d4c6b3d74f636adec0b695ed">More...</a><br /></td></tr>
<tr class="separator:aa5c031b9d4c6b3d74f636adec0b695ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44910ca27d6ec5eaa48f7136fad87ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ae44910ca27d6ec5eaa48f7136fad87ea">initiateSystem</a> ()</td></tr>
<tr class="memdesc:ae44910ca27d6ec5eaa48f7136fad87ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initiates the system with model inputs.  <a href="#ae44910ca27d6ec5eaa48f7136fad87ea">More...</a><br /></td></tr>
<tr class="separator:ae44910ca27d6ec5eaa48f7136fad87ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef90fd76ed4f6bb9d063e7e72e9a983"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a6ef90fd76ed4f6bb9d063e7e72e9a983">initiateSavedSystem</a> ()</td></tr>
<tr class="memdesc:a6ef90fd76ed4f6bb9d063e7e72e9a983"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initiates a saved system from save files.  <a href="#a6ef90fd76ed4f6bb9d063e7e72e9a983">More...</a><br /></td></tr>
<tr class="separator:a6ef90fd76ed4f6bb9d063e7e72e9a983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9bf054812136067d30e79345f877de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f9bf054812136067d30e79345f877de"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a1f9bf054812136067d30e79345f877de">calculateSystemCentre</a> ()</td></tr>
<tr class="memdesc:a1f9bf054812136067d30e79345f877de"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the tissue geometric centre. <br /></td></tr>
<tr class="separator:a1f9bf054812136067d30e79345f877de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0989e1c64b0fde348701454e9fbf67"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c0989e1c64b0fde348701454e9fbf67"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a5c0989e1c64b0fde348701454e9fbf67">resetForces</a> (bool resetPacking)</td></tr>
<tr class="memdesc:a5c0989e1c64b0fde348701454e9fbf67"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function resets all forces to zero at the beginning of each iteration. Depending on the packing calculation type (implicit/explicit) the boolean states if teh packing forces should be reset or not. <br /></td></tr>
<tr class="separator:a5c0989e1c64b0fde348701454e9fbf67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6ec9457aa61d2493747d0110a50ca5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e6ec9457aa61d2493747d0110a50ca5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a8e6ec9457aa61d2493747d0110a50ca5">calculateApicalSize</a> ()</td></tr>
<tr class="memdesc:a8e6ec9457aa61d2493747d0110a50ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the xy-plane bounding box of the apical side of the tissue. <br /></td></tr>
<tr class="separator:a8e6ec9457aa61d2493747d0110a50ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4950a649e48408ad5756acd9c2718665"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4950a649e48408ad5756acd9c2718665"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a4950a649e48408ad5756acd9c2718665">calculateBoundingBox</a> ()</td></tr>
<tr class="memdesc:a4950a649e48408ad5756acd9c2718665"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the 3D bounding box of the tissue. <br /></td></tr>
<tr class="separator:a4950a649e48408ad5756acd9c2718665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21c5c157e6f487f879bdd7043288982"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af21c5c157e6f487f879bdd7043288982"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#af21c5c157e6f487f879bdd7043288982">calculateZProjectedAreas</a> ()</td></tr>
<tr class="memdesc:af21c5c157e6f487f879bdd7043288982"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the z-projected areas of all elemetns and nodes. <br /></td></tr>
<tr class="separator:af21c5c157e6f487f879bdd7043288982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a47dfca0623a5636cb65416411cb901"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a7a47dfca0623a5636cb65416411cb901">correctzProjectedAreaForMidNodes</a> ()</td></tr>
<tr class="memdesc:a7a47dfca0623a5636cb65416411cb901"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function corrects the z-projected areas for mid-l;ayer nodes, as their areas are counted twice, by both elements.  <a href="#a7a47dfca0623a5636cb65416411cb901">More...</a><br /></td></tr>
<tr class="separator:a7a47dfca0623a5636cb65416411cb901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3f5acaa8ec130dedc94dfd6f7b013a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c3f5acaa8ec130dedc94dfd6f7b013a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a9c3f5acaa8ec130dedc94dfd6f7b013a">clearProjectedAreas</a> ()</td></tr>
<tr class="memdesc:a9c3f5acaa8ec130dedc94dfd6f7b013a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function clears the z-projected areas of all elemetns and nodes. <br /></td></tr>
<tr class="separator:a9c3f5acaa8ec130dedc94dfd6f7b013a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ad0627365ad5d465b273183c7db344"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9ad0627365ad5d465b273183c7db344"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#aa9ad0627365ad5d465b273183c7db344">checkForExperimentalSetupsBeforeIteration</a> ()</td></tr>
<tr class="memdesc:aa9ad0627365ad5d465b273183c7db344"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro function checks for all experimental setup updates at the beginning of a time step, prior to iterations. <br /></td></tr>
<tr class="separator:aa9ad0627365ad5d465b273183c7db344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebd37d36e25d118738d25811da4aa45"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ebd37d36e25d118738d25811da4aa45"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a2ebd37d36e25d118738d25811da4aa45">checkForExperimentalSetupsWithinIteration</a> ()</td></tr>
<tr class="memdesc:a2ebd37d36e25d118738d25811da4aa45"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro function checks for all experimental setup updates at each N-R iteration. <br /></td></tr>
<tr class="separator:a2ebd37d36e25d118738d25811da4aa45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b5dcc56bb2633d284a413f1e9dc1e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8b5dcc56bb2633d284a413f1e9dc1e9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ae8b5dcc56bb2633d284a413f1e9dc1e9">checkForExperimentalSetupsAfterIteration</a> ()</td></tr>
<tr class="memdesc:ae8b5dcc56bb2633d284a413f1e9dc1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro function checks for all experimental setup updates at the end of iterations, post convergence. <br /></td></tr>
<tr class="separator:ae8b5dcc56bb2633d284a413f1e9dc1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ebb11d5727f0a6fc3ebfe8166b7290"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a49ebb11d5727f0a6fc3ebfe8166b7290">checkForEmergentEllipseFormation</a> ()</td></tr>
<tr class="memdesc:a49ebb11d5727f0a6fc3ebfe8166b7290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for emergent marker elipse bands with fold initiation in the tissue.  <a href="#a49ebb11d5727f0a6fc3ebfe8166b7290">More...</a><br /></td></tr>
<tr class="separator:a49ebb11d5727f0a6fc3ebfe8166b7290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7aa0ded1d2cd262ed08c8abddde4f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#aba7aa0ded1d2cd262ed08c8abddde4f8">checkForEllipseIdUpdateWithECMDegradation</a> ()</td></tr>
<tr class="memdesc:aba7aa0ded1d2cd262ed08c8abddde4f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for emergence of ellipse bands as a result of ECM loss.  <a href="#aba7aa0ded1d2cd262ed08c8abddde4f8">More...</a><br /></td></tr>
<tr class="separator:aba7aa0ded1d2cd262ed08c8abddde4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf2aca93cb0f8716817936d98b6bf0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a1cf2aca93cb0f8716817936d98b6bf0e">checkEllipseAllocationWithCurvingNodes</a> ()</td></tr>
<tr class="memdesc:a1cf2aca93cb0f8716817936d98b6bf0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the ellipse band allocation of nodes residing on fold initiation.  <a href="#a1cf2aca93cb0f8716817936d98b6bf0e">More...</a><br /></td></tr>
<tr class="separator:a1cf2aca93cb0f8716817936d98b6bf0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7040a8ecc377bd2e53c785fc4c488b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a0e7040a8ecc377bd2e53c785fc4c488b">updateEllipseWithCollapse</a> ()</td></tr>
<tr class="memdesc:a0e7040a8ecc377bd2e53c785fc4c488b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update marker ellipses with collapsing nodes.  <a href="#a0e7040a8ecc377bd2e53c785fc4c488b">More...</a><br /></td></tr>
<tr class="separator:a0e7040a8ecc377bd2e53c785fc4c488b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065f2150d785ee160762367bd6419e42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a065f2150d785ee160762367bd6419e42">checkForLeftOutElementsInEllipseAssignment</a> ()</td></tr>
<tr class="memdesc:a065f2150d785ee160762367bd6419e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if elements at border of two emergent folds are missed in marking, and correct as needed.  <a href="#a065f2150d785ee160762367bd6419e42">More...</a><br /></td></tr>
<tr class="separator:a065f2150d785ee160762367bd6419e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae096c8a7fcc6e921415d1be317526d02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ae096c8a7fcc6e921415d1be317526d02">checkECMChange</a> ()</td></tr>
<tr class="memdesc:ae096c8a7fcc6e921415d1be317526d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if there is ECM perturbation.  <a href="#ae096c8a7fcc6e921415d1be317526d02">More...</a><br /></td></tr>
<tr class="separator:ae096c8a7fcc6e921415d1be317526d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d9108d648996ef65a3eff0977a8590"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#af0d9108d648996ef65a3eff0977a8590">updateChangeForExplicitECM</a> (int idOfCurrentECMPerturbation)</td></tr>
<tr class="memdesc:af0d9108d648996ef65a3eff0977a8590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update physical properties of the ECM with the ECM perturbaiton function of input ID.  <a href="#af0d9108d648996ef65a3eff0977a8590">More...</a><br /></td></tr>
<tr class="separator:af0d9108d648996ef65a3eff0977a8590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2308c071a7f6260910d76d4a8604a0a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a2308c071a7f6260910d76d4a8604a0a3">updateECMRenewalHalflifeMultiplier</a> (int idOfCurrentECMPerturbation)</td></tr>
<tr class="memdesc:a2308c071a7f6260910d76d4a8604a0a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update ECM renewal half-life with the ECM perturbaiton function of input ID.  <a href="#a2308c071a7f6260910d76d4a8604a0a3">More...</a><br /></td></tr>
<tr class="separator:a2308c071a7f6260910d76d4a8604a0a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac28dca8cca35baed5b75ce4f8062c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a6ac28dca8cca35baed5b75ce4f8062c8">updateChangeForViscosityBasedECMDefinition</a> (int idOfCurrentECMPerturbation)</td></tr>
<tr class="memdesc:a6ac28dca8cca35baed5b75ce4f8062c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update ECM viscosity with the ECM perturbaiton function of input ID.  <a href="#a6ac28dca8cca35baed5b75ce4f8062c8">More...</a><br /></td></tr>
<tr class="separator:a6ac28dca8cca35baed5b75ce4f8062c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405e565b21064979e0010286927d087a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a405e565b21064979e0010286927d087a">calculateChangeRatesForECM</a> (int idOfCurrentECMPerturbation)</td></tr>
<tr class="memdesc:a405e565b21064979e0010286927d087a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the physical property change rates for ECM perturbation with the ECM perturbaiton function of input ID.  <a href="#a405e565b21064979e0010286927d087a">More...</a><br /></td></tr>
<tr class="separator:a405e565b21064979e0010286927d087a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361530c38e215fd901d5e8a0ef051386"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a361530c38e215fd901d5e8a0ef051386">checkStiffnessPerturbation</a> ()</td></tr>
<tr class="memdesc:a361530c38e215fd901d5e8a0ef051386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for stiffness perturbation on the tissue.  <a href="#a361530c38e215fd901d5e8a0ef051386">More...</a><br /></td></tr>
<tr class="separator:a361530c38e215fd901d5e8a0ef051386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacaebdb527784f46f67232f3180936e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#aacaebdb527784f46f67232f3180936e1">updateStiffnessChangeForActin</a> (int idOfCurrentStiffnessPerturbation)</td></tr>
<tr class="memdesc:aacaebdb527784f46f67232f3180936e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update stiffness of actin with the stiffness perturbaiton function of input ID.  <a href="#aacaebdb527784f46f67232f3180936e1">More...</a><br /></td></tr>
<tr class="separator:aacaebdb527784f46f67232f3180936e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b40b6f71c115d9c566333151219a7d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a8b40b6f71c115d9c566333151219a7d6">calculateStiffnessChangeRatesForActin</a> (int idOfCurrentStiffnessPerturbation)</td></tr>
<tr class="memdesc:a8b40b6f71c115d9c566333151219a7d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the stiffness change rates for actin with the stiffness perturbaiton function of input ID.  <a href="#a8b40b6f71c115d9c566333151219a7d6">More...</a><br /></td></tr>
<tr class="separator:a8b40b6f71c115d9c566333151219a7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7642cf5d56f38710da9b219e56b3c77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ae7642cf5d56f38710da9b219e56b3c77">updateOnFoldNodesFromCollapse</a> ()</td></tr>
<tr class="memdesc:ae7642cf5d56f38710da9b219e56b3c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark nodes as on fold, due to collapsed elements.  <a href="#ae7642cf5d56f38710da9b219e56b3c77">More...</a><br /></td></tr>
<tr class="separator:ae7642cf5d56f38710da9b219e56b3c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a12ff087efbc813a949e347da7a0438"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a5a12ff087efbc813a949e347da7a0438">assignFoldRegionAndReleasePeripodial</a> (<a class="el" href="classNode.html">Node</a> *NodeMAster, <a class="el" href="classNode.html">Node</a> *NodeSlave)</td></tr>
<tr class="memdesc:a5a12ff087efbc813a949e347da7a0438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nodes are assigned to be on folding regions if they lie in between two adhered nodes.  <a href="#a5a12ff087efbc813a949e347da7a0438">More...</a><br /></td></tr>
<tr class="separator:a5a12ff087efbc813a949e347da7a0438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee92b20e497b42f5b7a089c3f9409e97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#aee92b20e497b42f5b7a089c3f9409e97">artificialRelax</a> ()</td></tr>
<tr class="memdesc:aee92b20e497b42f5b7a089c3f9409e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Artificially relax all deformation on all elements at selected time point.  <a href="#aee92b20e497b42f5b7a089c3f9409e97">More...</a><br /></td></tr>
<tr class="separator:aee92b20e497b42f5b7a089c3f9409e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300713fd91c15b51421606bffd6d87b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a300713fd91c15b51421606bffd6d87b7">runOneStep</a> ()</td></tr>
<tr class="memdesc:a300713fd91c15b51421606bffd6d87b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the simulation for one time step.  <a href="#a300713fd91c15b51421606bffd6d87b7">More...</a><br /></td></tr>
<tr class="separator:a300713fd91c15b51421606bffd6d87b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5dbbde572af555225089e247296e2e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f5dbbde572af555225089e247296e2e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a1f5dbbde572af555225089e247296e2e">updateOneStepFromSave</a> ()</td></tr>
<tr class="memdesc:a1f5dbbde572af555225089e247296e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the simulation for time step from saved files. <br /></td></tr>
<tr class="separator:a1f5dbbde572af555225089e247296e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba920b0ae2806ea3890cbe2b819977fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#aba920b0ae2806ea3890cbe2b819977fe">updatePlasticDeformation</a> ()</td></tr>
<tr class="memdesc:aba920b0ae2806ea3890cbe2b819977fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the plastic deformation (remodelling) of all nodes.  <a href="#aba920b0ae2806ea3890cbe2b819977fe">More...</a><br /></td></tr>
<tr class="separator:aba920b0ae2806ea3890cbe2b819977fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a869cb433953d1d36249460b0a74545"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a6a869cb433953d1d36249460b0a74545">updateStepNR</a> ()</td></tr>
<tr class="memdesc:a6a869cb433953d1d36249460b0a74545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the positions with solving for the displacements with the N-R iterations.  <a href="#a6a869cb433953d1d36249460b0a74545">More...</a><br /></td></tr>
<tr class="separator:a6a869cb433953d1d36249460b0a74545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6fc494b468ebd56c07625d3e5984ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed6fc494b468ebd56c07625d3e5984ff"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#aed6fc494b468ebd56c07625d3e5984ff">updateElementPositionsinNR</a> (gsl_matrix *uk)</td></tr>
<tr class="memdesc:aed6fc494b468ebd56c07625d3e5984ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update elemental positions during one iteration of the NR numerical solving for the displacements. <br /></td></tr>
<tr class="separator:aed6fc494b468ebd56c07625d3e5984ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea943e8e0caf1b9ff8e40b61248024b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#aea943e8e0caf1b9ff8e40b61248024b6">updateNodePositionsNR</a> (gsl_matrix *uk)</td></tr>
<tr class="memdesc:aea943e8e0caf1b9ff8e40b61248024b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update nodal positions during one iteration of the NR numerical solving for the displacements.  <a href="#aea943e8e0caf1b9ff8e40b61248024b6">More...</a><br /></td></tr>
<tr class="separator:aea943e8e0caf1b9ff8e40b61248024b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16977eb346093b2fe00f94e9c485b37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae16977eb346093b2fe00f94e9c485b37"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ae16977eb346093b2fe00f94e9c485b37">calculateRandomForces</a> ()</td></tr>
<tr class="memdesc:ae16977eb346093b2fe00f94e9c485b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the random forces on elements. <br /></td></tr>
<tr class="separator:ae16977eb346093b2fe00f94e9c485b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14662c0f9cee95a76c523130e8e688d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad14662c0f9cee95a76c523130e8e688d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ad14662c0f9cee95a76c523130e8e688d">addRandomForces</a> (gsl_matrix *gExt)</td></tr>
<tr class="memdesc:ad14662c0f9cee95a76c523130e8e688d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add random forces to system forces. <br /></td></tr>
<tr class="separator:ad14662c0f9cee95a76c523130e8e688d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67230d22a5c07292574d10d5ee8fc13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ab67230d22a5c07292574d10d5ee8fc13">detectPacingNodes</a> ()</td></tr>
<tr class="memdesc:ab67230d22a5c07292574d10d5ee8fc13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect nodes potentially packing to each other.  <a href="#ab67230d22a5c07292574d10d5ee8fc13">More...</a><br /></td></tr>
<tr class="separator:ab67230d22a5c07292574d10d5ee8fc13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e76f4fe61889b9c0ae18436a7fd2fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a77e76f4fe61889b9c0ae18436a7fd2fb">calculatePackingForcesImplicit3D</a> ()</td></tr>
<tr class="memdesc:a77e76f4fe61889b9c0ae18436a7fd2fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate packing forces on nodes due to packing to each other.  <a href="#a77e76f4fe61889b9c0ae18436a7fd2fb">More...</a><br /></td></tr>
<tr class="separator:a77e76f4fe61889b9c0ae18436a7fd2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d76a2495e1b863ab0cdb7185821bec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a07d76a2495e1b863ab0cdb7185821bec">calculatePackingJacobian3D</a> (gsl_matrix *K)</td></tr>
<tr class="memdesc:a07d76a2495e1b863ab0cdb7185821bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the system jaconbian with the derivatives of forces due to packing to each other, with respect to positions.  <a href="#a07d76a2495e1b863ab0cdb7185821bec">More...</a><br /></td></tr>
<tr class="separator:a07d76a2495e1b863ab0cdb7185821bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97927bd45513fc16d7dd56b9e8474f4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a97927bd45513fc16d7dd56b9e8474f4a">detectPackingToPipette</a> ()</td></tr>
<tr class="memdesc:a97927bd45513fc16d7dd56b9e8474f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect nodes potentially packing to the pipette wall in pipette aspiration experiment.  <a href="#a97927bd45513fc16d7dd56b9e8474f4a">More...</a><br /></td></tr>
<tr class="separator:a97927bd45513fc16d7dd56b9e8474f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18305ef63492bb7e76f79c4c85206d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#af18305ef63492bb7e76f79c4c85206d0">calculatePackingToPipetteForcesImplicit3D</a> ()</td></tr>
<tr class="memdesc:af18305ef63492bb7e76f79c4c85206d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate packing forces on nodes due to packing to pipette wall in pipette aspiration experiment.  <a href="#af18305ef63492bb7e76f79c4c85206d0">More...</a><br /></td></tr>
<tr class="separator:af18305ef63492bb7e76f79c4c85206d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebe76bd38ce67afd3611ad521450c1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#aeebe76bd38ce67afd3611ad521450c1f">calculatePackingToPipetteJacobian3D</a> (gsl_matrix *K)</td></tr>
<tr class="memdesc:aeebe76bd38ce67afd3611ad521450c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the system jaconbian with the derivatives of forces due to packing to the pipette wall in pipette aspiration experiment, with respect to positions.  <a href="#aeebe76bd38ce67afd3611ad521450c1f">More...</a><br /></td></tr>
<tr class="separator:aeebe76bd38ce67afd3611ad521450c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1225a76f3acef7e6ecc175d386b6b86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ac1225a76f3acef7e6ecc175d386b6b86">detectPacingToEnclosingSurfacesNodes</a> ()</td></tr>
<tr class="memdesc:ac1225a76f3acef7e6ecc175d386b6b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect nodes potentially packing to the enclosing surfaces in z.  <a href="#ac1225a76f3acef7e6ecc175d386b6b86">More...</a><br /></td></tr>
<tr class="separator:ac1225a76f3acef7e6ecc175d386b6b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2d417e1f2814ffd8e34c186508c2f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a3b2d417e1f2814ffd8e34c186508c2f2">calculatePackingForcesToEnclosingSurfacesImplicit3D</a> ()</td></tr>
<tr class="memdesc:a3b2d417e1f2814ffd8e34c186508c2f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate packing forces on nodes due to packing to enclosing surfaces.  <a href="#a3b2d417e1f2814ffd8e34c186508c2f2">More...</a><br /></td></tr>
<tr class="separator:a3b2d417e1f2814ffd8e34c186508c2f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b259e3827b74767c8005b2126191609"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a4b259e3827b74767c8005b2126191609">calculatePackingToEnclosingSurfacesJacobian3D</a> (gsl_matrix *K)</td></tr>
<tr class="memdesc:a4b259e3827b74767c8005b2126191609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the system jaconbian with the derivatives of forces due to packing to enclosing surfaces, with respect to positions.  <a href="#a4b259e3827b74767c8005b2126191609">More...</a><br /></td></tr>
<tr class="separator:a4b259e3827b74767c8005b2126191609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a62be5131e130aa7f631201d5a4a49a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a7a62be5131e130aa7f631201d5a4a49a">addPackingForces</a> (gsl_matrix *gExt)</td></tr>
<tr class="memdesc:a7a62be5131e130aa7f631201d5a4a49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add al packing forces to external foces vector.  <a href="#a7a62be5131e130aa7f631201d5a4a49a">More...</a><br /></td></tr>
<tr class="separator:a7a62be5131e130aa7f631201d5a4a49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac096cfe7f8b3b7b66f6af2a87ff6556f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac096cfe7f8b3b7b66f6af2a87ff6556f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ac096cfe7f8b3b7b66f6af2a87ff6556f">addValueToMatrix</a> (gsl_matrix *K, int i, int j, double value)</td></tr>
<tr class="memdesc:ac096cfe7f8b3b7b66f6af2a87ff6556f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function, adds value to matrix K, in indices (i,j). <br /></td></tr>
<tr class="separator:ac096cfe7f8b3b7b66f6af2a87ff6556f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92f90b98dc049a3206b4906ebf52585"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa92f90b98dc049a3206b4906ebf52585"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#aa92f90b98dc049a3206b4906ebf52585">updateElementPositions</a> ()</td></tr>
<tr class="memdesc:aa92f90b98dc049a3206b4906ebf52585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update element positions, from the nodal positions. <br /></td></tr>
<tr class="separator:aa92f90b98dc049a3206b4906ebf52585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59684286f79843524da38d1bb30718a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59684286f79843524da38d1bb30718a6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a59684286f79843524da38d1bb30718a6">updateMasterSlaveNodesInBinding</a> ()</td></tr>
<tr class="memdesc:a59684286f79843524da38d1bb30718a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update node degrees of freedom binding information stored in N-R solver to the saved data. <br /></td></tr>
<tr class="separator:a59684286f79843524da38d1bb30718a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cfdafedfcaedb329c377046009bf7ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cfdafedfcaedb329c377046009bf7ec"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a4cfdafedfcaedb329c377046009bf7ec">updateElementPositionsSingle</a> (size_t i)</td></tr>
<tr class="memdesc:a4cfdafedfcaedb329c377046009bf7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the position of element at index i, in the <a class="el" href="classSimulation.html#a96e0aaea7b40dbb5bc11329fc7d34559" title="The vector storing the unique pointers ot the elements of the simulation. ">Simulation::Elements</a> vector. <br /></td></tr>
<tr class="separator:a4cfdafedfcaedb329c377046009bf7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a12f6ac1b230cecbe004221326a7ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a91a12f6ac1b230cecbe004221326a7ca">alignTissueDVToXPositive</a> ()</td></tr>
<tr class="memdesc:a91a12f6ac1b230cecbe004221326a7ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Align tissue DV axis to x axis, the DV axis is defiend by Simulation::ventralTipIndex and Simulation::dorsalTipIndex, as assigned in <a class="el" href="classSimulation.html#a7ed75e3d044166072754e6e323f3604c" title="This function assigns the nodes marking the tips of the tissue in xy plane. ">Simulation::assignTips</a>.  <a href="#a91a12f6ac1b230cecbe004221326a7ca">More...</a><br /></td></tr>
<tr class="separator:a91a12f6ac1b230cecbe004221326a7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa2db4c2819e37c0ded181d47467233"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7aa2db4c2819e37c0ded181d47467233"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a7aa2db4c2819e37c0ded181d47467233">checkFlip</a> ()</td></tr>
<tr class="memdesc:a7aa2db4c2819e37c0ded181d47467233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if any of the elements have flipped, and report error accordingly. <br /></td></tr>
<tr class="separator:a7aa2db4c2819e37c0ded181d47467233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1776f97a899b0e77e20df658713cb3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada1776f97a899b0e77e20df658713cb3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ada1776f97a899b0e77e20df658713cb3">wrapUpAtTheEndOfSimulation</a> ()</td></tr>
<tr class="memdesc:ada1776f97a899b0e77e20df658713cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Correct tissue alignement once more before simulation is finalised to have the correct final mesh. <br /></td></tr>
<tr class="separator:ada1776f97a899b0e77e20df658713cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cdf77d01390a32cabb8ba7535a9f7dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2cdf77d01390a32cabb8ba7535a9f7dd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a2cdf77d01390a32cabb8ba7535a9f7dd">calculateDVDistance</a> ()</td></tr>
<tr class="memdesc:a2cdf77d01390a32cabb8ba7535a9f7dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calclate the long (DV) axis tip to tip distance (not contour length), the DV axis is defiend by Simulation::ventralTipIndex and Simulation::dorsalTipIndex, as assigned in <a class="el" href="classSimulation.html#a7ed75e3d044166072754e6e323f3604c" title="This function assigns the nodes marking the tips of the tissue in xy plane. ">Simulation::assignTips</a>. <br /></td></tr>
<tr class="separator:a2cdf77d01390a32cabb8ba7535a9f7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4897adef943963c8f79f45fcc52e409a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4897adef943963c8f79f45fcc52e409a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a4897adef943963c8f79f45fcc52e409a">fixNode0InPosition</a> (double x, double y, double z)</td></tr>
<tr class="memdesc:a4897adef943963c8f79f45fcc52e409a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fix the node 0 in 3D space, in case of zero external viscosity on all axes, checked in Simulation::checkForZeroExternalViscosity. <br /></td></tr>
<tr class="separator:a4897adef943963c8f79f45fcc52e409a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a473866f52cbbb0f5186f4b2a4ac451ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a473866f52cbbb0f5186f4b2a4ac451ee"></a>
std::ofstream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a473866f52cbbb0f5186f4b2a4ac451ee">outputFile</a></td></tr>
<tr class="memdesc:a473866f52cbbb0f5186f4b2a4ac451ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">The output file to direct eroors and wornings, progress summary such as last converged time step. <br /></td></tr>
<tr class="separator:a473866f52cbbb0f5186f4b2a4ac451ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219f980877f9cf37de32556b5bce836a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a219f980877f9cf37de32556b5bce836a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a219f980877f9cf37de32556b5bce836a">displayIsOn</a></td></tr>
<tr class="memdesc:a219f980877f9cf37de32556b5bce836a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The simulation is displayed. <br /></td></tr>
<tr class="separator:a219f980877f9cf37de32556b5bce836a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d07267bab8e631658e2ef056ee5750"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4d07267bab8e631658e2ef056ee5750"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ab4d07267bab8e631658e2ef056ee5750">DisplaySave</a></td></tr>
<tr class="memdesc:ab4d07267bab8e631658e2ef056ee5750"><td class="mdescLeft">&#160;</td><td class="mdescRight">The package is displaying a saved simulation from. <br /></td></tr>
<tr class="separator:ab4d07267bab8e631658e2ef056ee5750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b66ca81fcc16dab7f44632ddff7ecd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99b66ca81fcc16dab7f44632ddff7ecd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a99b66ca81fcc16dab7f44632ddff7ecd">reachedEndOfSaveFile</a></td></tr>
<tr class="memdesc:a99b66ca81fcc16dab7f44632ddff7ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The simulation has reached the end of the read of save file. <br /></td></tr>
<tr class="separator:a99b66ca81fcc16dab7f44632ddff7ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee381efb3458d02bf78487cbb4dc42a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ee381efb3458d02bf78487cbb4dc42a"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a0ee381efb3458d02bf78487cbb4dc42a">dt</a></td></tr>
<tr class="memdesc:a0ee381efb3458d02bf78487cbb4dc42a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The time step increment in seconds, such that <a class="el" href="classSimulation.html#a0a8d61383b2f51f2f98b72554b7e00cb" title="The current time of the simulation in time seconds, obtained as Simulation::currSimTimeSec = Simulati...">Simulation::currSimTimeSec</a> = <a class="el" href="classSimulation.html#a0ee381efb3458d02bf78487cbb4dc42a" title="The time step increment in seconds, such that Simulation::currSimTimeSec = Simulation::dt * Simulatio...">Simulation::dt</a> * <a class="el" href="classSimulation.html#a2056af9924aff237c804ffe006adc00b" title="The time step count, such that Simulation::currSimTimeSec = Simulation::dt * Simulation::timestep. ">Simulation::timestep</a>. <br /></td></tr>
<tr class="separator:a0ee381efb3458d02bf78487cbb4dc42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2056af9924aff237c804ffe006adc00b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2056af9924aff237c804ffe006adc00b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a2056af9924aff237c804ffe006adc00b">timestep</a></td></tr>
<tr class="memdesc:a2056af9924aff237c804ffe006adc00b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The time step count, such that <a class="el" href="classSimulation.html#a0a8d61383b2f51f2f98b72554b7e00cb" title="The current time of the simulation in time seconds, obtained as Simulation::currSimTimeSec = Simulati...">Simulation::currSimTimeSec</a> = <a class="el" href="classSimulation.html#a0ee381efb3458d02bf78487cbb4dc42a" title="The time step increment in seconds, such that Simulation::currSimTimeSec = Simulation::dt * Simulatio...">Simulation::dt</a> * <a class="el" href="classSimulation.html#a2056af9924aff237c804ffe006adc00b" title="The time step count, such that Simulation::currSimTimeSec = Simulation::dt * Simulation::timestep. ">Simulation::timestep</a>. <br /></td></tr>
<tr class="separator:a2056af9924aff237c804ffe006adc00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8d61383b2f51f2f98b72554b7e00cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a8d61383b2f51f2f98b72554b7e00cb"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a0a8d61383b2f51f2f98b72554b7e00cb">currSimTimeSec</a></td></tr>
<tr class="memdesc:a0a8d61383b2f51f2f98b72554b7e00cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current time of the simulation in time seconds, obtained as <a class="el" href="classSimulation.html#a0a8d61383b2f51f2f98b72554b7e00cb" title="The current time of the simulation in time seconds, obtained as Simulation::currSimTimeSec = Simulati...">Simulation::currSimTimeSec</a> = <a class="el" href="classSimulation.html#a0ee381efb3458d02bf78487cbb4dc42a" title="The time step increment in seconds, such that Simulation::currSimTimeSec = Simulation::dt * Simulatio...">Simulation::dt</a> * <a class="el" href="classSimulation.html#a2056af9924aff237c804ffe006adc00b" title="The time step count, such that Simulation::currSimTimeSec = Simulation::dt * Simulation::timestep. ">Simulation::timestep</a>. <br /></td></tr>
<tr class="separator:a0a8d61383b2f51f2f98b72554b7e00cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96bf105b28395184053bb4f987f05746"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96bf105b28395184053bb4f987f05746"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a96bf105b28395184053bb4f987f05746">SimLength</a></td></tr>
<tr class="memdesc:a96bf105b28395184053bb4f987f05746"><td class="mdescLeft">&#160;</td><td class="mdescRight">The desiered length of the current simulation in seconds. <br /></td></tr>
<tr class="separator:a96bf105b28395184053bb4f987f05746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4287e16564745895acac3550e11e82"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e4287e16564745895acac3550e11e82"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a9e4287e16564745895acac3550e11e82">saveDirectory</a></td></tr>
<tr class="memdesc:a9e4287e16564745895acac3550e11e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">The full path to the directory where the results of the simulation are saved. <br /></td></tr>
<tr class="separator:a9e4287e16564745895acac3550e11e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29eff6bb523b42f0c5e9db833a094444"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29eff6bb523b42f0c5e9db833a094444"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a29eff6bb523b42f0c5e9db833a094444">saveScreenshotsDirectory</a></td></tr>
<tr class="memdesc:a29eff6bb523b42f0c5e9db833a094444"><td class="mdescLeft">&#160;</td><td class="mdescRight">The full path to the directory where the screenshots of the simulation are saved. <br /></td></tr>
<tr class="separator:a29eff6bb523b42f0c5e9db833a094444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b086632fb67338d29f2ddc69c9087be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b086632fb67338d29f2ddc69c9087be"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a3b086632fb67338d29f2ddc69c9087be">saveDirectoryToDisplayString</a></td></tr>
<tr class="memdesc:a3b086632fb67338d29f2ddc69c9087be"><td class="mdescLeft">&#160;</td><td class="mdescRight">The full path to the directory from which the saved simulation is being read. <br /></td></tr>
<tr class="separator:a3b086632fb67338d29f2ddc69c9087be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419351054778337026abd0bc0787019d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a419351054778337026abd0bc0787019d"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a419351054778337026abd0bc0787019d">inputMeshFileName</a></td></tr>
<tr class="memdesc:a419351054778337026abd0bc0787019d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The path to the input mesh file. <br /></td></tr>
<tr class="separator:a419351054778337026abd0bc0787019d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab911b1546aecf4b891f670f11ebccf19"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab911b1546aecf4b891f670f11ebccf19"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ab911b1546aecf4b891f670f11ebccf19">outputFileString</a></td></tr>
<tr class="memdesc:ab911b1546aecf4b891f670f11ebccf19"><td class="mdescLeft">&#160;</td><td class="mdescRight">The full path to the output file (<a class="el" href="classSimulation.html#a473866f52cbbb0f5186f4b2a4ac451ee" title="The output file to direct eroors and wornings, progress summary such as last converged time step...">Simulation::outputFile</a>) directory. <br /></td></tr>
<tr class="separator:ab911b1546aecf4b891f670f11ebccf19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8b3f2ba1e2d02eec79d83cbd6b4d16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb8b3f2ba1e2d02eec79d83cbd6b4d16"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#afb8b3f2ba1e2d02eec79d83cbd6b4d16">saveImages</a></td></tr>
<tr class="memdesc:afb8b3f2ba1e2d02eec79d83cbd6b4d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if the screenshot images should be saved. <br /></td></tr>
<tr class="separator:afb8b3f2ba1e2d02eec79d83cbd6b4d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d0d5e335aeaefff71fee46ee73d0cba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d0d5e335aeaefff71fee46ee73d0cba"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a7d0d5e335aeaefff71fee46ee73d0cba">saveData</a></td></tr>
<tr class="memdesc:a7d0d5e335aeaefff71fee46ee73d0cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if the simulation data should be saved. <br /></td></tr>
<tr class="separator:a7d0d5e335aeaefff71fee46ee73d0cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8ebf021a21da302f6aabb24a9c5d87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc8ebf021a21da302f6aabb24a9c5d87"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#acc8ebf021a21da302f6aabb24a9c5d87">imageSaveInterval</a></td></tr>
<tr class="memdesc:acc8ebf021a21da302f6aabb24a9c5d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">The interval to save screenshot images, in time step counts. <br /></td></tr>
<tr class="separator:acc8ebf021a21da302f6aabb24a9c5d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3a518b104d571d442f9752c7e3cf92"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa3a518b104d571d442f9752c7e3cf92"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#afa3a518b104d571d442f9752c7e3cf92">dataSaveInterval</a></td></tr>
<tr class="memdesc:afa3a518b104d571d442f9752c7e3cf92"><td class="mdescLeft">&#160;</td><td class="mdescRight">The interval to save simalation data, in time step counts. <br /></td></tr>
<tr class="separator:afa3a518b104d571d442f9752c7e3cf92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624c8f135227f36c3749fb12b89f6937"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a624c8f135227f36c3749fb12b89f6937"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a624c8f135227f36c3749fb12b89f6937">EApical</a></td></tr>
<tr class="memdesc:a624c8f135227f36c3749fb12b89f6937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Young's modulus of the apical section of tissue. <br /></td></tr>
<tr class="separator:a624c8f135227f36c3749fb12b89f6937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36c6cc857bb7cdb84ccf9c17ef5bcba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac36c6cc857bb7cdb84ccf9c17ef5bcba"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ac36c6cc857bb7cdb84ccf9c17ef5bcba">EBasal</a></td></tr>
<tr class="memdesc:ac36c6cc857bb7cdb84ccf9c17ef5bcba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Young's modulus of the basal section of tissue. <br /></td></tr>
<tr class="separator:ac36c6cc857bb7cdb84ccf9c17ef5bcba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7241e19c4db7e819dad00bf210e8ca46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7241e19c4db7e819dad00bf210e8ca46"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a7241e19c4db7e819dad00bf210e8ca46">EMid</a></td></tr>
<tr class="memdesc:a7241e19c4db7e819dad00bf210e8ca46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Young's modulus of the mid-line of the tissue. <br /></td></tr>
<tr class="separator:a7241e19c4db7e819dad00bf210e8ca46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82219fd675e3f94e3de603f01af32dd9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82219fd675e3f94e3de603f01af32dd9"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a82219fd675e3f94e3de603f01af32dd9">EColumnarECM</a></td></tr>
<tr class="memdesc:a82219fd675e3f94e3de603f01af32dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Young's modulus of the columnar extracellular matrix (ECM) <br /></td></tr>
<tr class="separator:a82219fd675e3f94e3de603f01af32dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66bc1ebb86876dd826aee17cd78764f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66bc1ebb86876dd826aee17cd78764f2"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a66bc1ebb86876dd826aee17cd78764f2">EPeripodialECM</a></td></tr>
<tr class="memdesc:a66bc1ebb86876dd826aee17cd78764f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Young's modulus of the peripodial extracellular matrix (ECM) <br /></td></tr>
<tr class="separator:a66bc1ebb86876dd826aee17cd78764f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49bdb9254f7b7f5a6e33352c43881422"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49bdb9254f7b7f5a6e33352c43881422"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a49bdb9254f7b7f5a6e33352c43881422">poisson</a></td></tr>
<tr class="memdesc:a49bdb9254f7b7f5a6e33352c43881422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poisson ratio of the tissue. <br /></td></tr>
<tr class="separator:a49bdb9254f7b7f5a6e33352c43881422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db999f14bd36d808d133eb9ae702f9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6db999f14bd36d808d133eb9ae702f9a"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a6db999f14bd36d808d133eb9ae702f9a">discProperApicalViscosity</a></td></tr>
<tr class="memdesc:a6db999f14bd36d808d133eb9ae702f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The apical internal viscosity of the columnar layer. <br /></td></tr>
<tr class="separator:a6db999f14bd36d808d133eb9ae702f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3332b7870109dcfcf57bdd36566844e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3332b7870109dcfcf57bdd36566844e9"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a3332b7870109dcfcf57bdd36566844e9">discProperBasalViscosity</a></td></tr>
<tr class="memdesc:a3332b7870109dcfcf57bdd36566844e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The basal internal viscosity of the columnar layer. <br /></td></tr>
<tr class="separator:a3332b7870109dcfcf57bdd36566844e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5940ac39f46fd4f07d6cde8bb403fb80"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5940ac39f46fd4f07d6cde8bb403fb80"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a5940ac39f46fd4f07d6cde8bb403fb80">discProperMidlineViscosity</a></td></tr>
<tr class="memdesc:a5940ac39f46fd4f07d6cde8bb403fb80"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mid-line internal viscosity of the columnar layer. <br /></td></tr>
<tr class="separator:a5940ac39f46fd4f07d6cde8bb403fb80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762d730b0722e46ac8cec52816477249"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a762d730b0722e46ac8cec52816477249"></a>
std::array&lt; int, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a762d730b0722e46ac8cec52816477249">noiseOnPysProp</a></td></tr>
<tr class="memdesc:a762d730b0722e46ac8cec52816477249"><td class="mdescLeft">&#160;</td><td class="mdescRight">The desired noise percentage on the physical properties [<a class="el" href="classSimulation.html#a624c8f135227f36c3749fb12b89f6937" title="Young&#39;s modulus of the apical section of tissue. ">Simulation::EApical</a>] [<a class="el" href="classSimulation.html#ac36c6cc857bb7cdb84ccf9c17ef5bcba" title="Young&#39;s modulus of the basal section of tissue. ">Simulation::EBasal</a>][Simulation::EMidLine][<a class="el" href="classSimulation.html#a49bdb9254f7b7f5a6e33352c43881422" title="Poisson ratio of the tissue. ">Simulation::poisson</a>]. <br /></td></tr>
<tr class="separator:a762d730b0722e46ac8cec52816477249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865d265405d3d496d3755735ff72484b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a865d265405d3d496d3755735ff72484b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a865d265405d3d496d3755735ff72484b">zeroExternalViscosity</a> [3]</td></tr>
<tr class="memdesc:a865d265405d3d496d3755735ff72484b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean stating if there is zero external viscosity on any of the 3 dimensions. <br /></td></tr>
<tr class="separator:a865d265405d3d496d3755735ff72484b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850dff7ea7bb0fe75dd0e2cac62d9eba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a850dff7ea7bb0fe75dd0e2cac62d9eba"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a850dff7ea7bb0fe75dd0e2cac62d9eba">extendExternalViscosityToInnerTissue</a></td></tr>
<tr class="memdesc:a850dff7ea7bb0fe75dd0e2cac62d9eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean stating if the external viscosity will be extended to the inner layers. <br /></td></tr>
<tr class="separator:a850dff7ea7bb0fe75dd0e2cac62d9eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0960e3fb2edb70918f75e27826d3bad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0960e3fb2edb70918f75e27826d3bad"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ae0960e3fb2edb70918f75e27826d3bad">externalViscosityDPApical</a></td></tr>
<tr class="memdesc:ae0960e3fb2edb70918f75e27826d3bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">The apical external viscosity of the columnar layer. <br /></td></tr>
<tr class="separator:ae0960e3fb2edb70918f75e27826d3bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb640995a5288502bd0ba3ea6a6c893"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2cb640995a5288502bd0ba3ea6a6c893"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a2cb640995a5288502bd0ba3ea6a6c893">externalViscosityDPBasal</a></td></tr>
<tr class="memdesc:a2cb640995a5288502bd0ba3ea6a6c893"><td class="mdescLeft">&#160;</td><td class="mdescRight">The basal external viscosity of the columnar layer. <br /></td></tr>
<tr class="separator:a2cb640995a5288502bd0ba3ea6a6c893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa794b85325ceb5339a21c3166cc40313"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa794b85325ceb5339a21c3166cc40313"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#aa794b85325ceb5339a21c3166cc40313">externalViscosityPMApical</a></td></tr>
<tr class="memdesc:aa794b85325ceb5339a21c3166cc40313"><td class="mdescLeft">&#160;</td><td class="mdescRight">The apical external viscosity of the peripodial layer. <br /></td></tr>
<tr class="separator:aa794b85325ceb5339a21c3166cc40313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd300d98cfaa633b13e2d091aa17398"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acdd300d98cfaa633b13e2d091aa17398"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#acdd300d98cfaa633b13e2d091aa17398">externalViscosityPMBasal</a></td></tr>
<tr class="memdesc:acdd300d98cfaa633b13e2d091aa17398"><td class="mdescLeft">&#160;</td><td class="mdescRight">The basal external viscosity of the peripodial layer. <br /></td></tr>
<tr class="separator:acdd300d98cfaa633b13e2d091aa17398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7008c3c2a7451471a70bdffb4e97054e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7008c3c2a7451471a70bdffb4e97054e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a7008c3c2a7451471a70bdffb4e97054e">externalViscosityLZApical</a></td></tr>
<tr class="memdesc:a7008c3c2a7451471a70bdffb4e97054e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The apical external viscosity of the linker zone between columnar and peripodial layer. <br /></td></tr>
<tr class="separator:a7008c3c2a7451471a70bdffb4e97054e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc411f696e2333c6501bd20fe0e4ab9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bc411f696e2333c6501bd20fe0e4ab9"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a8bc411f696e2333c6501bd20fe0e4ab9">externalViscosityLZBasal</a></td></tr>
<tr class="memdesc:a8bc411f696e2333c6501bd20fe0e4ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The basal external viscosity of the linker zone between columnar and peripodial layer. <br /></td></tr>
<tr class="separator:a8bc411f696e2333c6501bd20fe0e4ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc59b7f2368423781a41b0a457af1e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3dc59b7f2368423781a41b0a457af1e4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a3dc59b7f2368423781a41b0a457af1e4">MeshType</a></td></tr>
<tr class="memdesc:a3dc59b7f2368423781a41b0a457af1e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mesh type of the tissue; 2: a hexagonal mesh is generated with <a class="el" href="classSimulation.html#a7e232e744b0c21c7d878dc454e74b898" title="The number of rows of elemetns for initiating a hexagonal mesh for Simulation::MeshType = 2...">Simulation::Row</a> and <a class="el" href="classSimulation.html#ad700818601343ea02758de553eaab8e3" title="The number of columns of elemetns for initiating a hexagonal mesh for Simulation::MeshType = 2...">Simulation::Column</a> number of elemetns; 4: an input file is specified. <br /></td></tr>
<tr class="separator:a3dc59b7f2368423781a41b0a457af1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e232e744b0c21c7d878dc454e74b898"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e232e744b0c21c7d878dc454e74b898"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a7e232e744b0c21c7d878dc454e74b898">Row</a></td></tr>
<tr class="memdesc:a7e232e744b0c21c7d878dc454e74b898"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of rows of elemetns for initiating a hexagonal mesh for <a class="el" href="classSimulation.html#a3dc59b7f2368423781a41b0a457af1e4" title="The mesh type of the tissue; 2: a hexagonal mesh is generated with Simulation::Row and Simulation::Co...">Simulation::MeshType</a> = 2. <br /></td></tr>
<tr class="separator:a7e232e744b0c21c7d878dc454e74b898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad700818601343ea02758de553eaab8e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad700818601343ea02758de553eaab8e3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ad700818601343ea02758de553eaab8e3">Column</a></td></tr>
<tr class="memdesc:ad700818601343ea02758de553eaab8e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of columns of elemetns for initiating a hexagonal mesh for <a class="el" href="classSimulation.html#a3dc59b7f2368423781a41b0a457af1e4" title="The mesh type of the tissue; 2: a hexagonal mesh is generated with Simulation::Row and Simulation::Co...">Simulation::MeshType</a> = 2. <br /></td></tr>
<tr class="separator:ad700818601343ea02758de553eaab8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f79cab9b0ff8dc3802e1bf1f903d1c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f79cab9b0ff8dc3802e1bf1f903d1c7"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a8f79cab9b0ff8dc3802e1bf1f903d1c7">SideLength</a></td></tr>
<tr class="memdesc:a8f79cab9b0ff8dc3802e1bf1f903d1c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The side length of an element for initiating a hexagonal mesh for <a class="el" href="classSimulation.html#a3dc59b7f2368423781a41b0a457af1e4" title="The mesh type of the tissue; 2: a hexagonal mesh is generated with Simulation::Row and Simulation::Co...">Simulation::MeshType</a> = 2. <br /></td></tr>
<tr class="separator:a8f79cab9b0ff8dc3802e1bf1f903d1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27aa62c2297902e2e77159fe05362467"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27aa62c2297902e2e77159fe05362467"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a27aa62c2297902e2e77159fe05362467">zHeight</a></td></tr>
<tr class="memdesc:a27aa62c2297902e2e77159fe05362467"><td class="mdescLeft">&#160;</td><td class="mdescRight">The z height of an element for initiating a hexagonal mesh for <a class="el" href="classSimulation.html#a3dc59b7f2368423781a41b0a457af1e4" title="The mesh type of the tissue; 2: a hexagonal mesh is generated with Simulation::Row and Simulation::Co...">Simulation::MeshType</a> = 2. <br /></td></tr>
<tr class="separator:a27aa62c2297902e2e77159fe05362467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27563e2e991aadaf7ff9629c90197459"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27563e2e991aadaf7ff9629c90197459"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a27563e2e991aadaf7ff9629c90197459">ApicalNodeFixWithExternalViscosity</a></td></tr>
<tr class="memdesc:a27563e2e991aadaf7ff9629c90197459"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean stating if the apical nodes should be fixed with external viscosity;. <br /></td></tr>
<tr class="separator:a27563e2e991aadaf7ff9629c90197459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1898c90a360862484cb379c213640fbc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1898c90a360862484cb379c213640fbc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a1898c90a360862484cb379c213640fbc">BasalNodeFixWithExternalViscosity</a></td></tr>
<tr class="memdesc:a1898c90a360862484cb379c213640fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean stating if the basal nodes should be fixed with external viscosity;. <br /></td></tr>
<tr class="separator:a1898c90a360862484cb379c213640fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797bef0a4c6e90daf92f51550ee0619e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a797bef0a4c6e90daf92f51550ee0619e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a797bef0a4c6e90daf92f51550ee0619e">CircumferentialNodeFixWithHighExternalViscosity</a> [5]</td></tr>
<tr class="memdesc:a797bef0a4c6e90daf92f51550ee0619e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean array stating if the circumferential nodes should be fixed with external viscosity ([apical][basal][linker apcial][linker basal] [all]) <br /></td></tr>
<tr class="separator:a797bef0a4c6e90daf92f51550ee0619e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcdc046caaaf16a43ee646c79902eae1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcdc046caaaf16a43ee646c79902eae1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#afcdc046caaaf16a43ee646c79902eae1">NotumNodeFixWithExternalViscosity</a></td></tr>
<tr class="memdesc:afcdc046caaaf16a43ee646c79902eae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean stating if the notum nodes should be fixed with external viscosity;. <br /></td></tr>
<tr class="separator:afcdc046caaaf16a43ee646c79902eae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00c2a04cdaf04f28dbe95f1ca6fd934"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac00c2a04cdaf04f28dbe95f1ca6fd934"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ac00c2a04cdaf04f28dbe95f1ca6fd934">fixingExternalViscosity</a> [3]</td></tr>
<tr class="memdesc:ac00c2a04cdaf04f28dbe95f1ca6fd934"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array of viscosity values to fix nodes by external viscosity [x][y][z]. <br /></td></tr>
<tr class="separator:ac00c2a04cdaf04f28dbe95f1ca6fd934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b767055f674bf25b1b000c60683447"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34b767055f674bf25b1b000c60683447"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a34b767055f674bf25b1b000c60683447">ApicalNodeFix</a> [3]</td></tr>
<tr class="memdesc:a34b767055f674bf25b1b000c60683447"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean array stating if the apical nodes are fixed, rigid or via viscosity [x][y]<a href="accompanying boolean array to specify the fixing method Simulation#ApicalNodeFixWithExternalViscosity">z</a> <br /></td></tr>
<tr class="separator:a34b767055f674bf25b1b000c60683447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d716c8688103f42b89242d962c9ab1b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d716c8688103f42b89242d962c9ab1b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a1d716c8688103f42b89242d962c9ab1b">BasalNodeFix</a> [3]</td></tr>
<tr class="memdesc:a1d716c8688103f42b89242d962c9ab1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean array stating if the basal nodes are fixed, rigid or via viscosity [x][y]<a href="accompanying boolean array to specify the fixing method Simulation#BasalNodeFixWithExternalViscosity">z</a> <br /></td></tr>
<tr class="separator:a1d716c8688103f42b89242d962c9ab1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6222749d0ee7055efb52974eacbfa074"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6222749d0ee7055efb52974eacbfa074"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a6222749d0ee7055efb52974eacbfa074">NotumNodeFix</a> [3]</td></tr>
<tr class="memdesc:a6222749d0ee7055efb52974eacbfa074"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean array stating if the notum nodes are fixed, rigid or via viscosity [x][y]<a href="accompanying boolean array to specify the fixing method Simulation#CircumferentialNodeFixWithHighExternalViscosity">z</a> <br /></td></tr>
<tr class="separator:a6222749d0ee7055efb52974eacbfa074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995a48098144f291dfa47773c150ed84"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a995a48098144f291dfa47773c150ed84"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a995a48098144f291dfa47773c150ed84">notumFixingRange</a> [2]</td></tr>
<tr class="memdesc:a995a48098144f291dfa47773c150ed84"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boundaries of the notum zone in relative x [minX][maxX]. <br /></td></tr>
<tr class="separator:a995a48098144f291dfa47773c150ed84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42120f650198d83e054144ab71e2fee2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42120f650198d83e054144ab71e2fee2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a42120f650198d83e054144ab71e2fee2">CircumferentialNodeFix</a> [5][3]</td></tr>
<tr class="memdesc:a42120f650198d83e054144ab71e2fee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean array stating if the circumference should be fixed, rigid or via viscosity: <br />
row 0: apical circumferece x,y,z ; row 1: basal circumference x,y,z; row 2: linker apical circumference x,y,z, row 3: linker basal circumference x,y,z, row 4: all circumference x,y,z. <br /></td></tr>
<tr class="separator:a42120f650198d83e054144ab71e2fee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8435d5bedf3810cb12138538169d9c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d8435d5bedf3810cb12138538169d9c"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a3d8435d5bedf3810cb12138538169d9c">PeripodialElasticity</a></td></tr>
<tr class="memdesc:a3d8435d5bedf3810cb12138538169d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Young's modulus of the peropodial tissue. <br /></td></tr>
<tr class="separator:a3d8435d5bedf3810cb12138538169d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d12531ec1daffb9e389ac59b4f43299"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d12531ec1daffb9e389ac59b4f43299"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a9d12531ec1daffb9e389ac59b4f43299">peripodialApicalViscosity</a></td></tr>
<tr class="memdesc:a9d12531ec1daffb9e389ac59b4f43299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apical viscosity of the peripodial tissue. <br /></td></tr>
<tr class="separator:a9d12531ec1daffb9e389ac59b4f43299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37b9f5ae1a1711bf6905ea1525fb1f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa37b9f5ae1a1711bf6905ea1525fb1f4"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#aa37b9f5ae1a1711bf6905ea1525fb1f4">peripodialBasalViscosity</a></td></tr>
<tr class="memdesc:aa37b9f5ae1a1711bf6905ea1525fb1f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basal viscosity of the peripodial tissue. <br /></td></tr>
<tr class="separator:aa37b9f5ae1a1711bf6905ea1525fb1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b5bdeb108bfc8816cd90eddbe49067"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92b5bdeb108bfc8816cd90eddbe49067"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a92b5bdeb108bfc8816cd90eddbe49067">peripodialMidlineViscosity</a></td></tr>
<tr class="memdesc:a92b5bdeb108bfc8816cd90eddbe49067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mid-line viscosity of the peripodial tissue. <br /></td></tr>
<tr class="separator:a92b5bdeb108bfc8816cd90eddbe49067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6f3faf5d16e41aa43c9a71fb67d1b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c6f3faf5d16e41aa43c9a71fb67d1b8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a7c6f3faf5d16e41aa43c9a71fb67d1b8">BaseLinkerZoneParametersOnPeripodialness</a></td></tr>
<tr class="memdesc:a7c6f3faf5d16e41aa43c9a71fb67d1b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean stating if the physical properties should be calculated based on the tisseu type weights for linker zones (<a class="el" href="classShapeBase.html#a134d82ba500ef829b6aa3e3a83783c9a" title="The fraction defining how close to the columnar layer the element is. 1.0 for columnar layer...">ShapeBase::columnarGrowthWeight</a>) <br /></td></tr>
<tr class="separator:a7c6f3faf5d16e41aa43c9a71fb67d1b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5d205910274dd5be4976b87ab20abc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa5d205910274dd5be4976b87ab20abc"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#aaa5d205910274dd5be4976b87ab20abc">LinkerZoneApicalElasticity</a></td></tr>
<tr class="memdesc:aaa5d205910274dd5be4976b87ab20abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Young's modulus of the apical section of linker tissue between columnar and peripodial. <br /></td></tr>
<tr class="separator:aaa5d205910274dd5be4976b87ab20abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07cf19fd8a3e78d4644563b3c9c030ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07cf19fd8a3e78d4644563b3c9c030ee"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a07cf19fd8a3e78d4644563b3c9c030ee">LinkerZoneBasalYoungsModulus</a></td></tr>
<tr class="memdesc:a07cf19fd8a3e78d4644563b3c9c030ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Young's modulus of the basal section of linker tissue between columnar and peripodial. <br /></td></tr>
<tr class="separator:a07cf19fd8a3e78d4644563b3c9c030ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f11d2644c957402cd0e6e1b4c652182"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f11d2644c957402cd0e6e1b4c652182"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a8f11d2644c957402cd0e6e1b4c652182">linkerZoneApicalViscosity</a></td></tr>
<tr class="memdesc:a8f11d2644c957402cd0e6e1b4c652182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal viscosity of the apical section of linker tissue between columnar and peripodial. <br /></td></tr>
<tr class="separator:a8f11d2644c957402cd0e6e1b4c652182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b9b2275582a0d94b6ac6709b0f73eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7b9b2275582a0d94b6ac6709b0f73eb"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#af7b9b2275582a0d94b6ac6709b0f73eb">linkerZoneBasalViscosity</a></td></tr>
<tr class="memdesc:af7b9b2275582a0d94b6ac6709b0f73eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal viscosity of the basal section of linker tissue between columnar and peripodial. <br /></td></tr>
<tr class="separator:af7b9b2275582a0d94b6ac6709b0f73eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5810bcef5e865af1cdbfb8e0586fa12d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5810bcef5e865af1cdbfb8e0586fa12d"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a5810bcef5e865af1cdbfb8e0586fa12d">linkerZoneMidlineViscosity</a></td></tr>
<tr class="memdesc:a5810bcef5e865af1cdbfb8e0586fa12d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal viscosity of the mid-line section of linker tissue between columnar and peripodial. <br /></td></tr>
<tr class="separator:a5810bcef5e865af1cdbfb8e0586fa12d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47187b5d7f450b1c41e6fdaffeedc207"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47187b5d7f450b1c41e6fdaffeedc207"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a47187b5d7f450b1c41e6fdaffeedc207">nGrowthFunctions</a></td></tr>
<tr class="memdesc:a47187b5d7f450b1c41e6fdaffeedc207"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of growth functions active in the simulation. <br /></td></tr>
<tr class="separator:a47187b5d7f450b1c41e6fdaffeedc207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae83cadb5675d5ef391adb5d1595070ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae83cadb5675d5ef391adb5d1595070ec"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ae83cadb5675d5ef391adb5d1595070ec">GridGrowthsPinnedOnInitialMesh</a></td></tr>
<tr class="memdesc:ae83cadb5675d5ef391adb5d1595070ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean stating if the grid based gorwth is pinned on the mesh for prolonged periods, the timings stored in <a class="el" href="classSimulation.html#ad6454fcc9e796f92d6c9aec482f10191" title="The vector storing the growth rate pinning update times, as Simulation::timestep counters. ">Simulation::growthPinUpdateTime</a>. <br /></td></tr>
<tr class="separator:ae83cadb5675d5ef391adb5d1595070ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505b17bf704f4ee58df2490b993c8f15"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a505b17bf704f4ee58df2490b993c8f15"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a505b17bf704f4ee58df2490b993c8f15">nGrowthPinning</a></td></tr>
<tr class="memdesc:a505b17bf704f4ee58df2490b993c8f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of times growth pinning positions will be updated, the relative positions of elements in tissue. <br /></td></tr>
<tr class="separator:a505b17bf704f4ee58df2490b993c8f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6454fcc9e796f92d6c9aec482f10191"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6454fcc9e796f92d6c9aec482f10191"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ad6454fcc9e796f92d6c9aec482f10191">growthPinUpdateTime</a></td></tr>
<tr class="memdesc:ad6454fcc9e796f92d6c9aec482f10191"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector storing the growth rate pinning update times, as <a class="el" href="classSimulation.html#a2056af9924aff237c804ffe006adc00b" title="The time step count, such that Simulation::currSimTimeSec = Simulation::dt * Simulation::timestep. ">Simulation::timestep</a> counters. <br /></td></tr>
<tr class="separator:ad6454fcc9e796f92d6c9aec482f10191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7209f8394d5888670e14e3d46c89718f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7209f8394d5888670e14e3d46c89718f"></a>
std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a7209f8394d5888670e14e3d46c89718f">growthPinUpdateBools</a></td></tr>
<tr class="memdesc:a7209f8394d5888670e14e3d46c89718f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector storint the booleans to check the pinning update has been carried out. <br /></td></tr>
<tr class="separator:a7209f8394d5888670e14e3d46c89718f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4bbc66c4a2bb43de57509d25ce6ac4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a4bbc66c4a2bb43de57509d25ce6ac4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a6a4bbc66c4a2bb43de57509d25ce6ac4">gridGrowthsInterpolationType</a></td></tr>
<tr class="memdesc:a6a4bbc66c4a2bb43de57509d25ce6ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of interpolation done on growth map grid, 0 = no interpolation, step function, 1 = linear interpolation (default = 1). <br /></td></tr>
<tr class="separator:a6a4bbc66c4a2bb43de57509d25ce6ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425b8ee683e10f79d04e8710d82dafe2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a425b8ee683e10f79d04e8710d82dafe2"></a>
std::vector&lt; std::unique_ptr&lt; <a class="el" href="classGrowthFunctionBase.html">GrowthFunctionBase</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a425b8ee683e10f79d04e8710d82dafe2">GrowthFunctions</a></td></tr>
<tr class="memdesc:a425b8ee683e10f79d04e8710d82dafe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector containing the unique pointers to the growth functions active in the simulation. <br /></td></tr>
<tr class="separator:a425b8ee683e10f79d04e8710d82dafe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74251252e9f320268055537749d674c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74251252e9f320268055537749d674c1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a74251252e9f320268055537749d674c1">nShapeChangeFunctions</a></td></tr>
<tr class="memdesc:a74251252e9f320268055537749d674c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of shape change functions active in the simulation. <br /></td></tr>
<tr class="separator:a74251252e9f320268055537749d674c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdceee7efa90cc90973292c5e0a72e72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afdceee7efa90cc90973292c5e0a72e72"></a>
std::vector&lt; std::unique_ptr&lt; <a class="el" href="classGrowthFunctionBase.html">GrowthFunctionBase</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#afdceee7efa90cc90973292c5e0a72e72">ShapeChangeFunctions</a></td></tr>
<tr class="memdesc:afdceee7efa90cc90973292c5e0a72e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector containing the unique pointers to the shape change functions active in the simulation. <br /></td></tr>
<tr class="separator:afdceee7efa90cc90973292c5e0a72e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5869e105b5d4d2e41c071f24988b314e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5869e105b5d4d2e41c071f24988b314e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a5869e105b5d4d2e41c071f24988b314e">shapeChangeECMLimit</a></td></tr>
<tr class="memdesc:a5869e105b5d4d2e41c071f24988b314e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The threshold of ECM density upon which emergent shape change will be activated (reduction of ECM strength inducing shape change). <br /></td></tr>
<tr class="separator:a5869e105b5d4d2e41c071f24988b314e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d54e9e505f3701cf5ca8b0ac0df00a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0d54e9e505f3701cf5ca8b0ac0df00a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ab0d54e9e505f3701cf5ca8b0ac0df00a">thereIsPlasticDeformation</a></td></tr>
<tr class="memdesc:ab0d54e9e505f3701cf5ca8b0ac0df00a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean stating that there is plastic deformation (remodelling) in the tissue. <br /></td></tr>
<tr class="separator:ab0d54e9e505f3701cf5ca8b0ac0df00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2cb97bd129a14b21e15b742af8768c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf2cb97bd129a14b21e15b742af8768c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#abf2cb97bd129a14b21e15b742af8768c">plasticDeformationAppliedToPeripodial</a></td></tr>
<tr class="memdesc:abf2cb97bd129a14b21e15b742af8768c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean stating that plastic deformation (remodelling) is applied to peripodial tissue. <br /></td></tr>
<tr class="separator:abf2cb97bd129a14b21e15b742af8768c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42218fdf4e2a624fd4886edb39125251"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42218fdf4e2a624fd4886edb39125251"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a42218fdf4e2a624fd4886edb39125251">plasticDeformationAppliedToColumnar</a></td></tr>
<tr class="memdesc:a42218fdf4e2a624fd4886edb39125251"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean stating that plastic deformation (remodelling) is applied to columnar tissue. <br /></td></tr>
<tr class="separator:a42218fdf4e2a624fd4886edb39125251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e44e881245a507dc96188a8934b3bcc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e44e881245a507dc96188a8934b3bcc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a0e44e881245a507dc96188a8934b3bcc">volumeConservedInPlasticDeformation</a></td></tr>
<tr class="memdesc:a0e44e881245a507dc96188a8934b3bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean stating if volume is conserved during plastic deformation (remodelling). <br /></td></tr>
<tr class="separator:a0e44e881245a507dc96188a8934b3bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aeea82e56a6523f2918583af1ecdd1a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1aeea82e56a6523f2918583af1ecdd1a"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a1aeea82e56a6523f2918583af1ecdd1a">plasticDeformationHalfLife</a></td></tr>
<tr class="memdesc:a1aeea82e56a6523f2918583af1ecdd1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The half life or plastic deformation (remodelling). <br /></td></tr>
<tr class="separator:a1aeea82e56a6523f2918583af1ecdd1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28126585484ed0c7676c880cfe92f991"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28126585484ed0c7676c880cfe92f991"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a28126585484ed0c7676c880cfe92f991">zRemodellingLowerThreshold</a></td></tr>
<tr class="memdesc:a28126585484ed0c7676c880cfe92f991"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lower threshold of z remodelling, below which an element cannot be shrunk in z, fraction. <br /></td></tr>
<tr class="separator:a28126585484ed0c7676c880cfe92f991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab455f57038010e1d9c6694eb99ddca8e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab455f57038010e1d9c6694eb99ddca8e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ab455f57038010e1d9c6694eb99ddca8e">zRemodellingUpperThreshold</a></td></tr>
<tr class="memdesc:ab455f57038010e1d9c6694eb99ddca8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lower threshold of z remodelling, below which an element cannot be extended in z, fraction. <br /></td></tr>
<tr class="separator:ab455f57038010e1d9c6694eb99ddca8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6913c3f238cbf5455955b42bd617f72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6913c3f238cbf5455955b42bd617f72"></a>
std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#aa6913c3f238cbf5455955b42bd617f72">Nodes</a></td></tr>
<tr class="memdesc:aa6913c3f238cbf5455955b42bd617f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector storing the unique pointers ot the nodes of the simulation. <br /></td></tr>
<tr class="separator:aa6913c3f238cbf5455955b42bd617f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e0aaea7b40dbb5bc11329fc7d34559"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96e0aaea7b40dbb5bc11329fc7d34559"></a>
std::vector&lt; std::unique_ptr&lt; <a class="el" href="classShapeBase.html">ShapeBase</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a96e0aaea7b40dbb5bc11329fc7d34559">Elements</a></td></tr>
<tr class="memdesc:a96e0aaea7b40dbb5bc11329fc7d34559"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector storing the unique pointers ot the elements of the simulation. <br /></td></tr>
<tr class="separator:a96e0aaea7b40dbb5bc11329fc7d34559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80589d220581f9b149e4316e732252f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa80589d220581f9b149e4316e732252f"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#aa80589d220581f9b149e4316e732252f">nElements</a></td></tr>
<tr class="memdesc:aa80589d220581f9b149e4316e732252f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of elements of the simulation. <br /></td></tr>
<tr class="separator:aa80589d220581f9b149e4316e732252f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab779ac291bc517de8a598ab72094c1a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab779ac291bc517de8a598ab72094c1a6"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ab779ac291bc517de8a598ab72094c1a6">nNodes</a></td></tr>
<tr class="memdesc:ab779ac291bc517de8a598ab72094c1a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of nodes of the simulation. <br /></td></tr>
<tr class="separator:ab779ac291bc517de8a598ab72094c1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae01de5bcfd81ddeca987cdb6b054f54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae01de5bcfd81ddeca987cdb6b054f54"></a>
std::vector&lt; std::array&lt; double, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#aae01de5bcfd81ddeca987cdb6b054f54">SystemForces</a></td></tr>
<tr class="memdesc:aae01de5bcfd81ddeca987cdb6b054f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector storing the system forces applied on each node [<a class="el" href="classSimulation.html#ab779ac291bc517de8a598ab72094c1a6" title="The number of nodes of the simulation. ">Simulation::nNodes</a>][3D]. <br /></td></tr>
<tr class="separator:aae01de5bcfd81ddeca987cdb6b054f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999a884533442902aa3a868f4c326a1c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a999a884533442902aa3a868f4c326a1c"></a>
std::vector&lt; std::array&lt; double, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a999a884533442902aa3a868f4c326a1c">PackingForces</a></td></tr>
<tr class="memdesc:a999a884533442902aa3a868f4c326a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector storing the packing forces applied on each node [<a class="el" href="classSimulation.html#ab779ac291bc517de8a598ab72094c1a6" title="The number of nodes of the simulation. ">Simulation::nNodes</a>][3D]. <br /></td></tr>
<tr class="separator:a999a884533442902aa3a868f4c326a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c661769aba37b7374be811dc230e01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8c661769aba37b7374be811dc230e01"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#af8c661769aba37b7374be811dc230e01">addingRandomForces</a></td></tr>
<tr class="memdesc:af8c661769aba37b7374be811dc230e01"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean stating if random forces are added as noise. <br /></td></tr>
<tr class="separator:af8c661769aba37b7374be811dc230e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08bbe7a4f6a277158fac630b4336e3e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08bbe7a4f6a277158fac630b4336e3e2"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a08bbe7a4f6a277158fac630b4336e3e2">randomForces</a></td></tr>
<tr class="memdesc:a08bbe7a4f6a277158fac630b4336e3e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector storing the random forces applied on each node, stored in vector form [<a class="el" href="classSimulation.html#ab779ac291bc517de8a598ab72094c1a6" title="The number of nodes of the simulation. ">Simulation::nNodes</a> * 3D]. <br /></td></tr>
<tr class="separator:a08bbe7a4f6a277158fac630b4336e3e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b272cd63a24f903ab2378d71330e48"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56b272cd63a24f903ab2378d71330e48"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a56b272cd63a24f903ab2378d71330e48">randomForceMean</a></td></tr>
<tr class="memdesc:a56b272cd63a24f903ab2378d71330e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mean of the random forces. <br /></td></tr>
<tr class="separator:a56b272cd63a24f903ab2378d71330e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16edf4b6fbdfb5cbc953ecefb21620c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa16edf4b6fbdfb5cbc953ecefb21620c"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#aa16edf4b6fbdfb5cbc953ecefb21620c">randomForceVar</a></td></tr>
<tr class="memdesc:aa16edf4b6fbdfb5cbc953ecefb21620c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variance of the random forces. <br /></td></tr>
<tr class="separator:aa16edf4b6fbdfb5cbc953ecefb21620c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3229dca48a5d49bbcd641f74605341c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3229dca48a5d49bbcd641f74605341c0"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a3229dca48a5d49bbcd641f74605341c0">SystemCentre</a> [3]</td></tr>
<tr class="memdesc:a3229dca48a5d49bbcd641f74605341c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The geometric centre of the tissue mesh. <br /></td></tr>
<tr class="separator:a3229dca48a5d49bbcd641f74605341c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d908b8560f3da1a2524481c970449c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31d908b8560f3da1a2524481c970449c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a31d908b8560f3da1a2524481c970449c">needPeripodialforInputConsistency</a></td></tr>
<tr class="memdesc:a31d908b8560f3da1a2524481c970449c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean stating if the simulation inputs require peripodial tissue. <br /></td></tr>
<tr class="separator:a31d908b8560f3da1a2524481c970449c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43db0752ce3c4d11a6268e7896a021f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43db0752ce3c4d11a6268e7896a021f0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a43db0752ce3c4d11a6268e7896a021f0">thereIsPeripodialMembrane</a></td></tr>
<tr class="memdesc:a43db0752ce3c4d11a6268e7896a021f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean stating if there is a peripodial membrane in the simulation. <br /></td></tr>
<tr class="separator:a43db0752ce3c4d11a6268e7896a021f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b15db1d6838c8387e3cce18dc469b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6b15db1d6838c8387e3cce18dc469b1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#aa6b15db1d6838c8387e3cce18dc469b1">symmetricY</a></td></tr>
<tr class="memdesc:aa6b15db1d6838c8387e3cce18dc469b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean stating if there is y-axis symettricity in tissue. <br /></td></tr>
<tr class="separator:aa6b15db1d6838c8387e3cce18dc469b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab224011afb730f28d57d12db3160c4ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab224011afb730f28d57d12db3160c4ed"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ab224011afb730f28d57d12db3160c4ed">symmetricX</a></td></tr>
<tr class="memdesc:ab224011afb730f28d57d12db3160c4ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean stating if there is x-axis symettricity in tissue. <br /></td></tr>
<tr class="separator:ab224011afb730f28d57d12db3160c4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd66be606281f44c05ec6b4f8eed882"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1dd66be606281f44c05ec6b4f8eed882"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a1dd66be606281f44c05ec6b4f8eed882">conservingColumnVolumes</a></td></tr>
<tr class="memdesc:a1dd66be606281f44c05ec6b4f8eed882"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean stating if the simulation is conserving the volume of each elemental column rather than each element. <br /></td></tr>
<tr class="separator:a1dd66be606281f44c05ec6b4f8eed882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adabe1c2bf2cb95e122fe157ddf4c170e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adabe1c2bf2cb95e122fe157ddf4c170e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#adabe1c2bf2cb95e122fe157ddf4c170e">thereIsArtificaialRelaxation</a></td></tr>
<tr class="memdesc:adabe1c2bf2cb95e122fe157ddf4c170e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean stating if there is artifical relaxation of forces in tissue at a selected time point stored in <a class="el" href="classSimulation.html#a7a394751dc6e09dec25db763d94cbdf9" title="The time of artifical relaxation of forces, in seconds. ">Simulation::artificialRelaxationTime</a>. <br /></td></tr>
<tr class="separator:adabe1c2bf2cb95e122fe157ddf4c170e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb11c44d4b8ae638fb8c4bdce400c37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9cb11c44d4b8ae638fb8c4bdce400c37"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a9cb11c44d4b8ae638fb8c4bdce400c37">relaxECMInArtificialRelaxation</a></td></tr>
<tr class="memdesc:a9cb11c44d4b8ae638fb8c4bdce400c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean stating if the ECM should be relaxed with the tissue in artifical relaxation of forces at a selected time point stored in <a class="el" href="classSimulation.html#a7a394751dc6e09dec25db763d94cbdf9" title="The time of artifical relaxation of forces, in seconds. ">Simulation::artificialRelaxationTime</a>. <br /></td></tr>
<tr class="separator:a9cb11c44d4b8ae638fb8c4bdce400c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a394751dc6e09dec25db763d94cbdf9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a394751dc6e09dec25db763d94cbdf9"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a7a394751dc6e09dec25db763d94cbdf9">artificialRelaxationTime</a></td></tr>
<tr class="memdesc:a7a394751dc6e09dec25db763d94cbdf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The time of artifical relaxation of forces, in seconds. <br /></td></tr>
<tr class="separator:a7a394751dc6e09dec25db763d94cbdf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab998930bbef90a5a59ba86079a44e7ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab998930bbef90a5a59ba86079a44e7ae"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ab998930bbef90a5a59ba86079a44e7ae">stretcherAttached</a></td></tr>
<tr class="memdesc:ab998930bbef90a5a59ba86079a44e7ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean stating if there is a stretcher experimental setup attached to tissue. <br /></td></tr>
<tr class="separator:ab998930bbef90a5a59ba86079a44e7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822045adc54ecbf2a5c33c65eeb856e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a822045adc54ecbf2a5c33c65eeb856e8"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a822045adc54ecbf2a5c33c65eeb856e8">leftClampBorder</a></td></tr>
<tr class="memdesc:a822045adc54ecbf2a5c33c65eeb856e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classNode.html#a1bd379569cc1a8b96432e61971aed4d9" title="The unique identification number of the node. ">Node::Id</a> vector for the nodes at the border of stretcher experiment left side clamp. <br /></td></tr>
<tr class="separator:a822045adc54ecbf2a5c33c65eeb856e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e68a828b5ec906e9b949aebd087098"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73e68a828b5ec906e9b949aebd087098"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a73e68a828b5ec906e9b949aebd087098">rightClampBorder</a></td></tr>
<tr class="memdesc:a73e68a828b5ec906e9b949aebd087098"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classNode.html#a1bd379569cc1a8b96432e61971aed4d9" title="The unique identification number of the node. ">Node::Id</a> vector for the nodes at the border of stretcher experiment right side clamp. <br /></td></tr>
<tr class="separator:a73e68a828b5ec906e9b949aebd087098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d5bb340613f0a93a71bb8f3a73f609"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6d5bb340613f0a93a71bb8f3a73f609"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ad6d5bb340613f0a93a71bb8f3a73f609">leftClampForces</a> [3]</td></tr>
<tr class="memdesc:ad6d5bb340613f0a93a71bb8f3a73f609"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total force vector at the stretcher experiment left side clamp. <br /></td></tr>
<tr class="separator:ad6d5bb340613f0a93a71bb8f3a73f609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88acfad799773f87059228a07d40b37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa88acfad799773f87059228a07d40b37"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#aa88acfad799773f87059228a07d40b37">rightClampForces</a> [3]</td></tr>
<tr class="memdesc:aa88acfad799773f87059228a07d40b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total force vector at the stretcher experiment right side clamp. <br /></td></tr>
<tr class="separator:aa88acfad799773f87059228a07d40b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99671c6b222e164dd65bd969632480f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af99671c6b222e164dd65bd969632480f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#af99671c6b222e164dd65bd969632480f">DVClamp</a></td></tr>
<tr class="memdesc:af99671c6b222e164dd65bd969632480f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if the tissue should be clapmed in the DV axis (long axis). <br /></td></tr>
<tr class="separator:af99671c6b222e164dd65bd969632480f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21ce1a13eb2eedd549a1f61232b948b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac21ce1a13eb2eedd549a1f61232b948b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ac21ce1a13eb2eedd549a1f61232b948b">distanceIndex</a></td></tr>
<tr class="memdesc:ac21ce1a13eb2eedd549a1f61232b948b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index of dimension for stretcher clamp position, 0 (x) id attached on long axis, 1 (y) otherwise. <br /></td></tr>
<tr class="separator:ac21ce1a13eb2eedd549a1f61232b948b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7c90b578a80c574d7f8c35adac0afd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b7c90b578a80c574d7f8c35adac0afd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a8b7c90b578a80c574d7f8c35adac0afd">StretchInitialTime</a></td></tr>
<tr class="memdesc:a8b7c90b578a80c574d7f8c35adac0afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The activation time of the stretcher, timestep counter unit. <br /></td></tr>
<tr class="separator:a8b7c90b578a80c574d7f8c35adac0afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13e08bc4489985bbb66400226595aac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af13e08bc4489985bbb66400226595aac"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#af13e08bc4489985bbb66400226595aac">StretchEndTime</a></td></tr>
<tr class="memdesc:af13e08bc4489985bbb66400226595aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">The end time of gradual stretching stretcher, timestep counter unit. <br /></td></tr>
<tr class="separator:af13e08bc4489985bbb66400226595aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579d17e790d3ea2e470db00e3a732e0c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a579d17e790d3ea2e470db00e3a732e0c"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a579d17e790d3ea2e470db00e3a732e0c">StretchMin</a></td></tr>
<tr class="memdesc:a579d17e790d3ea2e470db00e3a732e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum relative position in the selected direction (<a class="el" href="classSimulation.html#ac21ce1a13eb2eedd549a1f61232b948b" title="The index of dimension for stretcher clamp position, 0 (x) id attached on long axis, 1 (y) otherwise. ">Simulation::distanceIndex</a>), below which the nodes are clamped and move with the stretcher. <br /></td></tr>
<tr class="separator:a579d17e790d3ea2e470db00e3a732e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53227db1a41449ba235979fdd052f42e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53227db1a41449ba235979fdd052f42e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a53227db1a41449ba235979fdd052f42e">StretchMax</a></td></tr>
<tr class="memdesc:a53227db1a41449ba235979fdd052f42e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum relative position in the selected direction (<a class="el" href="classSimulation.html#ac21ce1a13eb2eedd549a1f61232b948b" title="The index of dimension for stretcher clamp position, 0 (x) id attached on long axis, 1 (y) otherwise. ">Simulation::distanceIndex</a>), below which the nodes are clamped and move with the stretcher. <br /></td></tr>
<tr class="separator:a53227db1a41449ba235979fdd052f42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76aca0fc8a6de8550af15556d18e6dfb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76aca0fc8a6de8550af15556d18e6dfb"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a76aca0fc8a6de8550af15556d18e6dfb">StretchStrain</a></td></tr>
<tr class="memdesc:a76aca0fc8a6de8550af15556d18e6dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The stretch applied in the stretcher device. <br /></td></tr>
<tr class="separator:a76aca0fc8a6de8550af15556d18e6dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10cfa63b384b954f5ea34afca788f298"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10cfa63b384b954f5ea34afca788f298"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a10cfa63b384b954f5ea34afca788f298">PipetteSuction</a></td></tr>
<tr class="memdesc:a10cfa63b384b954f5ea34afca788f298"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean if there is a pipette aspiration experiment in the simulation. <br /></td></tr>
<tr class="separator:a10cfa63b384b954f5ea34afca788f298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d18b41ab9318966acb05815ab4deb0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53d18b41ab9318966acb05815ab4deb0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a53d18b41ab9318966acb05815ab4deb0">ApicalSuction</a></td></tr>
<tr class="memdesc:a53d18b41ab9318966acb05815ab4deb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean if the pipette aspiration experiment is attached to apical surface, if not, it is attached to basal surface. <br /></td></tr>
<tr class="separator:a53d18b41ab9318966acb05815ab4deb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac639bb76a25b8df8917d6e288358110"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac639bb76a25b8df8917d6e288358110"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#aac639bb76a25b8df8917d6e288358110">TissueStuckOnGlassDuringPipetteAspiration</a></td></tr>
<tr class="memdesc:aac639bb76a25b8df8917d6e288358110"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean stating if the tissue is stuck on glass on the non-aspirated surface. <br /></td></tr>
<tr class="separator:aac639bb76a25b8df8917d6e288358110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24de4a27428b8a8d6c80a02d43186df8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24de4a27428b8a8d6c80a02d43186df8"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a24de4a27428b8a8d6c80a02d43186df8">TransientZFixListForPipette</a></td></tr>
<tr class="memdesc:a24de4a27428b8a8d6c80a02d43186df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector of <a class="el" href="classNode.html#a1bd379569cc1a8b96432e61971aed4d9" title="The unique identification number of the node. ">Node::Id</a> marking the nodes packling to the tip of the pipette. <br /></td></tr>
<tr class="separator:a24de4a27428b8a8d6c80a02d43186df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f29a12d0630213fe58e14a0e198ca0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3f29a12d0630213fe58e14a0e198ca0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ab3f29a12d0630213fe58e14a0e198ca0">PipetteInitialStep</a></td></tr>
<tr class="memdesc:ab3f29a12d0630213fe58e14a0e198ca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initial time step of pipette aspiration. <br /></td></tr>
<tr class="separator:ab3f29a12d0630213fe58e14a0e198ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a1f04e643d462d60644fef64fd7416"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54a1f04e643d462d60644fef64fd7416"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a54a1f04e643d462d60644fef64fd7416">nPipetteSuctionSteps</a></td></tr>
<tr class="memdesc:a54a1f04e643d462d60644fef64fd7416"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of steps the pressure of the pipette aspiration experimetnis increased, times and pressures saved in <a class="el" href="classSimulation.html#ae9b603670a57de082f3c87615eed3822" title="The time points where the pipette aspiration pressure is increased, the pressures are stored in Simul...">Simulation::pipetteSuctionTimes</a> and <a class="el" href="classSimulation.html#a53bcf3b46795c52fd209a52d326db783" title="The pressures steps of the pipette aspiration experiment, the times are stored in Simulation::pipette...">Simulation::pipetteSuctionPressures</a>, respectively. <br /></td></tr>
<tr class="separator:a54a1f04e643d462d60644fef64fd7416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b603670a57de082f3c87615eed3822"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9b603670a57de082f3c87615eed3822"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ae9b603670a57de082f3c87615eed3822">pipetteSuctionTimes</a></td></tr>
<tr class="memdesc:ae9b603670a57de082f3c87615eed3822"><td class="mdescLeft">&#160;</td><td class="mdescRight">The time points where the pipette aspiration pressure is increased, the pressures are stored in <a class="el" href="classSimulation.html#a53bcf3b46795c52fd209a52d326db783" title="The pressures steps of the pipette aspiration experiment, the times are stored in Simulation::pipette...">Simulation::pipetteSuctionPressures</a>. <br /></td></tr>
<tr class="separator:ae9b603670a57de082f3c87615eed3822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53bcf3b46795c52fd209a52d326db783"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53bcf3b46795c52fd209a52d326db783"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a53bcf3b46795c52fd209a52d326db783">pipetteSuctionPressures</a></td></tr>
<tr class="memdesc:a53bcf3b46795c52fd209a52d326db783"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pressures steps of the pipette aspiration experiment, the times are stored in <a class="el" href="classSimulation.html#ae9b603670a57de082f3c87615eed3822" title="The time points where the pipette aspiration pressure is increased, the pressures are stored in Simul...">Simulation::pipetteSuctionTimes</a>. <br /></td></tr>
<tr class="separator:a53bcf3b46795c52fd209a52d326db783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ba175cfd0377ddab49a0058139f03c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80ba175cfd0377ddab49a0058139f03c"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a80ba175cfd0377ddab49a0058139f03c">pipetteCentre</a> [3]</td></tr>
<tr class="memdesc:a80ba175cfd0377ddab49a0058139f03c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The centre of the pipette tip [x][y][z]. <br /></td></tr>
<tr class="separator:a80ba175cfd0377ddab49a0058139f03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d987f6569d306688d272436294e85f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d987f6569d306688d272436294e85f4"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a6d987f6569d306688d272436294e85f4">pipetteDepth</a></td></tr>
<tr class="memdesc:a6d987f6569d306688d272436294e85f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The z-depth of the suction pressure effectiveness from the pipette tip. <br /></td></tr>
<tr class="separator:a6d987f6569d306688d272436294e85f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0a8edcc987294ad36dc43cb0b2c77c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c0a8edcc987294ad36dc43cb0b2c77c"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a9c0a8edcc987294ad36dc43cb0b2c77c">pipetteInnerRadius</a></td></tr>
<tr class="memdesc:a9c0a8edcc987294ad36dc43cb0b2c77c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inner radius of the pipette. <br /></td></tr>
<tr class="separator:a9c0a8edcc987294ad36dc43cb0b2c77c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330bde4b57359e57318c1105edde06c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a330bde4b57359e57318c1105edde06c5"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a330bde4b57359e57318c1105edde06c5">pipetteThickness</a></td></tr>
<tr class="memdesc:a330bde4b57359e57318c1105edde06c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The thickness of the pipette. <br /></td></tr>
<tr class="separator:a330bde4b57359e57318c1105edde06c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a32b7ebb6db0157237249733ee653f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7a32b7ebb6db0157237249733ee653f"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ab7a32b7ebb6db0157237249733ee653f">pipetteInnerRadiusSq</a></td></tr>
<tr class="memdesc:ab7a32b7ebb6db0157237249733ee653f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pipette inner radius (<a class="el" href="classSimulation.html#a9c0a8edcc987294ad36dc43cb0b2c77c" title="The inner radius of the pipette. ">Simulation::pipetteInnerRadius</a>) squared. <br /></td></tr>
<tr class="separator:ab7a32b7ebb6db0157237249733ee653f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a94dce9bdc0a99a99cab0abe805185"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70a94dce9bdc0a99a99cab0abe805185"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a70a94dce9bdc0a99a99cab0abe805185">effectLimitsInZ</a> [2]</td></tr>
<tr class="memdesc:a70a94dce9bdc0a99a99cab0abe805185"><td class="mdescLeft">&#160;</td><td class="mdescRight">The effective suction limits of the pipette in z, from tip to infinity in the opposing direction. <br /></td></tr>
<tr class="separator:a70a94dce9bdc0a99a99cab0abe805185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b121f145af33dae88b463490aef709"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7b121f145af33dae88b463490aef709"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#aa7b121f145af33dae88b463490aef709">SuctionPressure</a> [3]</td></tr>
<tr class="memdesc:aa7b121f145af33dae88b463490aef709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current suction pressure of the pipette suction experiment. <br /></td></tr>
<tr class="separator:aa7b121f145af33dae88b463490aef709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad1e5ce0657d347c8b46a4d1749caa3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adad1e5ce0657d347c8b46a4d1749caa3"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#adad1e5ce0657d347c8b46a4d1749caa3">TissueHeight</a></td></tr>
<tr class="memdesc:adad1e5ce0657d347c8b46a4d1749caa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The height of the tissue. <br /></td></tr>
<tr class="separator:adad1e5ce0657d347c8b46a4d1749caa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40071d89036f339dd4c1dde41951741"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af40071d89036f339dd4c1dde41951741"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#af40071d89036f339dd4c1dde41951741">TissueHeightDiscretisationLayers</a></td></tr>
<tr class="memdesc:af40071d89036f339dd4c1dde41951741"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of elemetns the tissue height is discretisized to. <br /></td></tr>
<tr class="separator:af40071d89036f339dd4c1dde41951741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5b5de0190d35c7984c4b393fd9fcd9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e5b5de0190d35c7984c4b393fd9fcd9"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a8e5b5de0190d35c7984c4b393fd9fcd9">boundingBox</a> [2][3]</td></tr>
<tr class="memdesc:a8e5b5de0190d35c7984c4b393fd9fcd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bounding box of the tissue [lower left corner [x][y][z]] [upper right corner[x][y][z]]. <br /></td></tr>
<tr class="separator:a8e5b5de0190d35c7984c4b393fd9fcd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb78dddb085445b34d6ed6efee996183"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb78dddb085445b34d6ed6efee996183"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#aeb78dddb085445b34d6ed6efee996183">pacingNodeCouples0</a></td></tr>
<tr class="memdesc:aeb78dddb085445b34d6ed6efee996183"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector storing the <a class="el" href="classNode.html#a1bd379569cc1a8b96432e61971aed4d9" title="The unique identification number of the node. ">Node::Id</a> list of packing node couples, coupled with <a class="el" href="classSimulation.html#ab67e69811ef54ec761cce2b4c76fb568" title="The vector storing the Node::Id list of packing node couples, coupled with Simulation::pacingNodeCoup...">Simulation::pacingNodeCouples1</a>. <br /></td></tr>
<tr class="separator:aeb78dddb085445b34d6ed6efee996183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67e69811ef54ec761cce2b4c76fb568"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab67e69811ef54ec761cce2b4c76fb568"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ab67e69811ef54ec761cce2b4c76fb568">pacingNodeCouples1</a></td></tr>
<tr class="memdesc:ab67e69811ef54ec761cce2b4c76fb568"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector storing the <a class="el" href="classNode.html#a1bd379569cc1a8b96432e61971aed4d9" title="The unique identification number of the node. ">Node::Id</a> list of packing node couples, coupled with <a class="el" href="classSimulation.html#aeb78dddb085445b34d6ed6efee996183" title="The vector storing the Node::Id list of packing node couples, coupled with Simulation::pacingNodeCoup...">Simulation::pacingNodeCouples0</a>. <br /></td></tr>
<tr class="separator:ab67e69811ef54ec761cce2b4c76fb568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad549ce1c8c1fee8311e54eea5dede24d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad549ce1c8c1fee8311e54eea5dede24d"></a>
std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ad549ce1c8c1fee8311e54eea5dede24d">pacingNodeCouplesHaveAdhered</a></td></tr>
<tr class="memdesc:ad549ce1c8c1fee8311e54eea5dede24d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean vector stating if the potentially packing node couple have adheres (couple stored in <a class="el" href="classSimulation.html">Simulation</a>#///&lt; The vector storing the <a class="el" href="classNode.html#a1bd379569cc1a8b96432e61971aed4d9" title="The unique identification number of the node. ">Node::Id</a> list of packing node couples, coupled with <a class="el" href="classSimulation.html#aeb78dddb085445b34d6ed6efee996183" title="The vector storing the Node::Id list of packing node couples, coupled with Simulation::pacingNodeCoup...">Simulation::pacingNodeCouples0</a> and <a class="el" href="classSimulation.html">Simulation</a>#///&lt; The vector storing the <a class="el" href="classNode.html#a1bd379569cc1a8b96432e61971aed4d9" title="The unique identification number of the node. ">Node::Id</a> list of packing node couples, coupled with <a class="el" href="classSimulation.html#ab67e69811ef54ec761cce2b4c76fb568" title="The vector storing the Node::Id list of packing node couples, coupled with Simulation::pacingNodeCoup...">Simulation::pacingNodeCouples1</a>). <br /></td></tr>
<tr class="separator:ad549ce1c8c1fee8311e54eea5dede24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a035fd880a67421014b46a9a85c6cbd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a035fd880a67421014b46a9a85c6cbd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a6a035fd880a67421014b46a9a85c6cbd">nMarkerEllipseRanges</a></td></tr>
<tr class="memdesc:a6a035fd880a67421014b46a9a85c6cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of marker ellipses used in perturbation activation. <br /></td></tr>
<tr class="separator:a6a035fd880a67421014b46a9a85c6cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3495b4621a68a6698c6305f2dd9f2798"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3495b4621a68a6698c6305f2dd9f2798"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a3495b4621a68a6698c6305f2dd9f2798">markerEllipseBandXCentres</a></td></tr>
<tr class="memdesc:a3495b4621a68a6698c6305f2dd9f2798"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vecotr storing the x centres of the marker ellipse bands used in perturbation activation. <br /></td></tr>
<tr class="separator:a3495b4621a68a6698c6305f2dd9f2798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6084b215ed2b7f11bd208c25e9b1e256"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6084b215ed2b7f11bd208c25e9b1e256"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a6084b215ed2b7f11bd208c25e9b1e256">markerEllipseBandR1Ranges</a></td></tr>
<tr class="memdesc:a6084b215ed2b7f11bd208c25e9b1e256"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vecotr storing the inner radia of the marker ellipse bands used in perturbation activation. <br /></td></tr>
<tr class="separator:a6084b215ed2b7f11bd208c25e9b1e256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78598aabaa0ffafb153edf5dbc51aea9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78598aabaa0ffafb153edf5dbc51aea9"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a78598aabaa0ffafb153edf5dbc51aea9">markerEllipseBandR2Ranges</a></td></tr>
<tr class="memdesc:a78598aabaa0ffafb153edf5dbc51aea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vecotr storing the outer radia of the marker ellipse bands used in perturbation activation. <br /></td></tr>
<tr class="separator:a78598aabaa0ffafb153edf5dbc51aea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa715adde27080a9c1e52f4428070d408"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa715adde27080a9c1e52f4428070d408"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#aa715adde27080a9c1e52f4428070d408">thereIsECMChange</a></td></tr>
<tr class="memdesc:aa715adde27080a9c1e52f4428070d408"><td class="mdescLeft">&#160;</td><td class="mdescRight">There is perturnaton on ECM. <br /></td></tr>
<tr class="separator:aa715adde27080a9c1e52f4428070d408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc949fef766f9f71a713ea8fe88180b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc949fef766f9f71a713ea8fe88180b1"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#adc949fef766f9f71a713ea8fe88180b1">numberOfECMChangeEllipseBands</a></td></tr>
<tr class="memdesc:adc949fef766f9f71a713ea8fe88180b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of marker ellipses used in perturbation of the ECM. <br /></td></tr>
<tr class="separator:adc949fef766f9f71a713ea8fe88180b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505238cc725ac80e5fe265a698135d30"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a505238cc725ac80e5fe265a698135d30"></a>
std::vector&lt; vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a505238cc725ac80e5fe265a698135d30">ECMChangeEllipseBandIds</a></td></tr>
<tr class="memdesc:a505238cc725ac80e5fe265a698135d30"><td class="mdescLeft">&#160;</td><td class="mdescRight">The band Ids of marker ellipses used in perturbation of the ECM. <br /></td></tr>
<tr class="separator:a505238cc725ac80e5fe265a698135d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974c4132b507462e193a8b7d4fc852d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a974c4132b507462e193a8b7d4fc852d4"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a974c4132b507462e193a8b7d4fc852d4">ECMChangeBeginTimeInSec</a></td></tr>
<tr class="memdesc:a974c4132b507462e193a8b7d4fc852d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The time point where ECM change is activated. <br /></td></tr>
<tr class="separator:a974c4132b507462e193a8b7d4fc852d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d912ab9d070b8fc79363b27cdd73928"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d912ab9d070b8fc79363b27cdd73928"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a1d912ab9d070b8fc79363b27cdd73928">ECMChangeEndTimeInSec</a></td></tr>
<tr class="memdesc:a1d912ab9d070b8fc79363b27cdd73928"><td class="mdescLeft">&#160;</td><td class="mdescRight">The time point where ECM change is ended. <br /></td></tr>
<tr class="separator:a1d912ab9d070b8fc79363b27cdd73928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66db5546dcae7e908e950bd066cce4b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66db5546dcae7e908e950bd066cce4b8"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a66db5546dcae7e908e950bd066cce4b8">ECMStiffnessChangeFraction</a></td></tr>
<tr class="memdesc:a66db5546dcae7e908e950bd066cce4b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The final ECM stiffness as a fraction of the initial value at the end of perturbation. <br /></td></tr>
<tr class="separator:a66db5546dcae7e908e950bd066cce4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe203bfe372b8abc3af084c8c5aa7cec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe203bfe372b8abc3af084c8c5aa7cec"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#abe203bfe372b8abc3af084c8c5aa7cec">ECMRenewalHalfLifeTargetFraction</a></td></tr>
<tr class="memdesc:abe203bfe372b8abc3af084c8c5aa7cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The final ECM renewal halflife as a fraction of the initial value at the end of perturbation. <br /></td></tr>
<tr class="separator:abe203bfe372b8abc3af084c8c5aa7cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2367e4589f071a0925265873773cbb1d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2367e4589f071a0925265873773cbb1d"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a2367e4589f071a0925265873773cbb1d">ECMViscosityChangeFraction</a></td></tr>
<tr class="memdesc:a2367e4589f071a0925265873773cbb1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The final ECM external viscosity as a fraction of the initial value at the end of perturbation. <br /></td></tr>
<tr class="separator:a2367e4589f071a0925265873773cbb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082e87b4a29d83f54866ac085e188d92"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a082e87b4a29d83f54866ac085e188d92"></a>
std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a082e87b4a29d83f54866ac085e188d92">changeApicalECM</a></td></tr>
<tr class="memdesc:a082e87b4a29d83f54866ac085e188d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if the apical ECM should be affected by perturbation. <br /></td></tr>
<tr class="separator:a082e87b4a29d83f54866ac085e188d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c12a070e93fd1cd504f98aed28c9fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8c12a070e93fd1cd504f98aed28c9fa"></a>
std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#aa8c12a070e93fd1cd504f98aed28c9fa">changeBasalECM</a></td></tr>
<tr class="memdesc:aa8c12a070e93fd1cd504f98aed28c9fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if the basal ECM should be affected by perturbation. <br /></td></tr>
<tr class="separator:aa8c12a070e93fd1cd504f98aed28c9fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c668b7adc2f6d2d2d4520cc45e6926a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c668b7adc2f6d2d2d4520cc45e6926a"></a>
std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a2c668b7adc2f6d2d2d4520cc45e6926a">ECMChangeTypeIsEmergent</a></td></tr>
<tr class="memdesc:a2c668b7adc2f6d2d2d4520cc45e6926a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if the ECM perturbation is emergent with fold initiation, rather tahn input ellipse markers. <br /></td></tr>
<tr class="separator:a2c668b7adc2f6d2d2d4520cc45e6926a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99017cf7137be61482cfdcbe751f7a11"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99017cf7137be61482cfdcbe751f7a11"></a>
std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a99017cf7137be61482cfdcbe751f7a11">changedECM</a></td></tr>
<tr class="memdesc:a99017cf7137be61482cfdcbe751f7a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolaen vector stating if the ECM perturbation has been set up. <br /></td></tr>
<tr class="separator:a99017cf7137be61482cfdcbe751f7a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc8a1c0e41aa8cde9865604b27a4226"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3dc8a1c0e41aa8cde9865604b27a4226"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a3dc8a1c0e41aa8cde9865604b27a4226">notumECMChangeInitTime</a></td></tr>
<tr class="memdesc:a3dc8a1c0e41aa8cde9865604b27a4226"><td class="mdescLeft">&#160;</td><td class="mdescRight">The time point where ECM change to the notum tissue domain is activated. <br /></td></tr>
<tr class="separator:a3dc8a1c0e41aa8cde9865604b27a4226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f2a57f59d39995424b7c32ae11fa8c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45f2a57f59d39995424b7c32ae11fa8c"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a45f2a57f59d39995424b7c32ae11fa8c">notumECMChangeEndTime</a></td></tr>
<tr class="memdesc:a45f2a57f59d39995424b7c32ae11fa8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The time point where ECM change to the notum tissue domain is ended. <br /></td></tr>
<tr class="separator:a45f2a57f59d39995424b7c32ae11fa8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4797ce6928843e8871f25adea46f6e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade4797ce6928843e8871f25adea46f6e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ade4797ce6928843e8871f25adea46f6e">notumECMChangeFraction</a></td></tr>
<tr class="memdesc:ade4797ce6928843e8871f25adea46f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The final ECM stiffness as a fraction of the initial value at the end of perturbation to the notum tissue domain is ended. <br /></td></tr>
<tr class="separator:ade4797ce6928843e8871f25adea46f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6491c62b99ae31c0a5bd2b5e3383bfd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6491c62b99ae31c0a5bd2b5e3383bfd"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ae6491c62b99ae31c0a5bd2b5e3383bfd">hingeECMChangeInitTime</a></td></tr>
<tr class="memdesc:ae6491c62b99ae31c0a5bd2b5e3383bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The time point where ECM change to the hinge tissue domain is activated. <br /></td></tr>
<tr class="separator:ae6491c62b99ae31c0a5bd2b5e3383bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dac775eb4843f0cf562aa574664a14f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1dac775eb4843f0cf562aa574664a14f"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a1dac775eb4843f0cf562aa574664a14f">hingeECMChangeEndTime</a></td></tr>
<tr class="memdesc:a1dac775eb4843f0cf562aa574664a14f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The time point where ECM change to the hinge tissue domain is ended. <br /></td></tr>
<tr class="separator:a1dac775eb4843f0cf562aa574664a14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fcc51c4065261a6fa1308e40d6c18d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fcc51c4065261a6fa1308e40d6c18d2"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a2fcc51c4065261a6fa1308e40d6c18d2">hingeECMChangeFraction</a></td></tr>
<tr class="memdesc:a2fcc51c4065261a6fa1308e40d6c18d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The final ECM stiffness as a fraction of the initial value at the end of perturbation to the hinge tissue domain is ended. <br /></td></tr>
<tr class="separator:a2fcc51c4065261a6fa1308e40d6c18d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2da9f9cfd0abfe8d4530cc332f301d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe2da9f9cfd0abfe8d4530cc332f301d"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#abe2da9f9cfd0abfe8d4530cc332f301d">pouchECMChangeInitTime</a></td></tr>
<tr class="memdesc:abe2da9f9cfd0abfe8d4530cc332f301d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The time point where ECM change to the pouch tissue domain is activated. <br /></td></tr>
<tr class="separator:abe2da9f9cfd0abfe8d4530cc332f301d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb40a5902677375bd7d4f30336accb1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbb40a5902677375bd7d4f30336accb1"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#abbb40a5902677375bd7d4f30336accb1">pouchECMChangeEndTime</a></td></tr>
<tr class="memdesc:abbb40a5902677375bd7d4f30336accb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The time point where ECM change to the pouch tissue domain is activated. <br /></td></tr>
<tr class="separator:abbb40a5902677375bd7d4f30336accb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7767563df2d0e9f4d9191dbb6742a6ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7767563df2d0e9f4d9191dbb6742a6ca"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a7767563df2d0e9f4d9191dbb6742a6ca">pouchECMChangeFraction</a></td></tr>
<tr class="memdesc:a7767563df2d0e9f4d9191dbb6742a6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">The final ECM stiffness as a fraction of the initial value at the end of perturbation to the pouch tissue domain is ended. <br /></td></tr>
<tr class="separator:a7767563df2d0e9f4d9191dbb6742a6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8a88fffd9016ee11e7e2575109d437"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe8a88fffd9016ee11e7e2575109d437"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#afe8a88fffd9016ee11e7e2575109d437">ThereIsStiffnessPerturbation</a></td></tr>
<tr class="memdesc:afe8a88fffd9016ee11e7e2575109d437"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bolean stating if there is stiffness perturbation in the system. <br /></td></tr>
<tr class="separator:afe8a88fffd9016ee11e7e2575109d437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d9567de53b463e14b28ae81b35c279"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0d9567de53b463e14b28ae81b35c279"></a>
std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ab0d9567de53b463e14b28ae81b35c279">ThereIsApicalStiffnessPerturbation</a></td></tr>
<tr class="memdesc:ab0d9567de53b463e14b28ae81b35c279"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector storing if the shape change function is applied to apical surface. <br /></td></tr>
<tr class="separator:ab0d9567de53b463e14b28ae81b35c279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159554afc90804c2b60a4ac74bc8d0c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a159554afc90804c2b60a4ac74bc8d0c1"></a>
std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a159554afc90804c2b60a4ac74bc8d0c1">ThereIsBasalStiffnessPerturbation</a></td></tr>
<tr class="memdesc:a159554afc90804c2b60a4ac74bc8d0c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector storing if the shape change function is applied to basal surface. <br /></td></tr>
<tr class="separator:a159554afc90804c2b60a4ac74bc8d0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62aea550cbc8c8e7a767e44512a54668"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62aea550cbc8c8e7a767e44512a54668"></a>
std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a62aea550cbc8c8e7a767e44512a54668">ThereIsWholeTissueStiffnessPerturbation</a></td></tr>
<tr class="memdesc:a62aea550cbc8c8e7a767e44512a54668"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector storing if the shape change function is applied to whole tissue. <br /></td></tr>
<tr class="separator:a62aea550cbc8c8e7a767e44512a54668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673dec3e38b4fbf4b22de30069ba32dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a673dec3e38b4fbf4b22de30069ba32dd"></a>
std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a673dec3e38b4fbf4b22de30069ba32dd">ThereIsBasolateralStiffnessPerturbation</a></td></tr>
<tr class="memdesc:a673dec3e38b4fbf4b22de30069ba32dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector storing if the shape change function is applied to basal and lateral tissue. <br /></td></tr>
<tr class="separator:a673dec3e38b4fbf4b22de30069ba32dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec07dc74b012952665fa54ed35a2736"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ec07dc74b012952665fa54ed35a2736"></a>
std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a5ec07dc74b012952665fa54ed35a2736">ThereIsBasolateralWithApicalRelaxationStiffnessPerturbation</a></td></tr>
<tr class="memdesc:a5ec07dc74b012952665fa54ed35a2736"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector storing if the shape change function is applied to basal and lateral tissue with inverse compansation on the apical layer. <br /></td></tr>
<tr class="separator:a5ec07dc74b012952665fa54ed35a2736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f298f7f7ae41fcd197f17a6134603f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6f298f7f7ae41fcd197f17a6134603f"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>stiffnessChangedToFractionOfOriginal</b></td></tr>
<tr class="separator:aa6f298f7f7ae41fcd197f17a6134603f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36cfc7d8043d1dad55751cf184bcb2b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36cfc7d8043d1dad55751cf184bcb2b8"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a36cfc7d8043d1dad55751cf184bcb2b8">stiffnessPerturbationBeginTimeInSec</a></td></tr>
<tr class="memdesc:a36cfc7d8043d1dad55751cf184bcb2b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector storing the maximum stiffness change as a fraction of the original stiffness. <br /></td></tr>
<tr class="separator:a36cfc7d8043d1dad55751cf184bcb2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9dfbe4a63693a6cfdccfe9c0ee4771"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b9dfbe4a63693a6cfdccfe9c0ee4771"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a8b9dfbe4a63693a6cfdccfe9c0ee4771">stiffnessPerturbationEndTimeInSec</a></td></tr>
<tr class="memdesc:a8b9dfbe4a63693a6cfdccfe9c0ee4771"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector storing the stiffness perturbation initiation time points in sec. <br /></td></tr>
<tr class="separator:a8b9dfbe4a63693a6cfdccfe9c0ee4771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03ad5c7859265aa5eb4d03d2e1f73d1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ae03ad5c7859265aa5eb4d03d2e1f73d1">numberOfStiffnessPerturbationAppliesEllipseBands</a></td></tr>
<tr class="memdesc:ae03ad5c7859265aa5eb4d03d2e1f73d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector storing the stiffness perturbation end time points in sec.  <a href="#ae03ad5c7859265aa5eb4d03d2e1f73d1">More...</a><br /></td></tr>
<tr class="separator:ae03ad5c7859265aa5eb4d03d2e1f73d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d68493a45f2d2cd22c2e757124bd81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95d68493a45f2d2cd22c2e757124bd81"></a>
std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a95d68493a45f2d2cd22c2e757124bd81">stiffnessPerturbationEllipseBandIds</a></td></tr>
<tr class="memdesc:a95d68493a45f2d2cd22c2e757124bd81"><td class="mdescLeft">&#160;</td><td class="mdescRight">The IDs of the marker ellipse band ids the perturbation is applied to. <br /></td></tr>
<tr class="separator:a95d68493a45f2d2cd22c2e757124bd81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96269317c192e8f4682b45b2d272fce5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96269317c192e8f4682b45b2d272fce5"></a>
std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>startedStiffnessPerturbation</b></td></tr>
<tr class="separator:a96269317c192e8f4682b45b2d272fce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83a9bfa83ac45f58129afb916a129ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab83a9bfa83ac45f58129afb916a129ce"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ab83a9bfa83ac45f58129afb916a129ce">packingDetectionThreshold</a></td></tr>
<tr class="memdesc:ab83a9bfa83ac45f58129afb916a129ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">The threshold to detect potentially packing nodes, scaled to average side length. <br /></td></tr>
<tr class="separator:ab83a9bfa83ac45f58129afb916a129ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c55eae62bd214951ca78098e2daf7a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c55eae62bd214951ca78098e2daf7a4"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a0c55eae62bd214951ca78098e2daf7a4">packingDetectionThresholdGrid</a> [10][5]</td></tr>
<tr class="memdesc:a0c55eae62bd214951ca78098e2daf7a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The threshold to detect potentially packing nodes as a grid, scaled to local average side length. <br /></td></tr>
<tr class="separator:a0c55eae62bd214951ca78098e2daf7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0e72518548c938a0c4974e432f9d83"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa0e72518548c938a0c4974e432f9d83"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#afa0e72518548c938a0c4974e432f9d83">packingThreshold</a></td></tr>
<tr class="memdesc:afa0e72518548c938a0c4974e432f9d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">The threshold to detect packing nodes, scaled to average side length. <br /></td></tr>
<tr class="separator:afa0e72518548c938a0c4974e432f9d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a39e3f43e8c3af42da95a827a0a7d5d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a39e3f43e8c3af42da95a827a0a7d5d"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a7a39e3f43e8c3af42da95a827a0a7d5d">packingMultiplier</a></td></tr>
<tr class="memdesc:a7a39e3f43e8c3af42da95a827a0a7d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multiplier stored to scale packing functions where necessary, current value is unity. <br /></td></tr>
<tr class="separator:a7a39e3f43e8c3af42da95a827a0a7d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518ef4319a889b505ff0047fc30a1665"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a518ef4319a889b505ff0047fc30a1665"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a518ef4319a889b505ff0047fc30a1665">sigmoidSaturationForPacking</a></td></tr>
<tr class="memdesc:a518ef4319a889b505ff0047fc30a1665"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sigmoid saturation for packing, current value is 5, see packing function for details. <br /></td></tr>
<tr class="separator:a518ef4319a889b505ff0047fc30a1665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e6096603f734ee31fbd898f94bf38b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0e6096603f734ee31fbd898f94bf38b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#af0e6096603f734ee31fbd898f94bf38b">softPeriphery</a></td></tr>
<tr class="memdesc:af0e6096603f734ee31fbd898f94bf38b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolen stating if there is soft periphery. <br /></td></tr>
<tr class="separator:af0e6096603f734ee31fbd898f94bf38b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8301fb9927cb0527b8f58129aca5626"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8301fb9927cb0527b8f58129aca5626"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ab8301fb9927cb0527b8f58129aca5626">softDepth</a></td></tr>
<tr class="memdesc:ab8301fb9927cb0527b8f58129aca5626"><td class="mdescLeft">&#160;</td><td class="mdescRight">The range of the soft periphery on xy plane. <br /></td></tr>
<tr class="separator:ab8301fb9927cb0527b8f58129aca5626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ef7df1104c1e1263f50f11f36f3cdf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13ef7df1104c1e1263f50f11f36f3cdf"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a13ef7df1104c1e1263f50f11f36f3cdf">softnessFraction</a></td></tr>
<tr class="memdesc:a13ef7df1104c1e1263f50f11f36f3cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fraction of stiffness perturbation at the soft periphery. <br /></td></tr>
<tr class="separator:a13ef7df1104c1e1263f50f11f36f3cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a939ae561258603220a73e00ad4143def"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a939ae561258603220a73e00ad4143def"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a939ae561258603220a73e00ad4143def">softPeripheryBooleans</a> [4]</td></tr>
<tr class="memdesc:a939ae561258603220a73e00ad4143def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolen array stating if soft peripheri is applicable to [applyToApical] [applyToBasal] [applyToColumnar] [applyToPeripodial]. <br /></td></tr>
<tr class="separator:a939ae561258603220a73e00ad4143def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193d6b133b6b3cc3ad199dde1420756d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a193d6b133b6b3cc3ad199dde1420756d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a193d6b133b6b3cc3ad199dde1420756d">thereIsAdhesion</a></td></tr>
<tr class="memdesc:a193d6b133b6b3cc3ad199dde1420756d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if there is adhesion in the system. <br /></td></tr>
<tr class="separator:a193d6b133b6b3cc3ad199dde1420756d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee4b25647be698c89219c1cca3ba15e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ee4b25647be698c89219c1cca3ba15e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a6ee4b25647be698c89219c1cca3ba15e">collapseNodesOnAdhesion</a></td></tr>
<tr class="memdesc:a6ee4b25647be698c89219c1cca3ba15e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if the nodes should be collapsed in their degrees of freedom upon adheison. <br /></td></tr>
<tr class="separator:a6ee4b25647be698c89219c1cca3ba15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b06f6a7a5f9bab315843460f3df7a11"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b06f6a7a5f9bab315843460f3df7a11"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a3b06f6a7a5f9bab315843460f3df7a11">savedStepwise</a></td></tr>
<tr class="memdesc:a3b06f6a7a5f9bab315843460f3df7a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if collapse is stepwise rather than immediate, to avoid instabilities. <br /></td></tr>
<tr class="separator:a3b06f6a7a5f9bab315843460f3df7a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f134ccf6b32a0c6daefc77b298bd0f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f134ccf6b32a0c6daefc77b298bd0f3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a6f134ccf6b32a0c6daefc77b298bd0f3">thereIsEmergentEllipseMarking</a></td></tr>
<tr class="memdesc:a6f134ccf6b32a0c6daefc77b298bd0f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if the emerging folding regions will be marked for further perturbation. <br /></td></tr>
<tr class="separator:a6f134ccf6b32a0c6daefc77b298bd0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab123970654b2c9352dca1fb046cc2173"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab123970654b2c9352dca1fb046cc2173"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ab123970654b2c9352dca1fb046cc2173">thereNodeCollapsing</a></td></tr>
<tr class="memdesc:ab123970654b2c9352dca1fb046cc2173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if the nodes of elements at hogh risk of flipping will be collapsed in their degrees of freedom. <br /></td></tr>
<tr class="separator:ab123970654b2c9352dca1fb046cc2173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae940044346e35e17acd9f4c419f9ce4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae940044346e35e17acd9f4c419f9ce4a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ae940044346e35e17acd9f4c419f9ce4a">implicitPacking</a></td></tr>
<tr class="memdesc:ae940044346e35e17acd9f4c419f9ce4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if the hard-wall packing will be calculated implicitly, inside NR iterations. <br /></td></tr>
<tr class="separator:ae940044346e35e17acd9f4c419f9ce4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2da7191c739e175284886243762a90"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f2da7191c739e175284886243762a90"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a2f2da7191c739e175284886243762a90">thereIsExplicitECM</a></td></tr>
<tr class="memdesc:a2f2da7191c739e175284886243762a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if there is explcite ECM definition in the system. <br /></td></tr>
<tr class="separator:a2f2da7191c739e175284886243762a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c21241b429a8670ecf91d898ccfcf8b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c21241b429a8670ecf91d898ccfcf8b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a3c21241b429a8670ecf91d898ccfcf8b">addLateralECMManually</a></td></tr>
<tr class="memdesc:a3c21241b429a8670ecf91d898ccfcf8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if the side ECM will be added during simulation time rather than being a mexh input. <br /></td></tr>
<tr class="separator:a3c21241b429a8670ecf91d898ccfcf8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80f316c1518d8dbfaca351f3f4066ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af80f316c1518d8dbfaca351f3f4066ca"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#af80f316c1518d8dbfaca351f3f4066ca">lateralECMThickness</a></td></tr>
<tr class="memdesc:af80f316c1518d8dbfaca351f3f4066ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">The thickness of the side ECM to be added. <br /></td></tr>
<tr class="separator:af80f316c1518d8dbfaca351f3f4066ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab090ea461851d09d2ad06bce76967433"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab090ea461851d09d2ad06bce76967433"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ab090ea461851d09d2ad06bce76967433">thereIsExplicitActin</a></td></tr>
<tr class="memdesc:ab090ea461851d09d2ad06bce76967433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if there is explcite actin definition in the system. <br /></td></tr>
<tr class="separator:ab090ea461851d09d2ad06bce76967433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30bc298189ac3e82173c728e32e4a384"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30bc298189ac3e82173c728e32e4a384"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a30bc298189ac3e82173c728e32e4a384">ECMRenawalHalfLife</a></td></tr>
<tr class="memdesc:a30bc298189ac3e82173c728e32e4a384"><td class="mdescLeft">&#160;</td><td class="mdescRight">The half life for ECM renewal inside plastic deformation. <br /></td></tr>
<tr class="separator:a30bc298189ac3e82173c728e32e4a384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa935cd88fb6b87363b775efa578f2737"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa935cd88fb6b87363b775efa578f2737"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#aa935cd88fb6b87363b775efa578f2737">numberOfClones</a></td></tr>
<tr class="memdesc:aa935cd88fb6b87363b775efa578f2737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of mutant clones. <br /></td></tr>
<tr class="separator:aa935cd88fb6b87363b775efa578f2737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80702141bab1e092d1fb9f464a4c91c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af80702141bab1e092d1fb9f464a4c91c"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#af80702141bab1e092d1fb9f464a4c91c">cloneInformationX</a></td></tr>
<tr class="memdesc:af80702141bab1e092d1fb9f464a4c91c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector storing x positions of clone centres. <br /></td></tr>
<tr class="separator:af80702141bab1e092d1fb9f464a4c91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd330f29895998ed507bcd07792378e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afbd330f29895998ed507bcd07792378e"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#afbd330f29895998ed507bcd07792378e">cloneInformationY</a></td></tr>
<tr class="memdesc:afbd330f29895998ed507bcd07792378e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector storing y positions of clone centres. <br /></td></tr>
<tr class="separator:afbd330f29895998ed507bcd07792378e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13db8ef58a0e1927a397a7d562d6812a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13db8ef58a0e1927a397a7d562d6812a"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a13db8ef58a0e1927a397a7d562d6812a">cloneInformationR</a></td></tr>
<tr class="memdesc:a13db8ef58a0e1927a397a7d562d6812a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector storing z positions of clone centres. <br /></td></tr>
<tr class="separator:a13db8ef58a0e1927a397a7d562d6812a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00718ca118c533bbe7059a0f87cad3e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af00718ca118c533bbe7059a0f87cad3e"></a>
std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#af00718ca118c533bbe7059a0f87cad3e">cloneInformationUsingAbsolueGrowth</a></td></tr>
<tr class="memdesc:af00718ca118c533bbe7059a0f87cad3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector of booleans defining the growth perturbation type of clones, true if absolute growth is provided, false if scaled. <br /></td></tr>
<tr class="separator:af00718ca118c533bbe7059a0f87cad3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1abad698b27f9687e12b940eb1a3071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1abad698b27f9687e12b940eb1a3071"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ab1abad698b27f9687e12b940eb1a3071">cloneInformationGrowth</a></td></tr>
<tr class="memdesc:ab1abad698b27f9687e12b940eb1a3071"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector storing the absoule growth rates OR growth fold changes of clones. <br /></td></tr>
<tr class="separator:ab1abad698b27f9687e12b940eb1a3071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f78710998d8706eb7e15857eb03ccc6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f78710998d8706eb7e15857eb03ccc6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a5f78710998d8706eb7e15857eb03ccc6">encloseTissueBetweenSurfaces</a></td></tr>
<tr class="memdesc:a5f78710998d8706eb7e15857eb03ccc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if there is external enclosing surfaces. <br /></td></tr>
<tr class="separator:a5f78710998d8706eb7e15857eb03ccc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b273b605ad9f2dafb4b4ea22b3a4d92"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b273b605ad9f2dafb4b4ea22b3a4d92"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a4b273b605ad9f2dafb4b4ea22b3a4d92">initialZEnclosementBoundaries</a> [2]</td></tr>
<tr class="memdesc:a4b273b605ad9f2dafb4b4ea22b3a4d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initial z position of the enclosing surfaces [top][bottom]. <br /></td></tr>
<tr class="separator:a4b273b605ad9f2dafb4b4ea22b3a4d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8741a8f397eceac3a4f7d40009ada8a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8741a8f397eceac3a4f7d40009ada8a4"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a8741a8f397eceac3a4f7d40009ada8a4">finalZEnclosementBoundaries</a> [2]</td></tr>
<tr class="memdesc:a8741a8f397eceac3a4f7d40009ada8a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Final z position of the enclosing surfaces [top][bottom]. <br /></td></tr>
<tr class="separator:a8741a8f397eceac3a4f7d40009ada8a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4fdde612c109d01508eb4c8d49f76a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc4fdde612c109d01508eb4c8d49f76a"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#adc4fdde612c109d01508eb4c8d49f76a">initialTimeToEncloseTissueBetweenSurfacesSec</a></td></tr>
<tr class="memdesc:adc4fdde612c109d01508eb4c8d49f76a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initial time point to start enclosement. <br /></td></tr>
<tr class="separator:adc4fdde612c109d01508eb4c8d49f76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ef2d249b5d20a2fc0bc399a2b34e6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7ef2d249b5d20a2fc0bc399a2b34e6d"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ab7ef2d249b5d20a2fc0bc399a2b34e6d">finalTimeToEncloseTissueBetweenSurfacesSec</a></td></tr>
<tr class="memdesc:ab7ef2d249b5d20a2fc0bc399a2b34e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Final time point to apply enclosement. <br /></td></tr>
<tr class="separator:ab7ef2d249b5d20a2fc0bc399a2b34e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22bbc8742aed21f955c74c0ae2d60e59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22bbc8742aed21f955c74c0ae2d60e59"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a22bbc8742aed21f955c74c0ae2d60e59">zEnclosementBoundaries</a> [2]</td></tr>
<tr class="memdesc:a22bbc8742aed21f955c74c0ae2d60e59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current z position of the enclosing surfaces [top][bottom]. <br /></td></tr>
<tr class="separator:a22bbc8742aed21f955c74c0ae2d60e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9eacb89b824cb028ff9e36cf2a8eda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc9eacb89b824cb028ff9e36cf2a8eda"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#acc9eacb89b824cb028ff9e36cf2a8eda">packingToEnclosingSurfacesThreshold</a></td></tr>
<tr class="memdesc:acc9eacb89b824cb028ff9e36cf2a8eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The distance threshold for detection of nodes potentially packing to the surface. <br /></td></tr>
<tr class="separator:acc9eacb89b824cb028ff9e36cf2a8eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a1b9f341e5485d7c83e638062e1751"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95a1b9f341e5485d7c83e638062e1751"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a95a1b9f341e5485d7c83e638062e1751">packingDetectionToEnclosingSurfacesThreshold</a></td></tr>
<tr class="memdesc:a95a1b9f341e5485d7c83e638062e1751"><td class="mdescLeft">&#160;</td><td class="mdescRight">The distance threshold for packing to nodes to surfaces. <br /></td></tr>
<tr class="separator:a95a1b9f341e5485d7c83e638062e1751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7751a8ee737000de78a3347c259a9a07"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7751a8ee737000de78a3347c259a9a07"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a7751a8ee737000de78a3347c259a9a07">nodesPackingToPositiveSurface</a></td></tr>
<tr class="memdesc:a7751a8ee737000de78a3347c259a9a07"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classNode.html">Node</a> ids packing to enclosing surface on the top. <br /></td></tr>
<tr class="separator:a7751a8ee737000de78a3347c259a9a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0748afb72db2f26f45d5186504a902"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d0748afb72db2f26f45d5186504a902"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a1d0748afb72db2f26f45d5186504a902">nodesPackingToNegativeSurface</a></td></tr>
<tr class="memdesc:a1d0748afb72db2f26f45d5186504a902"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classNode.html">Node</a> ids packing to enclosing surface at the bottom. <br /></td></tr>
<tr class="separator:a1d0748afb72db2f26f45d5186504a902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbfa67b9482e8aca3f0f09fa8be33b3c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbfa67b9482e8aca3f0f09fa8be33b3c"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#adbfa67b9482e8aca3f0f09fa8be33b3c">initialWeightPackingToPositiveSurface</a></td></tr>
<tr class="memdesc:adbfa67b9482e8aca3f0f09fa8be33b3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weights of packing to state directionality, for nodes packing to surface on top. <br /></td></tr>
<tr class="separator:adbfa67b9482e8aca3f0f09fa8be33b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23138b2d969b8e89959ced5206f59fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac23138b2d969b8e89959ced5206f59fa"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ac23138b2d969b8e89959ced5206f59fa">initialWeightPackingToNegativeSurface</a></td></tr>
<tr class="memdesc:ac23138b2d969b8e89959ced5206f59fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weights of packing to state directionality, for nodes packing to surface at the bottom. <br /></td></tr>
<tr class="separator:ac23138b2d969b8e89959ced5206f59fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a26592cb20108652c8101026de864b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38a26592cb20108652c8101026de864b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#a38a26592cb20108652c8101026de864b">thereIsCircumferenceXYBinding</a></td></tr>
<tr class="memdesc:a38a26592cb20108652c8101026de864b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean stating if circumference is bound in xy plane, all nodes of the same column have their x&amp;y degrees of freedom fixed on the bottom node. This avoids boundary buckling. <br /></td></tr>
<tr class="separator:a38a26592cb20108652c8101026de864b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae799b43b58444df86277c65827076b61"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae799b43b58444df86277c65827076b61"></a>
std::unique_ptr&lt; <a class="el" href="classNewtonRaphsonSolver.html">NewtonRaphsonSolver</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimulation.html#ae799b43b58444df86277c65827076b61">NRSolver</a></td></tr>
<tr class="memdesc:ae799b43b58444df86277c65827076b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pointer to the newton raphson solver. <br /></td></tr>
<tr class="separator:ae799b43b58444df86277c65827076b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7a62be5131e130aa7f631201d5a4a49a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Simulation::addPackingForces </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>gExt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add al packing forces to external foces vector. </p>
<p>The packing forces calculated in <a class="el" href="classSimulation.html#a77e76f4fe61889b9c0ae18436a7fd2fb" title="Calculate packing forces on nodes due to packing to each other. ">Simulation::calculatePackingForcesImplicit3D</a> are added to the system force vector. The vector containd all dimensions of all nodes in one column, therefore indexing is carried out accordingly.</p>

</div>
</div>
<a class="anchor" id="a91a12f6ac1b230cecbe004221326a7ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Simulation::alignTissueDVToXPositive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Align tissue DV axis to x axis, the DV axis is defiend by Simulation::ventralTipIndex and Simulation::dorsalTipIndex, as assigned in <a class="el" href="classSimulation.html#a7ed75e3d044166072754e6e323f3604c" title="This function assigns the nodes marking the tips of the tissue in xy plane. ">Simulation::assignTips</a>. </p>
<p>The bounding box calculateion is relies on the fact that the tissue is lying parallel to the x axis in its initial long axis. Bring the long axis defined by Simulation::ventralTipIndex and Simulation::dorsalTipIndex Node::Ids parallel to the x axis with a rigid body rotation.</p>

</div>
</div>
<a class="anchor" id="aee92b20e497b42f5b7a089c3f9409e97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Simulation::artificialRelax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Artificially relax all deformation on all elements at selected time point. </p>
<p>This function relaxes all accumulated forces on elements of the tissue by transfering the current elastic deformation gradient onto growth gradient. The relaxation can optionally be extended to ECM, or be applied to only cellular material of the tissue.</p>

</div>
</div>
<a class="anchor" id="a5a12ff087efbc813a949e347da7a0438"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Simulation::assignFoldRegionAndReleasePeripodial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>NodeMAster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a> *&#160;</td>
          <td class="paramname"><em>NodeSlave</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Nodes are assigned to be on folding regions if they lie in between two adhered nodes. </p>
<p>If two nodes are adhered they are on an indenting surface and therefore on a fold initiation surface. The <a class="el" href="classNode.html#a913bf9335efdbd81a352b1ef80654f95" title="The boolean stating if this node is on a fold initiation region, automatically detected via curvature...">Node::onFoldInitiation</a> booleans are set to true. Then all the nodes falling in between these two nodes are also declared to be on fold initiation.</p>

</div>
</div>
<a class="anchor" id="a405e565b21064979e0010286927d087a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Simulation::calculateChangeRatesForECM </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idOfCurrentECMPerturbation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the physical property change rates for ECM perturbation with the ECM perturbaiton function of input ID. </p>
<p>If the ECM has perturbations, the elements are checked if they are influenced via <a class="el" href="classShapeBase.html#ab1572ddb1f68178e0607873a432f227c" title="This function decides if the ECM perturbation is applied to this element. ">ShapeBase::isECMChangeAppliedToElement</a> and rates are set in this function via <a class="el" href="classShapeBase.html#aef460b84dc469f89742af7c19411454f" title="This function will calciulate the stiffness perturbation rate. ">ShapeBase::calculateStiffnessPerturbationRate</a>.</p>
<p>For each node, the applicability of ECM change is checked via <a class="el" href="classNode.html#abf7a4917252fff90bd2ff2c50bfc5d21" title="This function checks if the node falls within the range of the marker ellipse band ids for the ECM pr...">Node::isECMChangeAppliedToNode</a>, and the rate <a class="el" href="classNode.html#a58afaee3d71a2c122396265c91acda04" title="The change in ECM viscosity per one hour. The double array of size (1,3) stores the viscosity change ...">Node::ECMViscosityChangePerHour</a> per dimension is calculated via the change fraction <a class="el" href="classSimulation.html#a2367e4589f071a0925265873773cbb1d" title="The final ECM external viscosity as a fraction of the initial value at the end of perturbation...">Simulation::ECMViscosityChangeFraction</a>, the total time of applied change obtined from <a class="el" href="classSimulation.html#a974c4132b507462e193a8b7d4fc852d4" title="The time point where ECM change is activated. ">Simulation::ECMChangeBeginTimeInSec</a> and <a class="el" href="classSimulation.html#a1d912ab9d070b8fc79363b27cdd73928" title="The time point where ECM change is ended. ">Simulation::ECMChangeEndTimeInSec</a>.</p>
<p>The viscosity based ECM perturbation can be applied for ECM definitions beyond explicit ECM, and this is purely on nodal viscosity basis.</p>

</div>
</div>
<a class="anchor" id="a77e76f4fe61889b9c0ae18436a7fd2fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Simulation::calculatePackingForcesImplicit3D </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate packing forces on nodes due to packing to each other. </p>
<p>This function calculates the packing forces between nodes, inside the Newton-Raphson iteration steps. The list of nodes that can potentially pack are detected in function , and recorded in <a class="el" href="classSimulation.html#aeb78dddb085445b34d6ed6efee996183" title="The vector storing the Node::Id list of packing node couples, coupled with Simulation::pacingNodeCoup...">Simulation::pacingNodeCouples0</a> and <a class="el" href="classSimulation.html#ab67e69811ef54ec761cce2b4c76fb568" title="The vector storing the Node::Id list of packing node couples, coupled with Simulation::pacingNodeCoup...">Simulation::pacingNodeCouples1</a>. The applied packing force is a function of the distance between nodes, and is calculated with an inverse logic function:</p>
<p class="formulaDsp">
\[ f\left( d \right) = \frac{L}{1+ e^{-k\left(d-d_{0}\right)}} \]
</p>
<p>Here, the amplitude \( L \) is defined such that the force will scale with the average mass of the two nodes. The steepness of the curve is the force profile will approach to zero as the distance between nodes approaches to packing threshold. It is defined the sigmoid saturation term and the packing threshold as detected by the current average side lengths of mesh elements as below. The sigmoid saturation is set to 5, as this is the approximate saturation distance of the standard logistic function.</p>
<p class="formulaDsp">
\[ -k = \frac{2\:sigmoid\:saturation}{packing\:threshold} \]
</p>
<p>The distance is shifted with distance \( d_{0} \) to move the mid point of the function to approximately 60 per cent of the packing threshold distance.</p>
<div class="image">
<img src="packingForce.png" alt="packingForce.png"/>
</div>
<p>Then the forces on each node i and j become: </p><p class="formulaDsp">
\[ \mathbf{F_{i}}\left( d \right) = f\left( d \right)\: \mathbf{e_{i}}\:\:,\:\: F_{j}\left( d \right) = f\left( d \right)\: \mathbf{e_{j}}=-f\left( d \right)\: \mathbf{e_{i}}=-\mathbf{F_{i}} \]
</p>
<p>where the distance \( d \) is \( ||\mathbf{x_{i}}-\mathbf{x_{j}} || \), and the normal is \( \mathbf{e_{i}} = \left( \mathbf{x_{i}}-\mathbf{x_{j}} \right) / ||\mathbf{x_{i}}-\mathbf{x_{j}} || \).</p>
<p>Procedure:</p>
<ul>
<li>Go through all the node couples that are selected to be packing in function</li>
<li>For each node pair id0 and id1, calculate the distance \( d \) and the unit normal between them</li>
<li>If the distance between the node pair is zero, then set the distance to the zero threshold value set in the function, to avoid division by zero.</li>
<li>Shift the distance by \( d_{0} \), such that the sigmoid is 0.5 at this distance. Currently \( d_{0} \) is set to 60 percent of <a class="el" href="classSimulation.html#afa0e72518548c938a0c4974e432f9d83" title="The threshold to detect packing nodes, scaled to average side length. ">Simulation::packingThreshold</a>. A shift of minimum of 50 per cent is necessary, as it will saturate the sigmoid at distance zero. A higher shift will make the saturation earlier, keeping a distance between nodes.</li>
<li>calculate the sigmoid value</li>
<li>Scale with average mass to obtain force per node. There is an additional multiplier that can be used to scale the force under specific conditions if desired.</li>
<li>Assign the forces in x, y and z directions with the normal</li>
<li>With the direction of the normal calculation, the algorithm will calculate \( \mathbf{F_{0}} \). \( \mathbf{F_{1}} \) is in the opposite direction. The forces are recorded on the <a class="el" href="classSimulation.html#a999a884533442902aa3a868f4c326a1c" title="The vector storing the packing forces applied on each node [Simulation::nNodes][3D]. ">Simulation::PackingForces</a> vector.</li>
</ul>

</div>
</div>
<a class="anchor" id="a3b2d417e1f2814ffd8e34c186508c2f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Simulation::calculatePackingForcesToEnclosingSurfacesImplicit3D </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate packing forces on nodes due to packing to enclosing surfaces. </p>
<p>See the documentation for <a class="el" href="classSimulation.html#a77e76f4fe61889b9c0ae18436a7fd2fb" title="Calculate packing forces on nodes due to packing to each other. ">Simulation::calculatePackingForcesImplicit3D</a>. The methodology is the same, with rigid wall positions in two z coordinates instead of a second node position.</p>

</div>
</div>
<a class="anchor" id="a07d76a2495e1b863ab0cdb7185821bec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Simulation::calculatePackingJacobian3D </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>K</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the system jaconbian with the derivatives of forces due to packing to each other, with respect to positions. </p>
<p>This function calculates the derivatives of packing forces between nodes with respect to nodal positions, and fills in hte Jacobian inside the Newton-Raphson iteration steps. The list of nodes that can potentially pack are detected in function , and recorded in and recorded in <a class="el" href="classSimulation.html#aeb78dddb085445b34d6ed6efee996183" title="The vector storing the Node::Id list of packing node couples, coupled with Simulation::pacingNodeCoup...">Simulation::pacingNodeCouples0</a> and <a class="el" href="classSimulation.html#ab67e69811ef54ec761cce2b4c76fb568" title="The vector storing the Node::Id list of packing node couples, coupled with Simulation::pacingNodeCoup...">Simulation::pacingNodeCouples1</a>.. The applied packing force is calculated in function <a class="el" href="classSimulation.html#a77e76f4fe61889b9c0ae18436a7fd2fb" title="Calculate packing forces on nodes due to packing to each other. ">Simulation::calculatePackingForcesImplicit3D</a>.</p>
<p>The derivatives are calculated as </p><p class="formulaDsp">
\[ \frac{d\mathbf{F_{i}}}{d\mathbf{x_{i}}} = \frac{f\left( d \right)}{d}\left( \mathbf{I} - \mathbf{e_{i}} \mathbf{e_{i}^{T}}\right) +\frac{df\left( d \right)}{dd} \mathbf{e_{i}} \mathbf{e_{i}^{T}} \]
</p>
<p> where distance \( d \) is \( ||\mathbf{x_{i}}-\mathbf{x_{j}} || \), the normal is \( \mathbf{e_{i}} = \left( \mathbf{x_{i}}-\mathbf{x_{j}} \right) / ||\mathbf{x_{i}}-\mathbf{x_{j}} || \), and \( \mathbf{I} \) is the identity matrix. The function \( f\left( d \right) \), linking the distance between the nodes is an inverse sigmoid function, detailed in <a class="el" href="classSimulation.html#a77e76f4fe61889b9c0ae18436a7fd2fb" title="Calculate packing forces on nodes due to packing to each other. ">Simulation::calculatePackingForcesImplicit3D</a>. Its derivative is then: </p><p class="formulaDsp">
\[ \frac{df\left( d \right)}{dd} = mass\:\frac{-2\:sigmoid\:saturation}{packing\:threshold} f\left( d \right) \left( 1 - f\left( d \right) \right) \]
</p>
<p> Procedure:</p>
<ul>
<li>Go through all the node couples that are selected to be packing in function</li>
<li>For each node pair id0 and id1, calculate the distance \( d \) and the unit normal between them</li>
<li>If the distance between the node pair is zero, then set the distance to the zero threshold value set in the function, to avoid division by zero.</li>
<li>Shift the distance by \( d_{0} \), such that the sigmoid is 0.5 at this distance. Currently \( d_{0} \) is set to 60 percent of <a class="el" href="classSimulation.html#afa0e72518548c938a0c4974e432f9d83" title="The threshold to detect packing nodes, scaled to average side length. ">Simulation::packingThreshold</a>. And calculate the sigmoid function value.</li>
<li>Shift the distance by \( d_{0} \), such that the sigmoid is 0.5 at this distance. Currently \( d_{0} \) is set to 60 percent of <a class="el" href="classSimulation.html#afa0e72518548c938a0c4974e432f9d83" title="The threshold to detect packing nodes, scaled to average side length. ">Simulation::packingThreshold</a>. And calculate the sigmoid function value. Calculate the derivative, leave the multiplication by the amplitude (mass) to the last stage.</li>
<li>Add the resulting 3 by 3 derivative matrices are added into the Jacobian in the form: <p class="formulaDsp">
\[ - \frac{d\mathbf{F_{0}}}{d\mathbf{x_{0}}} \:\: \rightarrow K \begin{bmatrix} &amp; \vdots &amp; \vdots &amp; \vdots &amp; \\ \dots &amp; x_{3id0,3id0} &amp; \dots &amp; x_{3id0,3id0+2} &amp; \dots \\ \dots &amp; \vdots &amp; \dots &amp; \vdots &amp; \dots \\ \dots &amp; x_{3id0+2,3id0} &amp; \dots &amp; x_{3id0+2,3id0+2} &amp; \dots \\ &amp; \vdots &amp; \vdots &amp; \vdots &amp; \end{bmatrix}, \]
</p>
 <p class="formulaDsp">
\[ \frac{d\mathbf{F_{0}}}{d\mathbf{x_{0}}} \:\: \rightarrow \begin{bmatrix} x_{3id0,3id1} &amp; \dots\\ \dots &amp; x_{3id0+2,3id1+2} \end{bmatrix}, -\frac{d\mathbf{F_{0}}}{d\mathbf{x_{0}}} \:\: \rightarrow \begin{bmatrix} x_{3id1,3id1} &amp; \dots\\ \dots &amp; x_{3id1+2,3id1+2} \end{bmatrix}, \frac{d\mathbf{F_{0}}}{d\mathbf{x_{0}}} \:\: \rightarrow \begin{bmatrix} x_{3id1,3id0} &amp; \dots\\ \dots &amp; x_{3id1+2,3id0+2} \end{bmatrix}. \]
</p>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a4b259e3827b74767c8005b2126191609"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Simulation::calculatePackingToEnclosingSurfacesJacobian3D </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>K</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the system jaconbian with the derivatives of forces due to packing to enclosing surfaces, with respect to positions. </p>
<p>See the documentation for <a class="el" href="classSimulation.html#a07d76a2495e1b863ab0cdb7185821bec" title="Update the system jaconbian with the derivatives of forces due to packing to each other...">Simulation::calculatePackingJacobian3D</a>. The methodology is the same, with rigid wall positions in two z coordinates instead of a second node position.</p>

</div>
</div>
<a class="anchor" id="af18305ef63492bb7e76f79c4c85206d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Simulation::calculatePackingToPipetteForcesImplicit3D </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate packing forces on nodes due to packing to pipette wall in pipette aspiration experiment. </p>
<p>See the documentation for <a class="el" href="classSimulation.html#a77e76f4fe61889b9c0ae18436a7fd2fb" title="Calculate packing forces on nodes due to packing to each other. ">Simulation::calculatePackingForcesImplicit3D</a>. The methodology is the same, with pipeete tip centre used instead of the second node.</p>

</div>
</div>
<a class="anchor" id="aeebe76bd38ce67afd3611ad521450c1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Simulation::calculatePackingToPipetteJacobian3D </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>K</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the system jaconbian with the derivatives of forces due to packing to the pipette wall in pipette aspiration experiment, with respect to positions. </p>
<p>See the documentation for <a class="el" href="classSimulation.html#a07d76a2495e1b863ab0cdb7185821bec" title="Update the system jaconbian with the derivatives of forces due to packing to each other...">Simulation::calculatePackingJacobian3D</a>. The methodology is the same, with pipette tip centre used instead of the second node.</p>

</div>
</div>
<a class="anchor" id="a8b40b6f71c115d9c566333151219a7d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Simulation::calculateStiffnessChangeRatesForActin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idOfCurrentStiffnessPerturbation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the stiffness change rates for actin with the stiffness perturbaiton function of input ID. </p>
<p>If the actin layer has perturbations, the elements are checked if they are influenced via <a class="el" href="classShapeBase.html#ae9cfd1ae56e018477dd3642d4d769d90" title="This function decides if the actin stiffness perturbation is applied to this element. ">ShapeBase::isActinStiffnessChangeAppliedToElement</a> and rates are set in this function via <a class="el" href="classShapeBase.html#aef460b84dc469f89742af7c19411454f" title="This function will calciulate the stiffness perturbation rate. ">ShapeBase::calculateStiffnessPerturbationRate</a>.</p>

</div>
</div>
<a class="anchor" id="ae096c8a7fcc6e921415d1be317526d02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Simulation::checkECMChange </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if there is ECM perturbation. </p>
<p>If there is explicit ECM, then first the compartment based perturbations are checked. Then each perturbation based on tissue placement, such as apical, basal or emergnt with markers, are checked. The stiffness, viscosity and half life updates are carried out via <a class="el" href="classShapeBase.html#a4eb97c0c1a988e77126809745b191c02" title="The function will update the actin multiplier as a result of stiffness perturbations. ">ShapeBase::updateStiffnessMultiplier</a>, ShapeBase::updateChangeForViscosityBasedECMDefinition, ShapeBase::updateChangeForExplicitECM and ShapeBase::updateECMRenewalHalflifeMultiplier.</p>

</div>
</div>
<a class="anchor" id="a1cf2aca93cb0f8716817936d98b6bf0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Simulation::checkEllipseAllocationWithCurvingNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the ellipse band allocation of nodes residing on fold initiation. </p>
<p>The emergent curved regions of the tissue are marked via ellipse ban ids. These bands can be defined by the user, as such marker ellipse band Ids 100, 101 and 102 are reserved for emergent band initiation. <br />
</p><ul>
<li>If a surface is on the apical fold initiation surface, then it acquires Id 100. <br />
</li>
<li>If a surface is on the basal fold initiation, then is acquires Id 101. <br />
</li>
<li>If there are emergent perturbations, and initiation of perturbation is conditional ( tissue shape change perturbation starts only after the ECM is reduced below a certain fraction of its original value), then the elements initially tagged 100 are updated to tag 102 once htis threshold (<a class="el" href="classSimulation.html#a5869e105b5d4d2e41c071f24988b314e" title="The threshold of ECM density upon which emergent shape change will be activated (reduction of ECM str...">Simulation::shapeChangeECMLimit</a>) is reached. The function <a class="el" href="classSimulation.html#aba7aa0ded1d2cd262ed08c8abddde4f8" title="Check for emergence of ellipse bands as a result of ECM loss. ">Simulation::checkForEllipseIdUpdateWithECMDegradation</a> will carry out this operation.</li>
</ul>

</div>
</div>
<a class="anchor" id="aba7aa0ded1d2cd262ed08c8abddde4f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Simulation::checkForEllipseIdUpdateWithECMDegradation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for emergence of ellipse bands as a result of ECM loss. </p>
<p>If there are emergent marker allocations, and initiation of a perturbation is conditional ( tissue shape change perturbation starts only after the ECM is reduced below a certain fraction of its original value), then the elements initially tagged 100 are updated to tag 102 once this threshold (<a class="el" href="classSimulation.html#a5869e105b5d4d2e41c071f24988b314e" title="The threshold of ECM density upon which emergent shape change will be activated (reduction of ECM str...">Simulation::shapeChangeECMLimit</a>) is reached.</p>

</div>
</div>
<a class="anchor" id="a49ebb11d5727f0a6fc3ebfe8166b7290"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Simulation::checkForEmergentEllipseFormation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for emergent marker elipse bands with fold initiation in the tissue. </p>
<p>The emergent marker ellipse Ids, reserved 100, 101 and 102, are assigned to curved surfaces of hte tissue. This information can be obtained via collapse of an elemental surface, or adhesion of two nodes. Once the identity is assigned, it can be updated to mark ECM relaxation threshold. The respnsible functions are <a class="el" href="classSimulation.html#a0e7040a8ecc377bd2e53c785fc4c488b" title="Update marker ellipses with collapsing nodes. ">Simulation::updateEllipseWithCollapse</a>, <a class="el" href="classSimulation.html#ae7642cf5d56f38710da9b219e56b3c77" title="Mark nodes as on fold, due to collapsed elements. ">Simulation::updateOnFoldNodesFromCollapse</a>, <a class="el" href="classSimulation.html#a1cf2aca93cb0f8716817936d98b6bf0e" title="Check the ellipse band allocation of nodes residing on fold initiation. ">Simulation::checkEllipseAllocationWithCurvingNodes</a>, <a class="el" href="classSimulation.html#a065f2150d785ee160762367bd6419e42" title="Check if elements at border of two emergent folds are missed in marking, and correct as needed...">Simulation::checkForLeftOutElementsInEllipseAssignment</a> and <a class="el" href="classSimulation.html#aba7aa0ded1d2cd262ed08c8abddde4f8" title="Check for emergence of ellipse bands as a result of ECM loss. ">Simulation::checkForEllipseIdUpdateWithECMDegradation</a>.</p>

</div>
</div>
<a class="anchor" id="a065f2150d785ee160762367bd6419e42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Simulation::checkForLeftOutElementsInEllipseAssignment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if elements at border of two emergent folds are missed in marking, and correct as needed. </p>
<p>When elements are assigned emergent marker identities, their nodes will follow. As a result, in densly folding regions, an element can have all its nodes assigned to a specific marker by its neighbours, without itself being assigned to it. These elements themselves will be tagged via their nodes.</p>

</div>
</div>
<a class="anchor" id="a361530c38e215fd901d5e8a0ef051386"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Simulation::checkStiffnessPerturbation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for stiffness perturbation on the tissue. </p>
<p>For all input stiffness perturbaitons, the perturbation activity time is checked from the <a class="el" href="classSimulation.html#a0a8d61383b2f51f2f98b72554b7e00cb" title="The current time of the simulation in time seconds, obtained as Simulation::currSimTimeSec = Simulati...">Simulation::currSimTimeSec</a> being between the selected <a class="el" href="classSimulation.html#a36cfc7d8043d1dad55751cf184bcb2b8" title="The vector storing the maximum stiffness change as a fraction of the original stiffness. ">Simulation::stiffnessPerturbationBeginTimeInSec</a> and <a class="el" href="classSimulation.html#a8b9dfbe4a63693a6cfdccfe9c0ee4771" title="The vector storing the stiffness perturbation initiation time points in sec. ">Simulation::stiffnessPerturbationEndTimeInSec</a>. If this is the first time the perturbation is being called (checked via Simulation::startedStiffnessPerturbation flag) then the rate is calculated via <a class="el" href="classSimulation.html#a8b40b6f71c115d9c566333151219a7d6" title="Calculate the stiffness change rates for actin with the stiffness perturbaiton function of input ID...">Simulation::calculateStiffnessChangeRatesForActin</a>. Then stiffnesses are uodated via <a class="el" href="classSimulation.html#aacaebdb527784f46f67232f3180936e1" title="Update stiffness of actin with the stiffness perturbaiton function of input ID. ">Simulation::updateStiffnessChangeForActin</a>.</p>

</div>
</div>
<a class="anchor" id="a7a47dfca0623a5636cb65416411cb901"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Simulation::correctzProjectedAreaForMidNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function corrects the z-projected areas for mid-l;ayer nodes, as their areas are counted twice, by both elements. </p>
<p>For the nodes in mid-line nodes the area is added from apical and basal surfaces of elemetns on both sides. This is corrected in this function. !! A more efficient approach would be to calculate these areas only once!!</p>

</div>
</div>
<a class="anchor" id="ab67230d22a5c07292574d10d5ee8fc13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Simulation::detectPacingNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect nodes potentially packing to each other. </p>
<p>The current distance of node-node packing is dependent on the local average side length and is sored in a 10x5 grid <a class="el" href="classSimulation.html#a0c55eae62bd214951ca78098e2daf7a4" title="The threshold to detect potentially packing nodes as a grid, scaled to local average side length...">Simulation::packingDetectionThresholdGrid</a>.</p>

</div>
</div>
<a class="anchor" id="ac1225a76f3acef7e6ecc175d386b6b86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Simulation::detectPacingToEnclosingSurfacesNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect nodes potentially packing to the enclosing surfaces in z. </p>
<p>The current disctance of packing surfaces are stored in <a class="el" href="classSimulation.html#a22bbc8742aed21f955c74c0ae2d60e59" title="Current z position of the enclosing surfaces [top][bottom]. ">Simulation::zEnclosementBoundaries</a>. The z distance of nodes to these surfaces are checked against the threshold for packing detection <a class="el" href="classSimulation.html#a95a1b9f341e5485d7c83e638062e1751" title="The distance threshold for packing to nodes to surfaces. ">Simulation::packingDetectionToEnclosingSurfacesThreshold</a>. The actual forces of packing are not calculate4d here, this is for detection of potentially packing nodes.</p>

</div>
</div>
<a class="anchor" id="a97927bd45513fc16d7dd56b9e8474f4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Simulation::detectPackingToPipette </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect nodes potentially packing to the pipette wall in pipette aspiration experiment. </p>
<p>The current tip of the pipette is defined as the range starting <a class="el" href="classSimulation.html#a9c0a8edcc987294ad36dc43cb0b2c77c" title="The inner radius of the pipette. ">Simulation::pipetteInnerRadius</a> going for <a class="el" href="classSimulation.html#a330bde4b57359e57318c1105edde06c5" title="The thickness of the pipette. ">Simulation::pipetteThickness</a>, and the centre of the pipette tip is recorded in <a class="el" href="classSimulation.html#a80ba175cfd0377ddab49a0058139f03c" title="The centre of the pipette tip [x][y][z]. ">Simulation::pipetteCentre</a>. Any node falling within this threshold on the corect surface can potentially pack to the pipette.</p>

</div>
</div>
<a class="anchor" id="a6ef90fd76ed4f6bb9d063e7e72e9a983"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Simulation::initiateSavedSystem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initiates a saved system from save files. </p>
<p>This function follows the logic of the <a class="el" href="classSimulation.html#ae44910ca27d6ec5eaa48f7136fad87ea" title="This function initiates the system with model inputs. ">Simulation::initiateSystem</a> function, please refer to its documentation for details. The element and node properties are read from saveed files where available.</p>

</div>
</div>
<a class="anchor" id="ae44910ca27d6ec5eaa48f7136fad87ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Simulation::initiateSystem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initiates the system with model inputs. </p>
<p>If the mesh type is 2, then a mesh with selected number of rows and columns will be initiated. This is the default option is no input file is provided to the system.</p>
<p>Most commonly used input mesh type requires an input mesh file.</p>
<p>If there is symetricity in the system, a checkpoint for circumferential node definitions is in place. The symmetricity boundary should not be considered as at the outer circumference.</p>
<p>Then the existance of the peripodial membrane in the system is checked.</p>
<p>The tissue height is calculated and the tissue bounding box is obtained. Then the relative z positions of the elements are calculated.</p>
<p>At this point consistency is checked again to see if the model inputs necessiate a peripodial membane, and if they do, if it has been implemented.</p>
<p>If the model inputs enable an explicit definition of extracellular matrix, this is labelled on the mesh here via Simulation::setUpECMMimicingElements.</p>
<p>If the model inputs enable an explicit definition of an actin rich top layer, this is labelled on the mesh here via Simulation::setUpActinMimicingElements.</p>
<p>Then element neighbourhoods are filled in.</p>
<p>The simulation can fix degrees of freedom for certain nodes, as boundary condition. These node fixing options are set up via function Simulation::checkForNodeFixing.</p>
<p>The tip nodes are assigned via <a class="el" href="classSimulation.html#a7ed75e3d044166072754e6e323f3604c" title="This function assigns the nodes marking the tips of the tissue in xy plane. ">Simulation::assignTips</a>.</p>
<p>If all the initiation setup conpleted without errors up to this point, then the mesh is characterised with flags, and now the actual physical parametrs are set up. First the system forces matrix is set with the sytem node size, via function Simulation::initiateSystemForces. Then the system center is calcualted, and physical parameters are assigned to the elements via Simulation::assignPhysicalParameters. <br />
</p>
<p>Once the viscoelastic properties are set, thje system is checked against zero external viscosity. If there is no external viscosity in the system, then additional boundry conditions should e implemented to reach a unique solution in the NR iteration to solve for nodal displacements. Oncce viscosities are updated, the node massess, and the surfaces that are expoed the the external friction are set in Simulation::assignNodeMasses, Simulation::assignElementalSurfaceAreaIndices, and Simulation::assignConnectedElementsAndWeightsToNodes functions.</p>
<p>Then the boiunding box of the tissue is calculated and the relative positions are set.</p>
<p>If there are any additional manipulations, they are implemented next. Thee include growth mutant induction, experiemtal stretcher attachement, experimental pippete aspiration setup, and setting up symettic axes of the tissue to have fixed boundaries, and assigningn labelling by ellipse bands for further manipulation if these are implemented.</p>
<p>If the simultion is continuing from an already saved setup (Simualtion::ContinueFromSave = true), the last frame of the save is read via Simulation::readFinalSimulationStep.</p>
<p>If data is being saved, then the simulation summary will be written next.</p>
<p>Fianlly, the Newton Raphson solver object is initiated, and node DoF bonding as boundary condition is checked.</p>

</div>
</div>
<a class="anchor" id="aa5c031b9d4c6b3d74f636adec0b695ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Simulation::readExecutableInputs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads the input executables from user input. </p>
<p>The mode of simulation can be "DisplaySave","SimulationOnTheGo" or "ContinueFromSave". As the nemas suggest, "DisplaySave" option will dsplay a simulation from saved files, without running the simulation. "SimulationOnTheGo" will start a fresh simulation and "ContinueFromSave" will continue simulating from a save file.<br />
</p>
<p>The tag "-i" defines the input file, this should be a modelinput file detailing the parameters of the simulation.<br />
</p>
<p>If the input file requires saving, then an output direcotry should be specified with the "-od" tag.</p>
<p>In case of simulations contining from save or when the tool is called to display an existing simulation, the input directory should be specified, with the tag "-dInput".</p>

</div>
</div>
<a class="anchor" id="a300713fd91c15b51421606bffd6d87b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Simulation::runOneStep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the simulation for one time step. </p>
<p>The core function in the <a class="el" href="classSimulation.html">Simulation</a> class is the function to update the whole system from one time step to the next.</p>
<p>The process starts by resetting all forces of the current time step via <a class="el" href="classSimulation.html#a5c0989e1c64b0fde348701454e9fbf67" title="This function resets all forces to zero at the beginning of each iteration. Depending on the packing ...">Simulation::resetForces</a>. Then emergent marker initiation is checked, (<a class="el" href="classSimulation.html#a49ebb11d5727f0a6fc3ebfe8166b7290" title="Check for emergent marker elipse bands with fold initiation in the tissue. ">Simulation::checkForEmergentEllipseFormation</a>) as this could initiate physical property changes and should be carried out before the relavent updates. <br />
</p>
<p>Then the relative position updates of the tissue are carreid out. First the tissue long axis is aligned on the x axis (<a class="el" href="classSimulation.html#a91a12f6ac1b230cecbe004221326a7ca" title="Align tissue DV axis to x axis, the DV axis is defiend by Simulation::ventralTipIndex and Simulation:...">Simulation::alignTissueDVToXPositive</a>), then the bounsing box is calculated (ShapeBase::calculateBoundingBox), and the relative positions of apical (top layer) elements are obtained (<a class="el" href="classShapeBase.html#a04278729ad9cc3238b1966ade0685a3d" title="This function will calculate the relative positions of the element in the xy-plane bounding box of th...">ShapeBase::calculateRelativePosInBoundingBox</a>). The relative positions of the midline and bottom elements are updated to be the same as the apical layer, as growth should not differ in the z-axis, the relative positions should read the same grid point from growth maps.</p>
<p>Any experimental setup, that requires an update prior to entring the NR iterations for the time step are carried out by the function <a class="el" href="classSimulation.html#aa9ad0627365ad5d465b273183c7db344" title="This macro function checks for all experimental setup updates at the beginning of a time step...">Simulation::checkForExperimentalSetupsBeforeIteration</a>. This is folllowed by any existing perturbation on physical properties, through functions <a class="el" href="classSimulation.html#a361530c38e215fd901d5e8a0ef051386" title="Check for stiffness perturbation on the tissue. ">Simulation::checkStiffnessPerturbation</a> and <a class="el" href="classSimulation.html#ae096c8a7fcc6e921415d1be317526d02" title="Check if there is ECM perturbation. ">Simulation::checkECMChange</a>. <br />
</p>
<p>Once the physical proerties are updated, the growth of each element is calculated. For growth functions based on reading gorwht maps (the main attribute utilised in morphogenesis simulations), the relative position in usecan be updated less frequently then each step, this update is checked in Simulation::checkForPinningPositionsUpdate. Then the rigid body rotations around z axis are extracted to be eliminated through ShapeBase::updateGrowthRotationMatrices. For all growth functions and induced mutant clones the growth is calculated in Simulation::calculateGrowth. Simularly, shape changes are updated via Simulation::calculateShapeChange. <br />
</p>
<p>Based on user preferences, the volumes of the elements can be conserved individually (default), or the volume can be conserved through the column, but volume exchange is allowed between elements of the same column, this is stated by the boolean <a class="el" href="classSimulation.html#a1dd66be606281f44c05ec6b4f8eed882" title="The boolean stating if the simulation is conserving the volume of each elemental column rather than e...">Simulation::conservingColumnVolumes</a> and operation is handled by the function Simulation::conserveColumnVolume. <br />
</p>
<p>Following potential volume exchange, the remodelling (plastic deformation) is updated. All explicit ECM elements (<a class="el" href="classShapeBase.html#a5e442b31d2341cbe477d7c33195a576c" title="Boolean stating if the element is an ECM element. ">ShapeBase::isECMMimicing</a> = true) do have remodelling by default. Remodelling of cellular elements (all the rest) can be defiend by the user preferences and is defined in <a class="el" href="classSimulation.html#ab0d54e9e505f3701cf5ca8b0ac0df00a" title="The boolean stating that there is plastic deformation (remodelling) in the tissue. ">Simulation::thereIsPlasticDeformation</a>. The remodelling function is <a class="el" href="classSimulation.html#aba920b0ae2806ea3890cbe2b819977fe" title="Update the plastic deformation (remodelling) of all nodes. ">Simulation::updatePlasticDeformation</a>.</p>
<p>The growth, shape change, volume exchange and remodelling all induce theri effects eventually through growth of the elements. Once all these options are covered, the elemetns are grown in <a class="el" href="classShapeBase.html#a29ee0eeca30fdd381d294b383c3baf0c" title="This function updates the current growth deformaiton gradient with the growt/shape change/plastic def...">ShapeBase::growShapeByFg</a>, which updated the growth deformation gradient of the element. <br />
</p>
<p>As the shape size is changed, nodal masses (volumes) (Simulation::updateNodeMasses) and exposed surfaces (Simulation::updateNodeViscositySurfaces) are updated, then the weight of each elements contribution on the nodes are updated (Simulation::updateElementToConnectedNodes). Then the collapse nodes positions are updated, if the collapse is being carried out in stages. <br />
</p>
<p>Then packing to all posssible surfaces are detected, while the actual packing forces are calculated in the NR iterations as they are position dependent. This initial check creates a list of potential packing nodes, to check only these through the NR itaration, rather than checking all nodes at all times. Packing is checked against self contact (<a class="el" href="classSimulation.html#ab67230d22a5c07292574d10d5ee8fc13" title="Detect nodes potentially packing to each other. ">Simulation::detectPacingNodes</a>) then to enclosing surfaces (<a class="el" href="classSimulation.html#ac1225a76f3acef7e6ecc175d386b6b86" title="Detect nodes potentially packing to the enclosing surfaces in z. ">Simulation::detectPacingToEnclosingSurfacesNodes</a>) and pipette (<a class="el" href="classSimulation.html#a97927bd45513fc16d7dd56b9e8474f4a" title="Detect nodes potentially packing to the pipette wall in pipette aspiration experiment. ">Simulation::detectPackingToPipette</a>) if they are implemented. <br />
</p>
<p>Then collapse of elemental surfaces are checked (Simulation::checkEdgeLenghtsForBindingPotentiallyUnstableElementss), and the NR solver is notified if there are changes made.</p>
<p>After the collapse check, the nodal adhesion is updated (Simulation::adhereNodes), makinguse of the detected packing, as any node couple close enough to adhere must be close enough to activate self-contact. <br />
</p>
<p>The actual positional updates are delegated to teh newton-Raphson solver object via function <a class="el" href="classSimulation.html#a6a869cb433953d1d36249460b0a74545" title="Update the positions with solving for the displacements with the N-R iterations. ">Simulation::updateStepNR</a>. <br />
</p>
<p>Once the positions are updated, the bounding box is calculated again, the elements are checked agains flipping (<a class="el" href="classSimulation.html#a7aa2db4c2819e37c0ded181d47467233" title="Check if any of the elements have flipped, and report error accordingly. ">Simulation::checkFlip</a>).</p>
<p>If there is aftificail relaxation defined by the user, this is done at the end of the time step via <a class="el" href="classSimulation.html#aee92b20e497b42f5b7a089c3f9409e97" title="Artificially relax all deformation on all elements at selected time point. ">Simulation::artificialRelax</a>.</p>
<p>Then the time step is updated, and the data is saved if necessary in Simulation::processDisplayDataAndSave.</p>

</div>
</div>
<a class="anchor" id="af0d9108d648996ef65a3eff0977a8590"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Simulation::updateChangeForExplicitECM </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idOfCurrentECMPerturbation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update physical properties of the ECM with the ECM perturbaiton function of input ID. </p>
<p>If the ECM has perturbationson elasticity, the elements are checked if they are influenced via <a class="el" href="classShapeBase.html#ab1572ddb1f68178e0607873a432f227c" title="This function decides if the ECM perturbation is applied to this element. ">ShapeBase::isECMChangeAppliedToElement</a>, the <a class="el" href="classShapeBase.html#a9cff4a8549b3399fec12309d18b6db70" title="Current stiffness multiplier of the element, initially 1.0, modulated by stiffness perturbations ///<...">ShapeBase::stiffnessMultiplier</a> is altered via <a class="el" href="classShapeBase.html#a4eb97c0c1a988e77126809745b191c02" title="The function will update the actin multiplier as a result of stiffness perturbations. ">ShapeBase::updateStiffnessMultiplier</a> and elastic property tensors are updated via <a class="el" href="classShapeBase.html#a018cc92b513ff64b919c374b0767cc1b" title="This functions updates elastic propertiesand their dependent tensors upon alteration of a physical pr...">ShapeBase::updateElasticProperties</a>.</p>

</div>
</div>
<a class="anchor" id="a6ac28dca8cca35baed5b75ce4f8062c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Simulation::updateChangeForViscosityBasedECMDefinition </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idOfCurrentECMPerturbation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update ECM viscosity with the ECM perturbaiton function of input ID. </p>
<p>If the ECM has perturbations on viscosity, the nodes are checked if they are influenced via <a class="el" href="classNode.html#af754322e3928dc45f70b19762551890a" title="The tissue placement is 0 for basal nodes, 1 for apical nodes, and 2 for middle range. ">Node::tissuePlacement</a> and <a class="el" href="classSimulation.html#aa8c12a070e93fd1cd504f98aed28c9fa" title="Boolean stating if the basal ECM should be affected by perturbation. ">Simulation::changeBasalECM</a> - <a class="el" href="classSimulation.html#a082e87b4a29d83f54866ac085e188d92" title="Boolean stating if the apical ECM should be affected by perturbation. ">Simulation::changeApicalECM</a> boolean arrays, as well as the marker ellipse Ids. The visocisties of each node are updated via <a class="el" href="classNode.html#a58afaee3d71a2c122396265c91acda04" title="The change in ECM viscosity per one hour. The double array of size (1,3) stores the viscosity change ...">Node::ECMViscosityChangePerHour</a> and the time step <a class="el" href="classSimulation.html#a0ee381efb3458d02bf78487cbb4dc42a" title="The time step increment in seconds, such that Simulation::currSimTimeSec = Simulation::dt * Simulatio...">Simulation::dt</a> (in sec). Once new viscosity is calculated, it is capped to be positive and at most equal to the maximum external viscosity.</p>

</div>
</div>
<a class="anchor" id="a2308c071a7f6260910d76d4a8604a0a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Simulation::updateECMRenewalHalflifeMultiplier </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idOfCurrentECMPerturbation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update ECM renewal half-life with the ECM perturbaiton function of input ID. </p>
<p>If there is perturbation on ECM renewal halflife, the type of perturbation emergence is checked, if the perturbation initiation is emergend based on topology (active at fold grove basal sides), then the rate is calculated from the total application time.</p>

</div>
</div>
<a class="anchor" id="a0e7040a8ecc377bd2e53c785fc4c488b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Simulation::updateEllipseWithCollapse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update marker ellipses with collapsing nodes. </p>
<p>If there is an apical collapse of nodes, then this elemetn must be on a curving surface, thus the emergent marker ids are updated. The element is not checked if it is already assigned to a fold via emergent mariking (<a class="el" href="classShapeBase.html#a8d2b9ded0e51df7c23499ccc3f4da9fc" title="The unique ID of the covering perturbation band. ">ShapeBase::coveringEllipseBandId</a> is 100 or 101). Lateral ECM elements are not modified. If the element is not already assigned to an emergent marker group (on fold initiation), then its collapse status is checked via <a class="el" href="classShapeBase.html#a346f4ec76554bea282a5cab7ea28dfa2" title="This function checks if any of the edges of the element is shortened to the extent that it should be ...">ShapeBase::checkForCollapsedNodes</a>.</p>

</div>
</div>
<a class="anchor" id="aea943e8e0caf1b9ff8e40b61248024b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Simulation::updateNodePositionsNR </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>uk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update nodal positions during one iteration of the NR numerical solving for the displacements. </p>
<p>The nodal positions vector contains each position of each node in a single vector, and indexing is carried out accordingly.</p>

</div>
</div>
<a class="anchor" id="ae7642cf5d56f38710da9b219e56b3c77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Simulation::updateOnFoldNodesFromCollapse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark nodes as on fold, due to collapsed elements. </p>
<p>When an element collapses its nodes, it is a sign that it is residing on a fold. These elements assign their nodes to be on folds, by flagging the boolean Node::onFold.</p>

</div>
</div>
<a class="anchor" id="aba920b0ae2806ea3890cbe2b819977fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Simulation::updatePlasticDeformation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the plastic deformation (remodelling) of all nodes. </p>
<p>The ezplicitely defined ECM elements are always subject to non-volume econserving plastic deformation. The remodelling is calculated by ShaopeBase::calculatePlasticDeformation3D.</p>
<p>If there is user prefered remodelling on elements other than the ECM then the <a class="el" href="classShapeBase.html#a1d56f7eb3fed744adc268bc4da7a790f" title="The tissue type is 000 for columnar layer, 1 for peripodial membrane, and 2 for linker zone...">ShapeBase::tissueType</a> is chacked agains the parameters <a class="el" href="classSimulation.html#a42218fdf4e2a624fd4886edb39125251" title="The boolean stating that plastic deformation (remodelling) is applied to columnar tissue...">Simulation::plasticDeformationAppliedToColumnar</a> and <a class="el" href="classSimulation.html#abf2cb97bd129a14b21e15b742af8768c" title="The boolean stating that plastic deformation (remodelling) is applied to peripodial tissue...">Simulation::plasticDeformationAppliedToPeripodial</a>. The parameters of the <a class="el" href="classShapeBase.html#aa1c9eda4ef1eb0b23620235039bab921" title="This function calculates the plastic deformation (remodelling) from the current elastic deformation g...">ShapeBase::calculatePlasticDeformation3D</a> are again defined by the user, such as the <a class="el" href="classSimulation.html#a0e44e881245a507dc96188a8934b3bcc" title="The boolean stating if volume is conserved during plastic deformation (remodelling). ">Simulation::volumeConservedInPlasticDeformation</a>, <a class="el" href="classSimulation.html#a1aeea82e56a6523f2918583af1ecdd1a" title="The half life or plastic deformation (remodelling). ">Simulation::plasticDeformationHalfLife</a> <a class="el" href="classSimulation.html#a28126585484ed0c7676c880cfe92f991" title="The lower threshold of z remodelling, below which an element cannot be shrunk in z, fraction. ">Simulation::zRemodellingLowerThreshold</a> and <a class="el" href="classSimulation.html#ab455f57038010e1d9c6694eb99ddca8e" title="The lower threshold of z remodelling, below which an element cannot be extended in z...">Simulation::zRemodellingUpperThreshold</a>. See function documentation for further details.</p>
<p>If there is no remodelling, then the elements plastic deformation increment is set to identity in <a class="el" href="classShapeBase.html#aa36cea09cbf418a9e37454016c5b3f30" title="This function sets diagonal of the plastic deformation gradient increment from input values...">ShapeBase::setPlasticDeformationIncrement</a>.</p>

</div>
</div>
<a class="anchor" id="a6a869cb433953d1d36249460b0a74545"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Simulation::updateStepNR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the positions with solving for the displacements with the N-R iterations. </p>
<p>The iteration will be carried out for 20 steps, if upon 20 trials the simulation have not converged, an error will be generated. The iteration starts by clearing all force, displacement and Jacobian matrices of the NR solver in <a class="el" href="classNewtonRaphsonSolver.html#a3d01456ea07e72b0f02ae2e8d2b8ec9e" title="The function setting the calculation matrices to zero at the beginning of each iteration. ">NewtonRaphsonSolver::setMatricesToZeroAtTheBeginningOfIteration</a>. Then the vector containing the positions of teh nodes at the end of the previous time step "n", \( \boldsymbol{u_n} \) is calculated in <a class="el" href="classNewtonRaphsonSolver.html#af759360cc54ea9515deb3cc2ecc83377" title="This function constructs NewtonRaphsonSolver::un matrix at the beginning of the iterations. ">NewtonRaphsonSolver::constructUnMatrix</a>. The positions of the current iteration "k", \( \boldsymbol{u_k} \) are initiated equal to \( \boldsymbol{u_n} \) via <a class="el" href="classNewtonRaphsonSolver.html#a48b7753542f36889cd030104937d76a3" title="This function initiates NewtonRaphsonSolver::uk matrix at the beginning of the iterations, it is initiated to be equal to NewtonRaphsonSolver::un. ">NewtonRaphsonSolver::initialteUkMatrix</a>. <br />
</p>
<p>While the system has not converged, all the forces are rest at the beginning of each iteration with <a class="el" href="classSimulation.html#a5c0989e1c64b0fde348701454e9fbf67" title="This function resets all forces to zero at the beginning of each iteration. Depending on the packing ...">Simulation::resetForces</a>. Then the matrices to be cumulated from scratch in each iteration are reset in <a class="el" href="classNewtonRaphsonSolver.html#a36d647a13f9942e90e288a42c5444c4d" title="The function setting the relevant matrices to zero at each iteration. ">NewtonRaphsonSolver::setMatricesToZeroInsideIteration()</a>. The displacement matrix per time step <a class="el" href="classSimulation.html#a0ee381efb3458d02bf78487cbb4dc42a" title="The time step increment in seconds, such that Simulation::currSimTimeSec = Simulation::dt * Simulatio...">Simulation::dt</a> is calculated for use in external viscous forces in <a class="el" href="classNewtonRaphsonSolver.html#aa0ce333a40397fd113f9b9fc47bcb6ca" title="This function calculates the displacement of each node in current iteration &quot;k&quot;, from their positions...">NewtonRaphsonSolver::calculateDisplacementMatrix</a>. Then all the internal elemental and nodal forces are calculated in <a class="el" href="classNewtonRaphsonSolver.html#a5793ee41a3a4d97c0c944347f1f6da8e" title="This function calculates elemental forces and Jacobians, later to be combined in NewtonRaphsonSolver:...">NewtonRaphsonSolver::calculateForcesAndJacobianMatrixNR</a>. The forces are moved from the elements and nodes to the system vectors in <a class="el" href="classNewtonRaphsonSolver.html#aca7345c1d02bf38b1c36cf1f5110f869" title="This function writes the values of elemental elastic (ShapeBase::ge) and internal viscous forces (Sha...">NewtonRaphsonSolver::writeForcesTogeAndgvInternal</a>, the elastic and viscous terms of the elemental Jacobians are mapped and added onto the system Jacobian in <a class="el" href="classNewtonRaphsonSolver.html#a0d6e3a4d0cf1c6e4fdf2753c7f08df13" title="This function writes the elemental values for elastic part of the Jacobian - stiffness matrix - (Shap...">NewtonRaphsonSolver::writeImplicitElementalKToJacobian</a>. The external forces are calculated in <a class="el" href="classNewtonRaphsonSolver.html#ad39200f7babf1a3761a010c1a43f7c22" title="This function calculates the external viscous forces acting on each node, the values are sotred in Ne...">NewtonRaphsonSolver::calculateExternalViscousForcesForNR</a> and their derivatives are added to the system Jacobian in <a class="el" href="classNewtonRaphsonSolver.html#a78759a96ed41bf35e8401b7c63180ea2" title="This function adds the external related terms of the Jacobian to the system Jacobian NewtonRaphsonSol...">NewtonRaphsonSolver::addImplicitKViscousExternalToJacobian</a>. <br />
</p>
<p>If the packing forces calculated implicitely (default) they are updated via <a class="el" href="classSimulation.html#a77e76f4fe61889b9c0ae18436a7fd2fb" title="Calculate packing forces on nodes due to packing to each other. ">Simulation::calculatePackingForcesImplicit3D</a> and the corresponding Jacobian update is carried out with <a class="el" href="classSimulation.html#a07d76a2495e1b863ab0cdb7185821bec" title="Update the system jaconbian with the derivatives of forces due to packing to each other...">Simulation::calculatePackingJacobian3D</a>. The packing for enclosing surfaces and the pipette are also carried out here (<a class="el" href="classSimulation.html#a3b2d417e1f2814ffd8e34c186508c2f2" title="Calculate packing forces on nodes due to packing to enclosing surfaces. ">Simulation::calculatePackingForcesToEnclosingSurfacesImplicit3D</a>, <a class="el" href="classSimulation.html#a4b259e3827b74767c8005b2126191609" title="Update the system jaconbian with the derivatives of forces due to packing to enclosing surfaces...">Simulation::calculatePackingToEnclosingSurfacesJacobian3D</a>, <a class="el" href="classSimulation.html#af18305ef63492bb7e76f79c4c85206d0" title="Calculate packing forces on nodes due to packing to pipette wall in pipette aspiration experiment...">Simulation::calculatePackingToPipetteForcesImplicit3D</a> and <a class="el" href="classSimulation.html#aeebe76bd38ce67afd3611ad521450c1f" title="Update the system jaconbian with the derivatives of forces due to packing to the pipette wall in pipe...">Simulation::calculatePackingToPipetteJacobian3D</a>).</p>
<p>All the internal forces and the external viscous resistance forces are collated in <a class="el" href="classNewtonRaphsonSolver.html#a843bd105e92dfa1c9205e4efa134a406" title="The matrix containing sum of NewtonRaphsonSolver::ge, NewtonRaphsonSolver::gvInternal, NewtonRaphsonSolver::gvExternal, NewtonRaphsonSolver::gExt. Organisation is [Node0,x ; Node0,y ; Node0,z; ... ; Noden,x ; Noden,y ; Noden,z]. ">NewtonRaphsonSolver::gSum</a> via <a class="el" href="classNewtonRaphsonSolver.html#aba9098983f90b6237a9d32ea633bcb7f" title="This function adds the ealsticity and viscosity related forces (NewtonRaphsonSolver::ge, NewtonRaphsonSolver::gvInternal, NewtonRaphsonSolver::gvExternal) to sum of forces, NewtonRaphsonSolver::gSum. ">NewtonRaphsonSolver::calculateSumOfInternalForces</a>. The external forceas from the pipette suction if set up, all packing, and random forces if assigned are collated in <a class="el" href="classNewtonRaphsonSolver.html#afee5ceb54c8d439c1044ad3997d079ea" title="The matrix containing external forces on each node (currently includes packing forces), size (nDim*nNodes,1). Organisation is [Node0,x ; Node0,y ; Node0,z; ... ; Noden,x ; Noden,y ; Noden,z]. ">NewtonRaphsonSolver::gExt</a>, and these are added to system forces in <a class="el" href="classNewtonRaphsonSolver.html#a24f8fb47b9c29dd9856228ba0602f69e">NewtonRaphsonSolver::addExernalForces()</a>. <br />
</p>
<p>Once all forces and their derivatives are collated in system forces and Jacobian, then degrees of freedom fixing is reflected on these matrices in <a class="el" href="classNewtonRaphsonSolver.html#acfaaed8f038167756f352b566b8455d7" title="This function updates the Jacobian to account for nodes that are fixed in certain dimensions in space...">NewtonRaphsonSolver::calcutateFixedK</a> and <a class="el" href="classNewtonRaphsonSolver.html#aa1e2ec4519853c9acfaf120c4b513651" title="This function updates the Jacobian of the system, NewtonRaphsonSolver::K, to reflect degrees of freed...">NewtonRaphsonSolver::calculateBoundKWithSlavesMasterDoF</a>.</p>
<p>Then <a class="el" href="classNewtonRaphsonSolver.html#a8efb09b253b7d19bd978296314d65c24" title="This function solves for the displacements within the N-R step. ">NewtonRaphsonSolver::solveForDeltaU</a> function arranges the matrices and solves for the incremental displacements via PARDISO sparse matrix solver. The convergence is checked via the norm of incremental displacements in <a class="el" href="classNewtonRaphsonSolver.html#a3653a563e32649e0c90407aa089a995b" title="Check for cenvergence with the norm of displacements vector,against the threshold NewtonRaphsonSolver...">NewtonRaphsonSolver::checkConvergenceViaDeltaU</a>, the position of the nodes in the iteration,  $ {u_k}  $ are updated in <a class="el" href="classNewtonRaphsonSolver.html#a5e457b3608c6fbd71767cd6eed07b2f7" title="Calulate the nodal displacemetns at the kth iteration of NR dolver. ">NewtonRaphsonSolver::updateUkInIteration</a>. The nodal and elemental positions are updated (<a class="el" href="classSimulation.html#aed6fc494b468ebd56c07625d3e5984ff" title="Update elemental positions during one iteration of the NR numerical solving for the displacements...">Simulation::updateElementPositionsinNR</a>, <a class="el" href="classSimulation.html#aea943e8e0caf1b9ff8e40b61248024b6" title="Update nodal positions during one iteration of the NR numerical solving for the displacements. ">Simulation::updateNodePositionsNR</a>) with the new node positions of the iteration.</p>

</div>
</div>
<a class="anchor" id="aacaebdb527784f46f67232f3180936e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Simulation::updateStiffnessChangeForActin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idOfCurrentStiffnessPerturbation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update stiffness of actin with the stiffness perturbaiton function of input ID. </p>
<p>If the actin layer has perturbations, the elements are checked if they are influenced via <a class="el" href="classShapeBase.html#ae9cfd1ae56e018477dd3642d4d769d90" title="This function decides if the actin stiffness perturbation is applied to this element. ">ShapeBase::isActinStiffnessChangeAppliedToElement</a>, the <a class="el" href="classShapeBase.html#a9cff4a8549b3399fec12309d18b6db70" title="Current stiffness multiplier of the element, initially 1.0, modulated by stiffness perturbations ///<...">ShapeBase::stiffnessMultiplier</a> is altered via <a class="el" href="classShapeBase.html#a4eb97c0c1a988e77126809745b191c02" title="The function will update the actin multiplier as a result of stiffness perturbations. ">ShapeBase::updateStiffnessMultiplier</a> and elastic property tensors are updated via <a class="el" href="classShapeBase.html#a018cc92b513ff64b919c374b0767cc1b" title="This functions updates elastic propertiesand their dependent tensors upon alteration of a physical pr...">ShapeBase::updateElasticProperties</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ae03ad5c7859265aa5eb4d03d2e1f73d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; Simulation::numberOfStiffnessPerturbationAppliesEllipseBands</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The vector storing the stiffness perturbation end time points in sec. </p>
<p>The number of marker ellipse band ids the perturbation is applied to. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/melda/Documents/nonAcademic/TissueFoldingFefractor/TissueFoldingRefractor/TissueFoldingLinux/TissueFolding/SourceCode/<a class="el" href="Simulation_8h_source.html">Simulation.h</a></li>
<li>/home/melda/Documents/nonAcademic/TissueFoldingFefractor/TissueFoldingRefractor/TissueFoldingLinux/TissueFolding/SourceCode/Simulation.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classSimulation.html">Simulation</a></li>
    <li class="footer">Generated on Wed May 29 2019 16:14:30 for Tissue Origami by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
