<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Tissue Origami: Node Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tissue Origami
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classNode.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classNode-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Node Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="Node_8h_source.html">Node.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4cb4e49e312b20b6d1b11e15d6a8a0e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cb4e49e312b20b6d1b11e15d6a8a0e3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a4cb4e49e312b20b6d1b11e15d6a8a0e3">Node</a> (int id, int dim, std::array&lt; double, 3 &gt; pos, int tissuePos, int <a class="el" href="classNode.html#ae621097f98f1d33d283cf65a0a02d29a">tissueType</a>)</td></tr>
<tr class="memdesc:a4cb4e49e312b20b6d1b11e15d6a8a0e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructer of the node. <br /></td></tr>
<tr class="separator:a4cb4e49e312b20b6d1b11e15d6a8a0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab165125d2f0e60b9030468a4152c3ccb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab165125d2f0e60b9030468a4152c3ccb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ab165125d2f0e60b9030468a4152c3ccb">haveCommonOwner</a> (<a class="el" href="classNode.html">Node</a> *nodeSlave)</td></tr>
<tr class="memdesc:ab165125d2f0e60b9030468a4152c3ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function to check if the node pointed by the input pointer (nodeSlave) has common owner with this node (returns boolean). <br /></td></tr>
<tr class="separator:ab165125d2f0e60b9030468a4152c3ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d23c3e39f6de623ed0aad9bc225c14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52d23c3e39f6de623ed0aad9bc225c14"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a52d23c3e39f6de623ed0aad9bc225c14">getCommonOwnerId</a> (<a class="el" href="classNode.html">Node</a> *nodeSlave)</td></tr>
<tr class="memdesc:a52d23c3e39f6de623ed0aad9bc225c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function to return the <a class="el" href="classShapeBase.html#ae097764dd4d607b54710d7ca0f7e12f8" title="The unique ID of the element, without remodelling, equal to its indes on the Simulation::Elements vec...">ShapeBase::Id</a> the owner element this node shares with the node pointed by the input pointer (nodeSlave). <br /></td></tr>
<tr class="separator:a52d23c3e39f6de623ed0aad9bc225c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae4720965b558b075a91af4cf742b2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#adae4720965b558b075a91af4cf742b2a">setExternalViscosity</a> (double ApicalVisc, double BasalVisc, bool extendExternalViscosityToInnerTissue)</td></tr>
<tr class="memdesc:adae4720965b558b075a91af4cf742b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function to set the viscosity of the node.  <a href="#adae4720965b558b075a91af4cf742b2a">More...</a><br /></td></tr>
<tr class="separator:adae4720965b558b075a91af4cf742b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc5a9838a0a1963e58f648c5f7cb635"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a7dc5a9838a0a1963e58f648c5f7cb635">checkIfNeighbour</a> (int IdToCheck)</td></tr>
<tr class="memdesc:a7dc5a9838a0a1963e58f648c5f7cb635"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function to check if the node with input Id (IdToCheck) is an immediate neighbour of the node.  <a href="#a7dc5a9838a0a1963e58f648c5f7cb635">More...</a><br /></td></tr>
<tr class="separator:a7dc5a9838a0a1963e58f648c5f7cb635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d80e6f467d8ca919872b6e47a882dd5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a1d80e6f467d8ca919872b6e47a882dd5">checkIfNodeHasPacking</a> ()</td></tr>
<tr class="memdesc:a1d80e6f467d8ca919872b6e47a882dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function to check if the node is eligible for packing.  <a href="#a1d80e6f467d8ca919872b6e47a882dd5">More...</a><br /></td></tr>
<tr class="separator:a1d80e6f467d8ca919872b6e47a882dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6a8e48ca7eda39cfb4b83699181cce"><td class="memItemLeft" align="right" valign="top">std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a7c6a8e48ca7eda39cfb4b83699181cce">getCurrentPosition</a> ()</td></tr>
<tr class="memdesc:a7c6a8e48ca7eda39cfb4b83699181cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the current position of the node  <a href="#a7c6a8e48ca7eda39cfb4b83699181cce">More...</a><br /></td></tr>
<tr class="separator:a7c6a8e48ca7eda39cfb4b83699181cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3030a518aa97bd50060b8733e87540f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a3030a518aa97bd50060b8733e87540f7">displayConnectedElementIds</a> ()</td></tr>
<tr class="memdesc:a3030a518aa97bd50060b8733e87540f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will print out a list of connected element Id's.  <a href="#a3030a518aa97bd50060b8733e87540f7">More...</a><br /></td></tr>
<tr class="separator:a3030a518aa97bd50060b8733e87540f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755e8c3d76e7f1f0ab364fc3d4da3a9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a755e8c3d76e7f1f0ab364fc3d4da3a9a">displayConnectedElementWeights</a> ()</td></tr>
<tr class="memdesc:a755e8c3d76e7f1f0ab364fc3d4da3a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will print out the weights of the connected elements, in the order of Id s given in connectedElementIds.  <a href="#a755e8c3d76e7f1f0ab364fc3d4da3a9a">More...</a><br /></td></tr>
<tr class="separator:a755e8c3d76e7f1f0ab364fc3d4da3a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d2419d4de14f0d0ecffc7c7809e705"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39d2419d4de14f0d0ecffc7c7809e705"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a39d2419d4de14f0d0ecffc7c7809e705">displayPosition</a> ()</td></tr>
<tr class="memdesc:a39d2419d4de14f0d0ecffc7c7809e705"><td class="mdescLeft">&#160;</td><td class="mdescRight">The helper function to display the position of the node during debugging or in catasthropic failure. <br /></td></tr>
<tr class="separator:a39d2419d4de14f0d0ecffc7c7809e705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2838f50304007a7cfe3df3f2e8d1772"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ac2838f50304007a7cfe3df3f2e8d1772">addToImmediateNeigs</a> (int newNodeId)</td></tr>
<tr class="memdesc:ac2838f50304007a7cfe3df3f2e8d1772"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function adds the input node Id (int) to the list of neighbours of the node (<a class="el" href="classNode.html#adac7d84db546cadec7a8193e6ff52bd6" title="The list of Id&#39;s for immediate neighbours of the node, i.e. the nodes that are shared by the elements...">Node::immediateNeigs</a>)  <a href="#ac2838f50304007a7cfe3df3f2e8d1772">More...</a><br /></td></tr>
<tr class="separator:ac2838f50304007a7cfe3df3f2e8d1772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6f029aa3388b8fb122139b1d24b71b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a2c6f029aa3388b8fb122139b1d24b71b">addToConnectedElements</a> (int newElementId, double volumePerNode)</td></tr>
<tr class="memdesc:a2c6f029aa3388b8fb122139b1d24b71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function adds the input newElementId (int) to the list of elements connected by this node, updating the mass, and weights of mass per connected element in the process.  <a href="#a2c6f029aa3388b8fb122139b1d24b71b">More...</a><br /></td></tr>
<tr class="separator:a2c6f029aa3388b8fb122139b1d24b71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc9c26deadb9d2ca3e248f4748d9dfc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a6dc9c26deadb9d2ca3e248f4748d9dfc">removeFromConnectedElements</a> (int newElementId, double volumePerNode)</td></tr>
<tr class="memdesc:a6dc9c26deadb9d2ca3e248f4748d9dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function removes the input newElementId (int) from the list of elements connected by this node, updating the mass, and weights of mass per connected element in the process.  <a href="#a6dc9c26deadb9d2ca3e248f4748d9dfc">More...</a><br /></td></tr>
<tr class="separator:a6dc9c26deadb9d2ca3e248f4748d9dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1e7e6c42b377c073a68c2b2ea97fa8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#abc1e7e6c42b377c073a68c2b2ea97fa8">isMyNeig</a> (int nodeId)</td></tr>
<tr class="memdesc:abc1e7e6c42b377c073a68c2b2ea97fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function to check if the node with the input node id is a neighbour of this node (returns boolean).  <a href="#abc1e7e6c42b377c073a68c2b2ea97fa8">More...</a><br /></td></tr>
<tr class="separator:abc1e7e6c42b377c073a68c2b2ea97fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5ecd8e43cad8d619629d07bcaa1a8e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aaf5ecd8e43cad8d619629d07bcaa1a8e">isNeigWithMyCollapsedNodes</a> (int NodeId, const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes)</td></tr>
<tr class="memdesc:aaf5ecd8e43cad8d619629d07bcaa1a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function to check if the node with the input <a class="el" href="classNode.html#a1bd379569cc1a8b96432e61971aed4d9" title="The unique identification number of the node. ">Node::Id</a> (nodeId) is collapsed with a neighbour of this node (returns boolean).  <a href="#aaf5ecd8e43cad8d619629d07bcaa1a8e">More...</a><br /></td></tr>
<tr class="separator:aaf5ecd8e43cad8d619629d07bcaa1a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108f0ce1c6a6ca9d372302cbb16677bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a108f0ce1c6a6ca9d372302cbb16677bc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a108f0ce1c6a6ca9d372302cbb16677bc">getNewCollapseListAndAveragePos</a> (std::vector&lt; int &gt; &amp;newCollapseList, std::array&lt; double, 3 &gt; avrPos, std::array&lt; bool, 3 &gt; fix, const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes, int masterNodeId)</td></tr>
<tr class="memdesc:a108f0ce1c6a6ca9d372302cbb16677bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function appends the list of node Ids this node is collapsed with to the input array. <br /></td></tr>
<tr class="separator:a108f0ce1c6a6ca9d372302cbb16677bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7256e876aa188a55e16ef5df1aa89c0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7256e876aa188a55e16ef5df1aa89c0f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a7256e876aa188a55e16ef5df1aa89c0f">clearDuplicatesFromCollapseList</a> ()</td></tr>
<tr class="memdesc:a7256e876aa188a55e16ef5df1aa89c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function clears the <a class="el" href="classNode.html#a099baa33319712e8ff03063385f8e095" title="The vector of int storing the ids of the nodes this node is collapsed and bound with. ">Node::collapsedWith</a> array from duplicates. <br /></td></tr>
<tr class="separator:a7256e876aa188a55e16ef5df1aa89c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12f31fe9c966e7afc2d820365116123"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ad12f31fe9c966e7afc2d820365116123">collapseOnNode</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes, int masterNodeId)</td></tr>
<tr class="memdesc:ad12f31fe9c966e7afc2d820365116123"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function collapses this node on the node with the <a class="el" href="classNode.html#a1bd379569cc1a8b96432e61971aed4d9" title="The unique identification number of the node. ">Node::Id</a> with input masterNodeId, at one time step.  <a href="#ad12f31fe9c966e7afc2d820365116123">More...</a><br /></td></tr>
<tr class="separator:ad12f31fe9c966e7afc2d820365116123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a914f0b9898cbfa82aac511f0a44ee811"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a914f0b9898cbfa82aac511f0a44ee811"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a914f0b9898cbfa82aac511f0a44ee811">collapseOnNodeInStages</a> (std::vector&lt; int &gt; &amp;newCollapseList, std::array&lt; double, 3 &gt; avrPos, std::array&lt; bool, 3 &gt; fix, const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes)</td></tr>
<tr class="memdesc:a914f0b9898cbfa82aac511f0a44ee811"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function collapses this node on the node with the <a class="el" href="classNode.html#a1bd379569cc1a8b96432e61971aed4d9" title="The unique identification number of the node. ">Node::Id</a> with input masterNodeId, at multiple time steps, perturbing the position of the node smoothly to ensure stability. <br /></td></tr>
<tr class="separator:a914f0b9898cbfa82aac511f0a44ee811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cbc108c419c4c525ad92684df401e51"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cbc108c419c4c525ad92684df401e51"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a4cbc108c419c4c525ad92684df401e51">updatePositionTowardsPoint</a> (std::array&lt; double, 3 &gt; avrPos, std::array&lt; bool, 3 &gt; fix)</td></tr>
<tr class="memdesc:a4cbc108c419c4c525ad92684df401e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function moves this node towards the coordinates given in input array avrPos, excluding movement of fixed position. <br /></td></tr>
<tr class="separator:a4cbc108c419c4c525ad92684df401e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7a4917252fff90bd2ff2c50bfc5d21"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf7a4917252fff90bd2ff2c50bfc5d21"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#abf7a4917252fff90bd2ff2c50bfc5d21">isECMChangeAppliedToNode</a> (bool changeApicalECM, bool changeBasalECM, std::vector&lt; int &gt; &amp;ECMChangeEllipseBandIds, int numberOfECMChangeEllipseBands)</td></tr>
<tr class="memdesc:abf7a4917252fff90bd2ff2c50bfc5d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if the node falls within the range of the marker ellipse band ids for the ECM property perturbations. <br /></td></tr>
<tr class="separator:abf7a4917252fff90bd2ff2c50bfc5d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7b8ccf4dab44216b997c5f63f11d9f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a3c7b8ccf4dab44216b997c5f63f11d9f">getId</a> ()</td></tr>
<tr class="memdesc:a3c7b8ccf4dab44216b997c5f63f11d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function returns the Id (<a class="el" href="classNode.html#a1bd379569cc1a8b96432e61971aed4d9" title="The unique identification number of the node. ">Node::Id</a>) of the node.  <a href="#a3c7b8ccf4dab44216b997c5f63f11d9f">More...</a><br /></td></tr>
<tr class="separator:a3c7b8ccf4dab44216b997c5f63f11d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a8f3a763935fb67e34784d060c0ea76f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f3a763935fb67e34784d060c0ea76f8"></a>
std::array&lt; bool, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a8f3a763935fb67e34784d060c0ea76f8">FixedPos</a></td></tr>
<tr class="memdesc:a8f3a763935fb67e34784d060c0ea76f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean array stating if the node's position is fixed in any direction, format: [x y z], true = fixed. <br /></td></tr>
<tr class="separator:a8f3a763935fb67e34784d060c0ea76f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd379569cc1a8b96432e61971aed4d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1bd379569cc1a8b96432e61971aed4d9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a1bd379569cc1a8b96432e61971aed4d9">Id</a></td></tr>
<tr class="memdesc:a1bd379569cc1a8b96432e61971aed4d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unique identification number of the node. <br /></td></tr>
<tr class="separator:a1bd379569cc1a8b96432e61971aed4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa21f137c35d767ff0a119ef5e058194"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa21f137c35d767ff0a119ef5e058194"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aaa21f137c35d767ff0a119ef5e058194">nDim</a></td></tr>
<tr class="memdesc:aaa21f137c35d767ff0a119ef5e058194"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of dimensions of the node, (2 or 3) <br /></td></tr>
<tr class="separator:aaa21f137c35d767ff0a119ef5e058194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e54350ca21406946b8e1b34360dbae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70e54350ca21406946b8e1b34360dbae"></a>
std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a70e54350ca21406946b8e1b34360dbae">Position</a></td></tr>
<tr class="memdesc:a70e54350ca21406946b8e1b34360dbae"><td class="mdescLeft">&#160;</td><td class="mdescRight">The position array of the node. <br /></td></tr>
<tr class="separator:a70e54350ca21406946b8e1b34360dbae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34061bba1f26ce526f8cb17ed2bab561"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34061bba1f26ce526f8cb17ed2bab561"></a>
std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a34061bba1f26ce526f8cb17ed2bab561">RKPosition</a></td></tr>
<tr class="memdesc:a34061bba1f26ce526f8cb17ed2bab561"><td class="mdescLeft">&#160;</td><td class="mdescRight">The position array for position during a Runge-Kutta step array of the node. <br /></td></tr>
<tr class="separator:a34061bba1f26ce526f8cb17ed2bab561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c133172953bbe1451075ef7b78db6b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c133172953bbe1451075ef7b78db6b7"></a>
std::array&lt; bool, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a6c133172953bbe1451075ef7b78db6b7">externalViscositySetInFixing</a></td></tr>
<tr class="memdesc:a6c133172953bbe1451075ef7b78db6b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean array stating if the external viscosity of any axis has been set in node fixing options. The node fixing is carried out before the physical parameter settings in most cases. The boolean check is carried out not to overwrite the existing set viscosity in normal viscosity assignment. <br /></td></tr>
<tr class="separator:a6c133172953bbe1451075ef7b78db6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6377f135c12aae0dd776107c2628516e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6377f135c12aae0dd776107c2628516e"></a>
std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a6377f135c12aae0dd776107c2628516e">externalViscosity</a></td></tr>
<tr class="memdesc:a6377f135c12aae0dd776107c2628516e"><td class="mdescLeft">&#160;</td><td class="mdescRight">External viscosity of the node, defined by its placement within the tissue. This can be defined as an external adhesion, ECM remodelling, or any other form of viscosity. <br /></td></tr>
<tr class="separator:a6377f135c12aae0dd776107c2628516e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6adc185162f9fea733839c4e7230f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d6adc185162f9fea733839c4e7230f7"></a>
std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a1d6adc185162f9fea733839c4e7230f7">initialExternalViscosity</a></td></tr>
<tr class="memdesc:a1d6adc185162f9fea733839c4e7230f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">External viscosity of the node before any modifications by perturbation (for example ECM stiffness/ viscosity change) <br /></td></tr>
<tr class="separator:a1d6adc185162f9fea733839c4e7230f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78523720b4a1758f38d4e8b1703ad6c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78523720b4a1758f38d4e8b1703ad6c3"></a>
std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a78523720b4a1758f38d4e8b1703ad6c3">maximumExternalViscosity</a></td></tr>
<tr class="memdesc:a78523720b4a1758f38d4e8b1703ad6c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum external viscosity the node can reach as a result of modifications by perturbation (for example ECM stiffness/ viscosity change) <br /></td></tr>
<tr class="separator:a78523720b4a1758f38d4e8b1703ad6c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59528693432e71fa9b9e7ecfef6ee274"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59528693432e71fa9b9e7ecfef6ee274"></a>
std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a59528693432e71fa9b9e7ecfef6ee274">minimumExternalViscosity</a></td></tr>
<tr class="memdesc:a59528693432e71fa9b9e7ecfef6ee274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum external viscosity the node can reach as a result of modifications by perturbation (for example ECM stiffness/ viscosity change) <br /></td></tr>
<tr class="separator:a59528693432e71fa9b9e7ecfef6ee274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58afaee3d71a2c122396265c91acda04"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58afaee3d71a2c122396265c91acda04"></a>
std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a58afaee3d71a2c122396265c91acda04">ECMViscosityChangePerHour</a></td></tr>
<tr class="memdesc:a58afaee3d71a2c122396265c91acda04"><td class="mdescLeft">&#160;</td><td class="mdescRight">The change in ECM viscosity per one hour. The double array of size (1,3) stores the viscosity change in x, y, and z directions, respectively. <br /></td></tr>
<tr class="separator:a58afaee3d71a2c122396265c91acda04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f25afa638813548bef54299c2d756e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f25afa638813548bef54299c2d756e4"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a1f25afa638813548bef54299c2d756e4">displacement</a></td></tr>
<tr class="memdesc:a1f25afa638813548bef54299c2d756e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">the displacement of the node from previous time step; <br /></td></tr>
<tr class="separator:a1f25afa638813548bef54299c2d756e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af754322e3928dc45f70b19762551890a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af754322e3928dc45f70b19762551890a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#af754322e3928dc45f70b19762551890a">tissuePlacement</a></td></tr>
<tr class="memdesc:af754322e3928dc45f70b19762551890a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The tissue placement is 0 for basal nodes, 1 for apical nodes, and 2 for middle range. <br /></td></tr>
<tr class="separator:af754322e3928dc45f70b19762551890a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae621097f98f1d33d283cf65a0a02d29a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae621097f98f1d33d283cf65a0a02d29a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ae621097f98f1d33d283cf65a0a02d29a">tissueType</a></td></tr>
<tr class="memdesc:ae621097f98f1d33d283cf65a0a02d29a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The tissue type is 0 for columnar layer, 1 for peripodial membrane, and 2 for linker zone. <br /></td></tr>
<tr class="separator:ae621097f98f1d33d283cf65a0a02d29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b225354ad961f2e9bd5d7fe9b67b3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6b225354ad961f2e9bd5d7fe9b67b3a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ab6b225354ad961f2e9bd5d7fe9b67b3a">atCircumference</a></td></tr>
<tr class="memdesc:ab6b225354ad961f2e9bd5d7fe9b67b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean defining if the node is at the circumference of the columnar layer of the tissue. <br /></td></tr>
<tr class="separator:ab6b225354ad961f2e9bd5d7fe9b67b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e510fc9158eb15e751861bc14eae38"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63e510fc9158eb15e751861bc14eae38"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a63e510fc9158eb15e751861bc14eae38">mass</a></td></tr>
<tr class="memdesc:a63e510fc9158eb15e751861bc14eae38"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mass of the node, calculated via the elements that use the node as a vertex. <br /></td></tr>
<tr class="separator:a63e510fc9158eb15e751861bc14eae38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a585da74654d80d5f94805e39c1e2ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a585da74654d80d5f94805e39c1e2ad"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a7a585da74654d80d5f94805e39c1e2ad">viscositySurface</a></td></tr>
<tr class="memdesc:a7a585da74654d80d5f94805e39c1e2ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">The surface of the node, calculated for application of external viscosity via surface. It is positive for a surface that is to feel external viscosity, zero otherwise. <br /></td></tr>
<tr class="separator:a7a585da74654d80d5f94805e39c1e2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e9678dfeffc9e99d925a83b58fde3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8e9678dfeffc9e99d925a83b58fde3d"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#af8e9678dfeffc9e99d925a83b58fde3d">zProjectedArea</a></td></tr>
<tr class="memdesc:af8e9678dfeffc9e99d925a83b58fde3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The surface of the node, as projected in Z, calculated from apical or pasal surfces of elements, lateral surfaces are not included. <br /></td></tr>
<tr class="separator:af8e9678dfeffc9e99d925a83b58fde3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac7d84db546cadec7a8193e6ff52bd6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adac7d84db546cadec7a8193e6ff52bd6"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#adac7d84db546cadec7a8193e6ff52bd6">immediateNeigs</a></td></tr>
<tr class="memdesc:adac7d84db546cadec7a8193e6ff52bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of Id's for immediate neighbours of the node, i.e. the nodes that are shared by the elements that utilise the owner of this node. <br /></td></tr>
<tr class="separator:adac7d84db546cadec7a8193e6ff52bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c30c38a9406e72b1fc3b1cc9448d37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42c30c38a9406e72b1fc3b1cc9448d37"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a42c30c38a9406e72b1fc3b1cc9448d37">connectedElementIds</a></td></tr>
<tr class="memdesc:a42c30c38a9406e72b1fc3b1cc9448d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of Id's for elements that are utilising this node. <br /></td></tr>
<tr class="separator:a42c30c38a9406e72b1fc3b1cc9448d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3f1b55c7bfb8b81d8182c06ad1eee4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f3f1b55c7bfb8b81d8182c06ad1eee4"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a8f3f1b55c7bfb8b81d8182c06ad1eee4">connectedElementWeights</a></td></tr>
<tr class="memdesc:a8f3f1b55c7bfb8b81d8182c06ad1eee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of weights (normalised mass) for elements that are utilising this node, order is linked to <a class="el" href="classNode.html#a42c30c38a9406e72b1fc3b1cc9448d37" title="The list of Id&#39;s for elements that are utilising this node. ">Node::connectedElementIds</a>. <br /></td></tr>
<tr class="separator:a8f3f1b55c7bfb8b81d8182c06ad1eee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d38b47678cff15e338f9c917d32696"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71d38b47678cff15e338f9c917d32696"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a71d38b47678cff15e338f9c917d32696">hasLateralElementOwner</a></td></tr>
<tr class="memdesc:a71d38b47678cff15e338f9c917d32696"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean stating if any lateral element uses this node. <br /></td></tr>
<tr class="separator:a71d38b47678cff15e338f9c917d32696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14618d71e657039ed84316154be7330"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae14618d71e657039ed84316154be7330"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ae14618d71e657039ed84316154be7330">atSymmetricityBorder</a></td></tr>
<tr class="memdesc:ae14618d71e657039ed84316154be7330"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean stating if the node is at the border of symmetricity. <br /></td></tr>
<tr class="separator:ae14618d71e657039ed84316154be7330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216c4bf4af00dc77d8c88c4d2952f6ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a216c4bf4af00dc77d8c88c4d2952f6ab"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a216c4bf4af00dc77d8c88c4d2952f6ab">insideEllipseBand</a></td></tr>
<tr class="memdesc:a216c4bf4af00dc77d8c88c4d2952f6ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean stating if the node is inside a marker ellipse. <br /></td></tr>
<tr class="separator:a216c4bf4af00dc77d8c88c4d2952f6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0c478d6925dc16abf3995061fda191"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a0c478d6925dc16abf3995061fda191"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a5a0c478d6925dc16abf3995061fda191">coveringEllipseBandId</a></td></tr>
<tr class="memdesc:a5a0c478d6925dc16abf3995061fda191"><td class="mdescLeft">&#160;</td><td class="mdescRight">The id of the marker ellipse that the node is covered by. If hte node is not covered by any marker ellipse, the value is -1. <br /></td></tr>
<tr class="separator:a5a0c478d6925dc16abf3995061fda191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9eb82543b868adc05b5543251ebb42f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9eb82543b868adc05b5543251ebb42f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#aa9eb82543b868adc05b5543251ebb42f">allOwnersECMMimicing</a></td></tr>
<tr class="memdesc:aa9eb82543b868adc05b5543251ebb42f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean stating all the elements making use of the node are ECM mimicking elements. <br /></td></tr>
<tr class="separator:aa9eb82543b868adc05b5543251ebb42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96140b8fa2e7abffd79a040c6972309"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af96140b8fa2e7abffd79a040c6972309"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#af96140b8fa2e7abffd79a040c6972309">isMaster</a> [3]</td></tr>
<tr class="memdesc:af96140b8fa2e7abffd79a040c6972309"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean array stating if the corresponding degree of freedom of the node is a master of any other degree of freedom. <br /></td></tr>
<tr class="separator:af96140b8fa2e7abffd79a040c6972309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83aeb69143ee2ddc1f6f49be4b261b44"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83aeb69143ee2ddc1f6f49be4b261b44"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a83aeb69143ee2ddc1f6f49be4b261b44">slaveTo</a> [3]</td></tr>
<tr class="memdesc:a83aeb69143ee2ddc1f6f49be4b261b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">The int array storing the master node ids if the corresponding degree of freedom of the node is a slave to the respective degree of freedom of another node. <br /></td></tr>
<tr class="separator:a83aeb69143ee2ddc1f6f49be4b261b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099baa33319712e8ff03063385f8e095"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a099baa33319712e8ff03063385f8e095"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a099baa33319712e8ff03063385f8e095">collapsedWith</a></td></tr>
<tr class="memdesc:a099baa33319712e8ff03063385f8e095"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector of int storing the ids of the nodes this node is collapsed and bound with. <br /></td></tr>
<tr class="separator:a099baa33319712e8ff03063385f8e095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484ea8b4f71ea5fdfa1036ed1fabfae0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a484ea8b4f71ea5fdfa1036ed1fabfae0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a484ea8b4f71ea5fdfa1036ed1fabfae0">adheredTo</a></td></tr>
<tr class="memdesc:a484ea8b4f71ea5fdfa1036ed1fabfae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The id of the node this node is adhered to. <br /></td></tr>
<tr class="separator:a484ea8b4f71ea5fdfa1036ed1fabfae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913bf9335efdbd81a352b1ef80654f95"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a913bf9335efdbd81a352b1ef80654f95"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#a913bf9335efdbd81a352b1ef80654f95">onFoldInitiation</a></td></tr>
<tr class="memdesc:a913bf9335efdbd81a352b1ef80654f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean stating if this node is on a fold initiation region, automatically detected via curvature. <br /></td></tr>
<tr class="separator:a913bf9335efdbd81a352b1ef80654f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41abb2d4571366c2ba8d3a0b46798b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad41abb2d4571366c2ba8d3a0b46798b6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ad41abb2d4571366c2ba8d3a0b46798b6">checkOwnersforEllipseAsignment</a></td></tr>
<tr class="memdesc:ad41abb2d4571366c2ba8d3a0b46798b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">When the ellipse ids are assigned to nodes by owner elemetns, you can end up with elements that have all their nodes engulfed in an ellipse, but the element itself is not assigned into an ellipse. This flag will check for that. <br /></td></tr>
<tr class="separator:ad41abb2d4571366c2ba8d3a0b46798b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf1e1353abc605a027ca492f44cd15bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf1e1353abc605a027ca492f44cd15bf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#acf1e1353abc605a027ca492f44cd15bf">positionUpdateOngoing</a></td></tr>
<tr class="memdesc:acf1e1353abc605a027ca492f44cd15bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean stating if this node has its in the process of updating its position during staged collapse of nodes upon adhesion. <br /></td></tr>
<tr class="separator:acf1e1353abc605a027ca492f44cd15bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19c4820651632467a0d7f913f002b56"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac19c4820651632467a0d7f913f002b56"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNode.html#ac19c4820651632467a0d7f913f002b56">positionUpdateCounter</a></td></tr>
<tr class="memdesc:ac19c4820651632467a0d7f913f002b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">The counter for steps the nodes position update upon collapse with another node has been ongoing. <br /></td></tr>
<tr class="separator:ac19c4820651632467a0d7f913f002b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The node class </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2c6f029aa3388b8fb122139b1d24b71b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::addToConnectedElements </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newElementId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>volumePerNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function adds the input newElementId (int) to the list of elements connected by this node, updating the mass, and weights of mass per connected element in the process. </p>
<p>This function adds the input newElementId (int) to the list of elements connected by this node, updating the mass, and weights of mass per connected element in the process.</p>
<p>First the mass before addition of the new element is recorded. Then the <a class="el" href="classNode.html#a63e510fc9158eb15e751861bc14eae38" title="The mass of the node, calculated via the elements that use the node as a vertex. ">Node::mass</a> is updated.</p>
<p>Each of the already recorded weights (in <a class="el" href="classNode.html#a8f3f1b55c7bfb8b81d8182c06ad1eee4" title="The list of weights (normalised mass) for elements that are utilising this node, order is linked to N...">Node::connectedElementWeights</a>) of the connected elements (in <a class="el" href="classNode.html#a42c30c38a9406e72b1fc3b1cc9448d37" title="The list of Id&#39;s for elements that are utilising this node. ">Node::connectedElementIds</a>) will be updated with the scale newMass / oldMass.</p>
<p>Then the new element and its corresponding id will be added to the lists of the node, <a class="el" href="classNode.html#a42c30c38a9406e72b1fc3b1cc9448d37" title="The list of Id&#39;s for elements that are utilising this node. ">Node::connectedElementIds</a>, and <a class="el" href="classNode.html#a8f3f1b55c7bfb8b81d8182c06ad1eee4" title="The list of weights (normalised mass) for elements that are utilising this node, order is linked to N...">Node::connectedElementWeights</a>, respectively.</p>

</div>
</div>
<a class="anchor" id="ac2838f50304007a7cfe3df3f2e8d1772"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::addToImmediateNeigs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newNodeId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function adds the input node Id (int) to the list of neighbours of the node (<a class="el" href="classNode.html#adac7d84db546cadec7a8193e6ff52bd6" title="The list of Id&#39;s for immediate neighbours of the node, i.e. the nodes that are shared by the elements...">Node::immediateNeigs</a>) </p>
<p>The function will add the input node id to the vector of immediate neighbours of the current node (<a class="el" href="classNode.html#adac7d84db546cadec7a8193e6ff52bd6" title="The list of Id&#39;s for immediate neighbours of the node, i.e. the nodes that are shared by the elements...">Node::immediateNeigs</a>).</p>

</div>
</div>
<a class="anchor" id="a7dc5a9838a0a1963e58f648c5f7cb635"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Node::checkIfNeighbour </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>IdToCheck</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function to check if the node with input Id (IdToCheck) is an immediate neighbour of the node. </p>
<p>The function will return true if the node with the unique <a class="el" href="classNode.html#a1bd379569cc1a8b96432e61971aed4d9" title="The unique identification number of the node. ">Node::Id</a> equal to "IdToCheck" is an immediate neighbour of the current node. The search will be done through the list <a class="el" href="classNode.html#adac7d84db546cadec7a8193e6ff52bd6" title="The list of Id&#39;s for immediate neighbours of the node, i.e. the nodes that are shared by the elements...">Node::immediateNeigs</a></p>

</div>
</div>
<a class="anchor" id="a1d80e6f467d8ca919872b6e47a882dd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Node::checkIfNodeHasPacking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function to check if the node is eligible for packing. </p>
<p>The function will return true if the node is eligible for packing calculation. This packing will ensure volume exclusion, and is calculated via function Simulation::calculatePacking. It is not necessary to calculate packing under the following conditions: 1) The node is at the middle of the columnar layer, the packing should have stopped any other node/element coming close enough to this node, as they would need to penetrate through the apical or basal surface of the tissue to reach this node.</p>

</div>
</div>
<a class="anchor" id="ad12f31fe9c966e7afc2d820365116123"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::collapseOnNode </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>Nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>masterNodeId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function collapses this node on the node with the <a class="el" href="classNode.html#a1bd379569cc1a8b96432e61971aed4d9" title="The unique identification number of the node. ">Node::Id</a> with input masterNodeId, at one time step. </p>
<p>This function will collapse this <a class="el" href="classNode.html">Node</a> with the input node id (second parameter). Collapse will bind the two nodes' all degrees of freedoms to each other, and bring them to the same position, mid point of their positions at the time of the function call. The function will take in the address of the list of node pointers in the simulation, and a node id.</p>

</div>
</div>
<a class="anchor" id="a3030a518aa97bd50060b8733e87540f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::displayConnectedElementIds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will print out a list of connected element Id's. </p>
<p>The function will display on screen the list of unique <a class="el" href="classNode.html#a1bd379569cc1a8b96432e61971aed4d9" title="The unique identification number of the node. ">Node::Id</a> s for the elements utilising this node. These elements are listed in <a class="el" href="classNode.html#a42c30c38a9406e72b1fc3b1cc9448d37" title="The list of Id&#39;s for elements that are utilising this node. ">Node::connectedElementIds</a>.</p>

</div>
</div>
<a class="anchor" id="a755e8c3d76e7f1f0ab364fc3d4da3a9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::displayConnectedElementWeights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will print out the weights of the connected elements, in the order of Id s given in connectedElementIds. </p>
<p>The function will display on screen output the list of weights (normalised masses) of the connected elements. These weights are stored in <a class="el" href="classNode.html#a8f3f1b55c7bfb8b81d8182c06ad1eee4" title="The list of weights (normalised mass) for elements that are utilising this node, order is linked to N...">Node::connectedElementWeights</a>, and the order is linked to the list: <a class="el" href="classNode.html#a42c30c38a9406e72b1fc3b1cc9448d37" title="The list of Id&#39;s for elements that are utilising this node. ">Node::connectedElementIds</a>.</p>

</div>
</div>
<a class="anchor" id="a7c6a8e48ca7eda39cfb4b83699181cce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; double, 3 &gt; Node::getCurrentPosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the current position of the node </p>
<p>The function will return the current position of the owner node.</p>

</div>
</div>
<a class="anchor" id="a3c7b8ccf4dab44216b997c5f63f11d9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Node::getId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function returns the Id (<a class="el" href="classNode.html#a1bd379569cc1a8b96432e61971aed4d9" title="The unique identification number of the node. ">Node::Id</a>) of the node. </p>
<p>The function returns the <a class="el" href="classNode.html#a1bd379569cc1a8b96432e61971aed4d9" title="The unique identification number of the node. ">Node::Id</a> of the node.</p>

</div>
</div>
<a class="anchor" id="abc1e7e6c42b377c073a68c2b2ea97fa8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Node::isMyNeig </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodeId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function to check if the node with the input node id is a neighbour of this node (returns boolean). </p>
<p>This function will take in a node id, and check if the node is an immediate neighbour of itself. The check is done through its <a class="el" href="classNode.html#adac7d84db546cadec7a8193e6ff52bd6" title="The list of Id&#39;s for immediate neighbours of the node, i.e. the nodes that are shared by the elements...">Node::immediateNeigs</a> list. The function will return true if the input id is a neighbour, and false otherwise.</p>

</div>
</div>
<a class="anchor" id="aaf5ecd8e43cad8d619629d07bcaa1a8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Node::isNeigWithMyCollapsedNodes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>NodeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>Nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function to check if the node with the input <a class="el" href="classNode.html#a1bd379569cc1a8b96432e61971aed4d9" title="The unique identification number of the node. ">Node::Id</a> (nodeId) is collapsed with a neighbour of this node (returns boolean). </p>
<p>This function will take in a node id, and the address of the list of node pointers in the simulation. It will check if the input node id is an immediate neighbour of any of the nodes it has been collapsed with. The check is done through <a class="el" href="classNode.html#adac7d84db546cadec7a8193e6ff52bd6" title="The list of Id&#39;s for immediate neighbours of the node, i.e. the nodes that are shared by the elements...">Node::immediateNeigs</a> lists of all the nodes on its <a class="el" href="classNode.html#a099baa33319712e8ff03063385f8e095" title="The vector of int storing the ids of the nodes this node is collapsed and bound with. ">Node::collapsedWith</a> list. The function will return true if the input id is a neighbour of any node this node has collapsed with, and false otherwise.</p>

</div>
</div>
<a class="anchor" id="a6dc9c26deadb9d2ca3e248f4748d9dfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::removeFromConnectedElements </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newElementId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>volumePerNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function removes the input newElementId (int) from the list of elements connected by this node, updating the mass, and weights of mass per connected element in the process. </p>
<p>This function removes the input newElementId (int) from the list of elements connected by this node, updating the mass, and weights of mass per connected element in the process.</p>
<p>First the mass before addition of the new element is recorded. Then the <a class="el" href="classNode.html#a63e510fc9158eb15e751861bc14eae38" title="The mass of the node, calculated via the elements that use the node as a vertex. ">Node::mass</a> is updated.</p>
<p>Each of the already recorded weights (in <a class="el" href="classNode.html#a8f3f1b55c7bfb8b81d8182c06ad1eee4" title="The list of weights (normalised mass) for elements that are utilising this node, order is linked to N...">Node::connectedElementWeights</a>) of the connected elements (in <a class="el" href="classNode.html#a42c30c38a9406e72b1fc3b1cc9448d37" title="The list of Id&#39;s for elements that are utilising this node. ">Node::connectedElementIds</a>) will be updated with the scale newMass / oldMass. The index of the element to be deleted on vector <a class="el" href="classNode.html#a42c30c38a9406e72b1fc3b1cc9448d37" title="The list of Id&#39;s for elements that are utilising this node. ">Node::connectedElementIds</a> is obtained in the process.</p>
<p>Then the element with the obtained index is removed from the lists of connected element ids and weights. For efficiency, the element to be removed is swapped with the last element of each vector, and the vector popped back.</p>

</div>
</div>
<a class="anchor" id="adae4720965b558b075a91af4cf742b2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Node::setExternalViscosity </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ApicalVisc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>BasalVisc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>extendExternalViscosityToInnerTissue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function to set the viscosity of the node. </p>
<p>This function will take in the apical and basal external viscosities of the tissue as inputs, respectively. The external viscosity of the node will be assigned via its <a class="el" href="classNode.html#af754322e3928dc45f70b19762551890a" title="The tissue placement is 0 for basal nodes, 1 for apical nodes, and 2 for middle range. ">Node::tissuePlacement</a> and <a class="el" href="classNode.html#ae621097f98f1d33d283cf65a0a02d29a" title="The tissue type is 0 for columnar layer, 1 for peripodial membrane, and 2 for linker zone...">Node::tissueType</a>. On the columnar layer, nodes that are in the mid-zone of the tissue (neither on the apical nor on the basal surface, will take the average of the two values.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/melda/Documents/nonAcademic/TissueFoldingFefractor/TissueFoldingRefractor/TissueFoldingLinux/TissueFolding/SourceCode/<a class="el" href="Node_8h_source.html">Node.h</a></li>
<li>/home/melda/Documents/nonAcademic/TissueFoldingFefractor/TissueFoldingRefractor/TissueFoldingLinux/TissueFolding/SourceCode/Node.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classNode.html">Node</a></li>
    <li class="footer">Generated on Wed May 29 2019 16:14:29 for Tissue Origami by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
