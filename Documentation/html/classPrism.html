<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Tissue Origami: Prism Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tissue Origami
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classPrism.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classPrism-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Prism Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for Prism:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classPrism.png" usemap="#Prism_map" alt=""/>
  <map id="Prism_map" name="Prism_map">
<area href="classShapeBase.html" alt="ShapeBase" shape="rect" coords="0,0,76,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9dcd242eef25b663bd3d43554ca5aeb4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9dcd242eef25b663bd3d43554ca5aeb4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#a9dcd242eef25b663bd3d43554ca5aeb4">Prism</a> (const std::vector&lt; int &gt; &amp;inpNodeIds, const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes, int CurrId)</td></tr>
<tr class="memdesc:a9dcd242eef25b663bd3d43554ca5aeb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a9dcd242eef25b663bd3d43554ca5aeb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab0c30da5abd28ac1bea8530eb67ba5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ab0c30da5abd28ac1bea8530eb67ba5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#a6ab0c30da5abd28ac1bea8530eb67ba5">~Prism</a> ()</td></tr>
<tr class="memdesc:a6ab0c30da5abd28ac1bea8530eb67ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a6ab0c30da5abd28ac1bea8530eb67ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f535b16518d1beea7d2405697bb203"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3f535b16518d1beea7d2405697bb203"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#ac3f535b16518d1beea7d2405697bb203">setElasticProperties</a> (double EApical, double EBasal, double EMid, double EECM, double <a class="el" href="classShapeBase.html#a8b4c2d3bfbc6c9785c5181a56f929151">v</a>)</td></tr>
<tr class="memdesc:ac3f535b16518d1beea7d2405697bb203"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the elastic properties of the prism. <br /></td></tr>
<tr class="separator:ac3f535b16518d1beea7d2405697bb203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a73ea508f443cbefc8e301d3f190ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44a73ea508f443cbefc8e301d3f190ad"></a>
std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#a44a73ea508f443cbefc8e301d3f190ad">calculateBasalNormal</a> ()</td></tr>
<tr class="memdesc:a44a73ea508f443cbefc8e301d3f190ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the normal of the basal surface of the element. <br /></td></tr>
<tr class="separator:a44a73ea508f443cbefc8e301d3f190ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe4a2476246f2b4f8368b61584dea58"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fe4a2476246f2b4f8368b61584dea58"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#a7fe4a2476246f2b4f8368b61584dea58">calculateApicalNormalCurrentShape</a> ()</td></tr>
<tr class="memdesc:a7fe4a2476246f2b4f8368b61584dea58"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the normal of the apical surface of the element. <br /></td></tr>
<tr class="separator:a7fe4a2476246f2b4f8368b61584dea58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a877cebf651015b88af641f1e045699"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#a9a877cebf651015b88af641f1e045699">calculateElementShapeFunctionDerivatives</a> ()</td></tr>
<tr class="memdesc:a9a877cebf651015b88af641f1e045699"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the shape function derivatives of the prism.  <a href="#a9a877cebf651015b88af641f1e045699">More...</a><br /></td></tr>
<tr class="separator:a9a877cebf651015b88af641f1e045699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ce210a9ba20d34b4b903e936b9dd8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4ce210a9ba20d34b4b903e936b9dd8d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#af4ce210a9ba20d34b4b903e936b9dd8d">checkHealth</a> ()</td></tr>
<tr class="memdesc:af4ce210a9ba20d34b4b903e936b9dd8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks the health of the element, against fliiping. <br /></td></tr>
<tr class="separator:af4ce210a9ba20d34b4b903e936b9dd8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10377e0ad0ae454a3cd25b82709119ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10377e0ad0ae454a3cd25b82709119ac"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#a10377e0ad0ae454a3cd25b82709119ac">getCorrecpondingApical</a> (int currNodeId)</td></tr>
<tr class="memdesc:a10377e0ad0ae454a3cd25b82709119ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the corresponding connected apical node of a basal input node on the prism. <br /></td></tr>
<tr class="separator:a10377e0ad0ae454a3cd25b82709119ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe648c5fa60635a50c14186135bed332"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe648c5fa60635a50c14186135bed332"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#abe648c5fa60635a50c14186135bed332">IsThisNodeMyBasal</a> (int currNodeId)</td></tr>
<tr class="memdesc:abe648c5fa60635a50c14186135bed332"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if the input <a class="el" href="classNode.html#a1bd379569cc1a8b96432e61971aed4d9" title="The unique identification number of the node. ">Node::Id</a> is a basal node of the prism. <br /></td></tr>
<tr class="separator:abe648c5fa60635a50c14186135bed332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f3b638a4068180a11add5921870230"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9f3b638a4068180a11add5921870230"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#ab9f3b638a4068180a11add5921870230">IsThisNodeMyApical</a> (int currNodeId)</td></tr>
<tr class="memdesc:ab9f3b638a4068180a11add5921870230"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if the input <a class="el" href="classNode.html#a1bd379569cc1a8b96432e61971aed4d9" title="The unique identification number of the node. ">Node::Id</a> is an apical node of the prism. <br /></td></tr>
<tr class="separator:ab9f3b638a4068180a11add5921870230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d08cfcf6bf111f5d9e314499bafd11"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91d08cfcf6bf111f5d9e314499bafd11"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#a91d08cfcf6bf111f5d9e314499bafd11">getElementHeight</a> ()</td></tr>
<tr class="memdesc:a91d08cfcf6bf111f5d9e314499bafd11"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the apical-basal (z) height of this prism. <br /></td></tr>
<tr class="separator:a91d08cfcf6bf111f5d9e314499bafd11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e80515fb1cdf4438b4b7d47334bd2e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67e80515fb1cdf4438b4b7d47334bd2e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#a67e80515fb1cdf4438b4b7d47334bd2e">calculateApicalArea</a> ()</td></tr>
<tr class="memdesc:a67e80515fb1cdf4438b4b7d47334bd2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the apical area of the prism. <br /></td></tr>
<tr class="separator:a67e80515fb1cdf4438b4b7d47334bd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8dd4b90cdaecdbabfb48f45a9bcdc95"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8dd4b90cdaecdbabfb48f45a9bcdc95"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#aa8dd4b90cdaecdbabfb48f45a9bcdc95">calculateBasalArea</a> ()</td></tr>
<tr class="memdesc:aa8dd4b90cdaecdbabfb48f45a9bcdc95"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the basal area of the prism. <br /></td></tr>
<tr class="separator:aa8dd4b90cdaecdbabfb48f45a9bcdc95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace69b0f46bcd14fed2413fa2e24701e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace69b0f46bcd14fed2413fa2e24701e4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#ace69b0f46bcd14fed2413fa2e24701e4">updateElasticProperties</a> ()</td></tr>
<tr class="memdesc:ace69b0f46bcd14fed2413fa2e24701e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function updates the elastic properties of the prism upon perturbation. <br /></td></tr>
<tr class="separator:ace69b0f46bcd14fed2413fa2e24701e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d95fcc54232f1b7777e988cdee98727"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#a6d95fcc54232f1b7777e988cdee98727">setBasalNeigElementId</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classShapeBase.html">ShapeBase</a> &gt;&gt; &amp;elementsList)</td></tr>
<tr class="memdesc:a6d95fcc54232f1b7777e988cdee98727"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the basal neighboiur of this element, which has an apical surface overlapping completely with teh basal surface of this prism.  <a href="#a6d95fcc54232f1b7777e988cdee98727">More...</a><br /></td></tr>
<tr class="separator:a6d95fcc54232f1b7777e988cdee98727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972fe7d50800036b4dfd724bcba2b32b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a972fe7d50800036b4dfd724bcba2b32b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#a972fe7d50800036b4dfd724bcba2b32b">constructElementStackList</a> (const int discretisationLayers, const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classShapeBase.html">ShapeBase</a> &gt;&gt; &amp;elementsList)</td></tr>
<tr class="memdesc:a972fe7d50800036b4dfd724bcba2b32b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function constructs the apical-basal element stack list that this prosm resides in. <br /></td></tr>
<tr class="separator:a972fe7d50800036b4dfd724bcba2b32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f9b472a3310e76ab0c76bd1fb7dd30"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85f9b472a3310e76ab0c76bd1fb7dd30"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#a85f9b472a3310e76ab0c76bd1fb7dd30">checkRotationConsistency3D</a> ()</td></tr>
<tr class="memdesc:a85f9b472a3310e76ab0c76bd1fb7dd30"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if the nodes of the prosm rotate counter-clock vise, and corrects if not. <br /></td></tr>
<tr class="separator:a85f9b472a3310e76ab0c76bd1fb7dd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33eafcdbe69936cca29d7f23649c8cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae33eafcdbe69936cca29d7f23649c8cc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#ae33eafcdbe69936cca29d7f23649c8cc">areNodesDirectlyConnected</a> (int node0, int node1)</td></tr>
<tr class="memdesc:ae33eafcdbe69936cca29d7f23649c8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if the two nodes with input <a class="el" href="classNode.html#a1bd379569cc1a8b96432e61971aed4d9" title="The unique identification number of the node. ">Node::Id</a> values are directly connected to each other in topology of the prism. <br /></td></tr>
<tr class="separator:ae33eafcdbe69936cca29d7f23649c8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classShapeBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classShapeBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classShapeBase.html">ShapeBase</a></td></tr>
<tr class="memitem:af919db3ff5e6a6d4a137cf4625189c23 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#af919db3ff5e6a6d4a137cf4625189c23">~ShapeBase</a> ()</td></tr>
<tr class="separator:af919db3ff5e6a6d4a137cf4625189c23 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55ac0089ea8e37649b0d85409c008ac inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab55ac0089ea8e37649b0d85409c008ac"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ab55ac0089ea8e37649b0d85409c008ac">getId</a> ()</td></tr>
<tr class="memdesc:ab55ac0089ea8e37649b0d85409c008ac inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function returns the unique ID of the element. <br /></td></tr>
<tr class="separator:ab55ac0089ea8e37649b0d85409c008ac inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0adf2bb9b59c68adc9dfdab8b9a67a5a inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0adf2bb9b59c68adc9dfdab8b9a67a5a"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a0adf2bb9b59c68adc9dfdab8b9a67a5a">getName</a> ()</td></tr>
<tr class="memdesc:a0adf2bb9b59c68adc9dfdab8b9a67a5a inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function returns the name of the element. <br /></td></tr>
<tr class="separator:a0adf2bb9b59c68adc9dfdab8b9a67a5a inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae6deee4256eb19c6e99b52a40847cb inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ae6deee4256eb19c6e99b52a40847cb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a7ae6deee4256eb19c6e99b52a40847cb">getShapeType</a> ()</td></tr>
<tr class="memdesc:a7ae6deee4256eb19c6e99b52a40847cb inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function returns the shape type of the element. <br /></td></tr>
<tr class="separator:a7ae6deee4256eb19c6e99b52a40847cb inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578a8062720c07fc8e1ad526422c96b8 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a578a8062720c07fc8e1ad526422c96b8"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a578a8062720c07fc8e1ad526422c96b8">getNodeNumber</a> ()</td></tr>
<tr class="memdesc:a578a8062720c07fc8e1ad526422c96b8 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function returns the number of nodes o the element. <br /></td></tr>
<tr class="separator:a578a8062720c07fc8e1ad526422c96b8 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f803aa2f7587251d746706cc478b71 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0f803aa2f7587251d746706cc478b71"></a>
const std::vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ab0f803aa2f7587251d746706cc478b71">getNodeIds</a> ()</td></tr>
<tr class="memdesc:ab0f803aa2f7587251d746706cc478b71 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function returns the vector of node IDs. <br /></td></tr>
<tr class="separator:ab0f803aa2f7587251d746706cc478b71 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586ebd517ab4b08eab7685b3c004b800 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a586ebd517ab4b08eab7685b3c004b800"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a586ebd517ab4b08eab7685b3c004b800">getNodeId</a> (int i)</td></tr>
<tr class="memdesc:a586ebd517ab4b08eab7685b3c004b800 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function returns the input i^{th} node's ID. <br /></td></tr>
<tr class="separator:a586ebd517ab4b08eab7685b3c004b800 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9bc340db8e5add7974be8c36e64802 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf9bc340db8e5add7974be8c36e64802"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aaf9bc340db8e5add7974be8c36e64802">getDim</a> ()</td></tr>
<tr class="memdesc:aaf9bc340db8e5add7974be8c36e64802 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function returns the dimensions of the node, ShapeBase::Dim. <br /></td></tr>
<tr class="separator:aaf9bc340db8e5add7974be8c36e64802 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787774fa435981eaba73d4137686783d inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a787774fa435981eaba73d4137686783d"></a>
std::array&lt; int, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a787774fa435981eaba73d4137686783d">getIdentifierColour</a> ()</td></tr>
<tr class="memdesc:a787774fa435981eaba73d4137686783d inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unique [r,g,b] identifier colour of the element, utilised in picking in the user interface. <br /></td></tr>
<tr class="separator:a787774fa435981eaba73d4137686783d inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeddd04a53a677417d8577f031b1ca25 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaeddd04a53a677417d8577f031b1ca25"></a>
std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aaeddd04a53a677417d8577f031b1ca25">getCentre</a> ()</td></tr>
<tr class="memdesc:aaeddd04a53a677417d8577f031b1ca25 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the centre of the element in world spave. <br /></td></tr>
<tr class="separator:aaeddd04a53a677417d8577f031b1ca25 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d1eaa5a49262418cee28284da14c16 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90d1eaa5a49262418cee28284da14c16"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a90d1eaa5a49262418cee28284da14c16">getPeripodialness</a> ()</td></tr>
<tr class="memdesc:a90d1eaa5a49262418cee28284da14c16 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the relative influence of the peripodial physical characteristics to this element. <br /></td></tr>
<tr class="separator:a90d1eaa5a49262418cee28284da14c16 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c758ac93865a1e51e63212ebfe2787 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44c758ac93865a1e51e63212ebfe2787"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a44c758ac93865a1e51e63212ebfe2787">getColumnarness</a> ()</td></tr>
<tr class="memdesc:a44c758ac93865a1e51e63212ebfe2787 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the relative influence of the columnar physical characteristics ot this element. <br /></td></tr>
<tr class="separator:a44c758ac93865a1e51e63212ebfe2787 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13cf955dcc9db425c762053468578d72 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a13cf955dcc9db425c762053468578d72">getRelativePositionInTissueInGridIndex</a> (int nGridX, int nGridY, int &amp;IndexX, int &amp;IndexY, double &amp;FracX, double &amp;FracY)</td></tr>
<tr class="memdesc:a13cf955dcc9db425c762053468578d72 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the relative position within the bounding box of the tissue, and calculates which point on the growth maps should be read.  <a href="#a13cf955dcc9db425c762053468578d72">More...</a><br /></td></tr>
<tr class="separator:a13cf955dcc9db425c762053468578d72 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e91ece1ff8f6cfa8d8c495a3afc59c5 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a2e91ece1ff8f6cfa8d8c495a3afc59c5">getInitialRelativePositionInTissueInGridIndex</a> (int nGridX, int nGridY, int &amp;IndexX, int &amp;IndexY, double &amp;FracX, double &amp;FracY)</td></tr>
<tr class="memdesc:a2e91ece1ff8f6cfa8d8c495a3afc59c5 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The relative positions of the iitial configuration of the element within the bounding box of the tissue.  <a href="#a2e91ece1ff8f6cfa8d8c495a3afc59c5">More...</a><br /></td></tr>
<tr class="separator:a2e91ece1ff8f6cfa8d8c495a3afc59c5 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf8b080646ee417af28e94f5857aa17 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aedf8b080646ee417af28e94f5857aa17"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aedf8b080646ee417af28e94f5857aa17">getStiffnessMultiplier</a> ()</td></tr>
<tr class="memdesc:aedf8b080646ee417af28e94f5857aa17 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the current stiffness multiplier as a result of perturbations to physical properties. <br /></td></tr>
<tr class="separator:aedf8b080646ee417af28e94f5857aa17 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438155adad0f124efa714b349830437b inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a438155adad0f124efa714b349830437b">getCurrentVolume</a> ()</td></tr>
<tr class="memdesc:a438155adad0f124efa714b349830437b inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the current volume of the element.  <a href="#a438155adad0f124efa714b349830437b">More...</a><br /></td></tr>
<tr class="separator:a438155adad0f124efa714b349830437b inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6c972d40af4b6709481f63903c4342 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf6c972d40af4b6709481f63903c4342"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#adf6c972d40af4b6709481f63903c4342">getElementalElasticForce</a> (int nodeIndex, int dimIndex)</td></tr>
<tr class="memdesc:adf6c972d40af4b6709481f63903c4342 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the calculated elastic force for the node nodeIndex, in coordinate dimIndex. <br /></td></tr>
<tr class="separator:adf6c972d40af4b6709481f63903c4342 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d82f91854fff8473dcd722ab423e10 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4d82f91854fff8473dcd722ab423e10"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ae4d82f91854fff8473dcd722ab423e10">setElementalElasticForce</a> (int nodeIndex, int dimIndex, double value)</td></tr>
<tr class="memdesc:ae4d82f91854fff8473dcd722ab423e10 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions sets the calculated elastic force for the node nodeIndex, dimension dimIndex, to the input value. <br /></td></tr>
<tr class="separator:ae4d82f91854fff8473dcd722ab423e10 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8aa4fb16ea7b545e6b8e13b95d6b6e inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#abb8aa4fb16ea7b545e6b8e13b95d6b6e">getCurrentFe</a> ()</td></tr>
<tr class="memdesc:abb8aa4fb16ea7b545e6b8e13b95d6b6e inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the current elastic part of the deformation gradient.  <a href="#abb8aa4fb16ea7b545e6b8e13b95d6b6e">More...</a><br /></td></tr>
<tr class="separator:abb8aa4fb16ea7b545e6b8e13b95d6b6e inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8f0f737818ca01e15b7652c38d4900 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b8f0f737818ca01e15b7652c38d4900"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a5b8f0f737818ca01e15b7652c38d4900">getApicalArea</a> ()</td></tr>
<tr class="memdesc:a5b8f0f737818ca01e15b7652c38d4900 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the current apical area of the element. <br /></td></tr>
<tr class="separator:a5b8f0f737818ca01e15b7652c38d4900 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a3c680c1b96ae81d6bfe21a0127655 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a40a3c680c1b96ae81d6bfe21a0127655">relaxElasticForces</a> ()</td></tr>
<tr class="memdesc:a40a3c680c1b96ae81d6bfe21a0127655 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function relaxes all teh accumulated elastic forces in the system.  <a href="#a40a3c680c1b96ae81d6bfe21a0127655">More...</a><br /></td></tr>
<tr class="separator:a40a3c680c1b96ae81d6bfe21a0127655 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f0cc5b33f3e12d91a246cc591c346c inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aa0f0cc5b33f3e12d91a246cc591c346c">isGrowthRateApplicable</a> (int sourceTissue, double &amp;weight, double zmin, double zmax)</td></tr>
<tr class="memdesc:aa0f0cc5b33f3e12d91a246cc591c346c inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function checks if the element if affected by the current growth functions.  <a href="#aa0f0cc5b33f3e12d91a246cc591c346c">More...</a><br /></td></tr>
<tr class="separator:aa0f0cc5b33f3e12d91a246cc591c346c inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605f5ce36b0d86330fbc535f553ae140 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a605f5ce36b0d86330fbc535f553ae140"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a605f5ce36b0d86330fbc535f553ae140">updateGrowthWillBeScaledDueToApikobasalRedistribution</a> (bool thisFunctionShrinksApical, std::vector&lt; int &gt; &amp;ellipseBandIdsForGrowthRedistribution)</td></tr>
<tr class="memdesc:a605f5ce36b0d86330fbc535f553ae140 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function decide if the growth will be redistirbuted in the height of the tissue. <br /></td></tr>
<tr class="separator:a605f5ce36b0d86330fbc535f553ae140 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace7f6727db271b84db82d0560d26b86 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aace7f6727db271b84db82d0560d26b86">scaleGrowthForZRedistribution</a> (double &amp;x, double &amp;y, double &amp;z)</td></tr>
<tr class="memdesc:aace7f6727db271b84db82d0560d26b86 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will modify the incremental growth deformation gradient of the element to reflect the volume redistribution in the height of the tissue.  <a href="#aace7f6727db271b84db82d0560d26b86">More...</a><br /></td></tr>
<tr class="separator:aace7f6727db271b84db82d0560d26b86 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45508a35016a845b9c3b2d8f7d51479a inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a45508a35016a845b9c3b2d8f7d51479a">calculateFgFromRates</a> (double dt, double x, double y, double z, gsl_matrix *rotMat, gsl_matrix *increment, int sourceTissue, double zMin, double zMax)</td></tr>
<tr class="memdesc:a45508a35016a845b9c3b2d8f7d51479a inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This fucntion will calculate the incremental growth deformation gradient change for the current time step, from input growth rates.  <a href="#a45508a35016a845b9c3b2d8f7d51479a">More...</a><br /></td></tr>
<tr class="separator:a45508a35016a845b9c3b2d8f7d51479a inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ed61e92393b0d7364a4a99ac0f77f9 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a23ed61e92393b0d7364a4a99ac0f77f9">calculateFgFromGridCorners</a> (int gridGrowthsInterpolationType, double dt, <a class="el" href="classGrowthFunctionBase.html">GrowthFunctionBase</a> *currGF, gsl_matrix *increment, int sourceTissue, int IndexX, int IndexY, double FracX, double dFracY)</td></tr>
<tr class="memdesc:a23ed61e92393b0d7364a4a99ac0f77f9 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This fucntion will calculate the incremental growth deformation gradient change for the current time step by reading it from the grid, and interpolating on 4 corners.  <a href="#a23ed61e92393b0d7364a4a99ac0f77f9">More...</a><br /></td></tr>
<tr class="separator:a23ed61e92393b0d7364a4a99ac0f77f9 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfee9abf0c9b00e278762688525ef333 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acfee9abf0c9b00e278762688525ef333"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#acfee9abf0c9b00e278762688525ef333">getGrowthIncrement</a> ()</td></tr>
<tr class="memdesc:acfee9abf0c9b00e278762688525ef333 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the current growth deformation gradient increment. <br /></td></tr>
<tr class="separator:acfee9abf0c9b00e278762688525ef333 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009b5aed1c546db5e517f9f33f67b066 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a009b5aed1c546db5e517f9f33f67b066">updateGrowthIncrement</a> (gsl_matrix *columnar, gsl_matrix *peripodial)</td></tr>
<tr class="memdesc:a009b5aed1c546db5e517f9f33f67b066 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will update the elemental growth deformation gradient from the current growth deformation gradient increment.  <a href="#a009b5aed1c546db5e517f9f33f67b066">More...</a><br /></td></tr>
<tr class="separator:a009b5aed1c546db5e517f9f33f67b066 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466480b1e7de98250dd22c8cdb092d54 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a466480b1e7de98250dd22c8cdb092d54">updateGrowthByMutation</a> (double dt)</td></tr>
<tr class="memdesc:a466480b1e7de98250dd22c8cdb092d54 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will update the growth growth deformaton gradient increment of the element due to a mutation.  <a href="#a466480b1e7de98250dd22c8cdb092d54">More...</a><br /></td></tr>
<tr class="separator:a466480b1e7de98250dd22c8cdb092d54 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c8d69e858be0ad6414f4f5f64eeb3b inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33c8d69e858be0ad6414f4f5f64eeb3b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a33c8d69e858be0ad6414f4f5f64eeb3b">scaleGrowthIncrement</a> (double multiuplier)</td></tr>
<tr class="memdesc:a33c8d69e858be0ad6414f4f5f64eeb3b inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will scale the growth growth deformaton gradient increment by input double. <br /></td></tr>
<tr class="separator:a33c8d69e858be0ad6414f4f5f64eeb3b inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2423a7dd85ab25b7eb38b5a954d732ab inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2423a7dd85ab25b7eb38b5a954d732ab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a2423a7dd85ab25b7eb38b5a954d732ab">calculateShapeChangeIncrementFromRates</a> (double dt, double rx, double ry, double rz, gsl_matrix *increment)</td></tr>
<tr class="memdesc:a2423a7dd85ab25b7eb38b5a954d732ab inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will calculate the current shape change deformation gradient increment due to elemental active shape change, from input rates. <br /></td></tr>
<tr class="separator:a2423a7dd85ab25b7eb38b5a954d732ab inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab057fa6a1189b6bed5ac9201fc6ca620 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab057fa6a1189b6bed5ac9201fc6ca620"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ab057fa6a1189b6bed5ac9201fc6ca620">updateShapeChangeIncrement</a> (gsl_matrix *columnarShapeChangeIncrement)</td></tr>
<tr class="memdesc:ab057fa6a1189b6bed5ac9201fc6ca620 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function updates the growth increment of the element with the current shape change increment. <br /></td></tr>
<tr class="separator:ab057fa6a1189b6bed5ac9201fc6ca620 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04278729ad9cc3238b1966ade0685a3d inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04278729ad9cc3238b1966ade0685a3d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a04278729ad9cc3238b1966ade0685a3d">calculateRelativePosInBoundingBox</a> (double boundingBoxXMin, double boundingBoxYMin, double boundingBoxLength, double boundingBoxWidth)</td></tr>
<tr class="memdesc:a04278729ad9cc3238b1966ade0685a3d inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will calculate the relative positions of the element in the xy-plane bounding box of the tissue. <br /></td></tr>
<tr class="separator:a04278729ad9cc3238b1966ade0685a3d inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39a584fa424f92b219d0ad903439ae7 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af39a584fa424f92b219d0ad903439ae7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#af39a584fa424f92b219d0ad903439ae7">mutateElement</a> (double growthFold, double growthRatePerHour)</td></tr>
<tr class="memdesc:af39a584fa424f92b219d0ad903439ae7 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will set the element as a mutant, the mutant growth rates will be set. <br /></td></tr>
<tr class="separator:af39a584fa424f92b219d0ad903439ae7 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf601cf9b007a1e001b01fb5ed84399a inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf601cf9b007a1e001b01fb5ed84399a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#acf601cf9b007a1e001b01fb5ed84399a">updateReferencePositionMatrixFromInput</a> (double **input)</td></tr>
<tr class="memdesc:acf601cf9b007a1e001b01fb5ed84399a inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will update the reference position matrix. Not used under healthy, continuous simulations, to preserve continuity of the mesh. <br /></td></tr>
<tr class="separator:acf601cf9b007a1e001b01fb5ed84399a inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e17514271f121498ed12cebae3aebe inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5e17514271f121498ed12cebae3aebe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ae5e17514271f121498ed12cebae3aebe">displayRelativePosInBoundingBox</a> ()</td></tr>
<tr class="memdesc:ae5e17514271f121498ed12cebae3aebe inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to display the relative position of the element in the bounding box of the tissue. <br /></td></tr>
<tr class="separator:ae5e17514271f121498ed12cebae3aebe inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50e45399c54ae205ae1adabbc485ff1 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad50e45399c54ae205ae1adabbc485ff1"></a>
std::array&lt; double, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ad50e45399c54ae205ae1adabbc485ff1">getRelativePosInBoundingBox</a> ()</td></tr>
<tr class="memdesc:ad50e45399c54ae205ae1adabbc485ff1 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the relative position of the element in the xy bounding box of the tissue. <br /></td></tr>
<tr class="separator:ad50e45399c54ae205ae1adabbc485ff1 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d8a64fec5591d51c6d54ea76711e0d inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71d8a64fec5591d51c6d54ea76711e0d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a71d8a64fec5591d51c6d54ea76711e0d">setRelativePosInBoundingBox</a> (double x, double y)</td></tr>
<tr class="memdesc:a71d8a64fec5591d51c6d54ea76711e0d inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functoin will set the relative position of the element in the bounding box of the tissue to the input coordinates. <br /></td></tr>
<tr class="separator:a71d8a64fec5591d51c6d54ea76711e0d inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7a7578407be503531bf14af6d004d1 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c7a7578407be503531bf14af6d004d1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a8c7a7578407be503531bf14af6d004d1">setInitialRelativePosInBoundingBox</a> ()</td></tr>
<tr class="memdesc:a8c7a7578407be503531bf14af6d004d1 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the initial relative position in bounding box of the tissue to current reference position. <br /></td></tr>
<tr class="separator:a8c7a7578407be503531bf14af6d004d1 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e054f84b56303812eee5b3abeec9b2f inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e054f84b56303812eee5b3abeec9b2f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a3e054f84b56303812eee5b3abeec9b2f">setInitialZPosition</a> (double zMax, double TissueHeight)</td></tr>
<tr class="memdesc:a3e054f84b56303812eee5b3abeec9b2f inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This fucntion sets the initial relative z position of the tissue in tissue height. <br /></td></tr>
<tr class="separator:a3e054f84b56303812eee5b3abeec9b2f inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775b57d5074679c6fd4d3f57885e86d8 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a775b57d5074679c6fd4d3f57885e86d8"></a>
std::array&lt; double, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a775b57d5074679c6fd4d3f57885e86d8">getInitialRelativePosInBoundingBox</a> ()</td></tr>
<tr class="memdesc:a775b57d5074679c6fd4d3f57885e86d8 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the initial relative position of the element in the xy bounding box of the tissue. <br /></td></tr>
<tr class="separator:a775b57d5074679c6fd4d3f57885e86d8 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde567878e8335d5f3b82042bcf23e5b inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acde567878e8335d5f3b82042bcf23e5b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#acde567878e8335d5f3b82042bcf23e5b">convertRelativePosToGridIndex</a> (std::array&lt; double, 2 &gt; relpos, int &amp;indexX, int &amp;indexY, double &amp;fracX, double &amp;fracY, int nGridX, int nGridY)</td></tr>
<tr class="memdesc:acde567878e8335d5f3b82042bcf23e5b inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will convert the relative position of the tissue in xy plane bounding box to growth map grid indices. <br /></td></tr>
<tr class="separator:acde567878e8335d5f3b82042bcf23e5b inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf99016ea7c36e0bff43a40e6a89df3 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aecf99016ea7c36e0bff43a40e6a89df3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aecf99016ea7c36e0bff43a40e6a89df3">getStrain</a> (int type, float &amp;StrainMag)</td></tr>
<tr class="memdesc:aecf99016ea7c36e0bff43a40e6a89df3 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the selected strain component of the element. <br /></td></tr>
<tr class="separator:aecf99016ea7c36e0bff43a40e6a89df3 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6971273ad49bfe9a49b2ddf09e426291 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6971273ad49bfe9a49b2ddf09e426291"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a6971273ad49bfe9a49b2ddf09e426291">getNodeBasedPysProp</a> (int type, int NodeNo, const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes, float &amp;PysPropMag)</td></tr>
<tr class="memdesc:a6971273ad49bfe9a49b2ddf09e426291 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the selected physical properties of the element on a nodal basis. <br /></td></tr>
<tr class="separator:a6971273ad49bfe9a49b2ddf09e426291 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff91451c3465778ed89624d6196f7f6 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abff91451c3465778ed89624d6196f7f6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#abff91451c3465778ed89624d6196f7f6">getPysProp</a> (int type, float &amp;PysPropMag, double dt)</td></tr>
<tr class="memdesc:abff91451c3465778ed89624d6196f7f6 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the selected physical properties of the element. <br /></td></tr>
<tr class="separator:abff91451c3465778ed89624d6196f7f6 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51bc2c7303dfaae0687d1d785b077e81 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51bc2c7303dfaae0687d1d785b077e81"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a51bc2c7303dfaae0687d1d785b077e81">getInternalViscosity</a> ()</td></tr>
<tr class="memdesc:a51bc2c7303dfaae0687d1d785b077e81 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the internal viscosity of the element. <br /></td></tr>
<tr class="separator:a51bc2c7303dfaae0687d1d785b077e81 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0651f685642cfddf6cefa3542ece51a inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0651f685642cfddf6cefa3542ece51a"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ac0651f685642cfddf6cefa3542ece51a">getOriginalInternalViscosity</a> ()</td></tr>
<tr class="memdesc:ac0651f685642cfddf6cefa3542ece51a inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the internal viscosity of the element prior to any perturbations. <br /></td></tr>
<tr class="separator:ac0651f685642cfddf6cefa3542ece51a inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade96ff86461eaabce716e83fa68bfa19 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade96ff86461eaabce716e83fa68bfa19"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ade96ff86461eaabce716e83fa68bfa19">getYoungModulus</a> ()</td></tr>
<tr class="memdesc:ade96ff86461eaabce716e83fa68bfa19 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the Young's modulus of the element. <br /></td></tr>
<tr class="separator:ade96ff86461eaabce716e83fa68bfa19 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01140f17779cd2e990c9f28e3c86b77e inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01140f17779cd2e990c9f28e3c86b77e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a01140f17779cd2e990c9f28e3c86b77e">getPoissonRatio</a> ()</td></tr>
<tr class="memdesc:a01140f17779cd2e990c9f28e3c86b77e inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the Poissons's ratio of the element. <br /></td></tr>
<tr class="separator:a01140f17779cd2e990c9f28e3c86b77e inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348086a2524d9f12ca7748757d6ce645 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a348086a2524d9f12ca7748757d6ce645"></a>
const std::array&lt; double, 3 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a348086a2524d9f12ca7748757d6ce645">getGrowthRate</a> ()</td></tr>
<tr class="memdesc:a348086a2524d9f12ca7748757d6ce645 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the current growth rate of the element. <br /></td></tr>
<tr class="separator:a348086a2524d9f12ca7748757d6ce645 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ca43e5283df3a948ab6e56f71fd3c6 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5ca43e5283df3a948ab6e56f71fd3c6"></a>
const std::array&lt; double, 6 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ac5ca43e5283df3a948ab6e56f71fd3c6">getShapeChangeRate</a> ()</td></tr>
<tr class="memdesc:ac5ca43e5283df3a948ab6e56f71fd3c6 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the current shape change rate of the element. <br /></td></tr>
<tr class="separator:ac5ca43e5283df3a948ab6e56f71fd3c6 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8362daf177d7d30d0b02aca95a185b25 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8362daf177d7d30d0b02aca95a185b25"></a>
const std::vector&lt; std::array&lt; double, 3 &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a8362daf177d7d30d0b02aca95a185b25">getReferencePos</a> ()</td></tr>
<tr class="memdesc:a8362daf177d7d30d0b02aca95a185b25 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the reference positions of the element. <br /></td></tr>
<tr class="separator:a8362daf177d7d30d0b02aca95a185b25 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1906a5afda8fcbeef23010759f2538c inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1906a5afda8fcbeef23010759f2538c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ab1906a5afda8fcbeef23010759f2538c">getPos</a> (gsl_matrix *Pos)</td></tr>
<tr class="memdesc:ab1906a5afda8fcbeef23010759f2538c inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will write the position of the element into input matrix. <br /></td></tr>
<tr class="separator:ab1906a5afda8fcbeef23010759f2538c inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79889ef9cb7831a50e5391cb1cc19793 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79889ef9cb7831a50e5391cb1cc19793"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a79889ef9cb7831a50e5391cb1cc19793">getFg</a> ()</td></tr>
<tr class="memdesc:a79889ef9cb7831a50e5391cb1cc19793 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the growth component of the deformation gradient. <br /></td></tr>
<tr class="separator:a79889ef9cb7831a50e5391cb1cc19793 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79110e674e80a1e429669ccb5c3e4cb inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa79110e674e80a1e429669ccb5c3e4cb"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aa79110e674e80a1e429669ccb5c3e4cb">getInvFg</a> ()</td></tr>
<tr class="memdesc:aa79110e674e80a1e429669ccb5c3e4cb inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the inverse of the growth deformation gradient matrix. <br /></td></tr>
<tr class="separator:aa79110e674e80a1e429669ccb5c3e4cb inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab261573ddd6829df0ee104260352c7ae inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab261573ddd6829df0ee104260352c7ae"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ab261573ddd6829df0ee104260352c7ae">getFsc</a> ()</td></tr>
<tr class="memdesc:ab261573ddd6829df0ee104260352c7ae inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the shape change component of the deformation gradient. <br /></td></tr>
<tr class="separator:ab261573ddd6829df0ee104260352c7ae inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884da8f201986aaef5c27efdd4a5b7d4 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a884da8f201986aaef5c27efdd4a5b7d4"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a884da8f201986aaef5c27efdd4a5b7d4">getInvFsc</a> ()</td></tr>
<tr class="memdesc:a884da8f201986aaef5c27efdd4a5b7d4 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the inverse of the shape change deformation gradient matrix. <br /></td></tr>
<tr class="separator:a884da8f201986aaef5c27efdd4a5b7d4 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26de227e5135a355667be3a2a86d1431 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26de227e5135a355667be3a2a86d1431"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a26de227e5135a355667be3a2a86d1431">getFe</a> ()</td></tr>
<tr class="memdesc:a26de227e5135a355667be3a2a86d1431 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the elastic component of the deformation gradient. <br /></td></tr>
<tr class="separator:a26de227e5135a355667be3a2a86d1431 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4916a23d305f1258ec83b7e53adabea1 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4916a23d305f1258ec83b7e53adabea1"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a4916a23d305f1258ec83b7e53adabea1">getZRemodellingSoFar</a> ()</td></tr>
<tr class="memdesc:a4916a23d305f1258ec83b7e53adabea1 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the z remodelling applied to the element so far, to cap the z remodelling. <br /></td></tr>
<tr class="separator:a4916a23d305f1258ec83b7e53adabea1 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad225c2235e531e5ee239a127bbf92def inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad225c2235e531e5ee239a127bbf92def"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ad225c2235e531e5ee239a127bbf92def">setZRemodellingSoFar</a> (double <a class="el" href="classShapeBase.html#a0dc566eb70e64da9fc3fa222b16999da">zRemodellingSoFar</a>)</td></tr>
<tr class="memdesc:ad225c2235e531e5ee239a127bbf92def inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will set the z remodelling applied to the element so far to input value. This is needed during saved input reading. <br /></td></tr>
<tr class="separator:ad225c2235e531e5ee239a127bbf92def inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a7323c50767ecdc82d8d8ce411b264 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ab8a7323c50767ecdc82d8d8ce411b264">displayName</a> ()</td></tr>
<tr class="memdesc:ab8a7323c50767ecdc82d8d8ce411b264 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function, display the name of the element.  <a href="#ab8a7323c50767ecdc82d8d8ce411b264">More...</a><br /></td></tr>
<tr class="separator:ab8a7323c50767ecdc82d8d8ce411b264 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324f8fd5dd90c14b621b2f2ee3ec98db inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a324f8fd5dd90c14b621b2f2ee3ec98db"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a324f8fd5dd90c14b621b2f2ee3ec98db">displayNodeIds</a> ()</td></tr>
<tr class="memdesc:a324f8fd5dd90c14b621b2f2ee3ec98db inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function, display the Ids of the nodes of the element. <br /></td></tr>
<tr class="separator:a324f8fd5dd90c14b621b2f2ee3ec98db inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4d0f70caf459dc93f914ef7fc2a053 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca4d0f70caf459dc93f914ef7fc2a053"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aca4d0f70caf459dc93f914ef7fc2a053">displayPositions</a> ()</td></tr>
<tr class="memdesc:aca4d0f70caf459dc93f914ef7fc2a053 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function, display the nodal positions of the element. <br /></td></tr>
<tr class="separator:aca4d0f70caf459dc93f914ef7fc2a053 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d221cf63220dad3ecf139ffa164698 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2d221cf63220dad3ecf139ffa164698"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#af2d221cf63220dad3ecf139ffa164698">displayReferencePositions</a> ()</td></tr>
<tr class="memdesc:af2d221cf63220dad3ecf139ffa164698 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function, display the nodal positions of the reference element. <br /></td></tr>
<tr class="separator:af2d221cf63220dad3ecf139ffa164698 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6bb76d8adffaeb7ad36cce8a3f17ab inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba6bb76d8adffaeb7ad36cce8a3f17ab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aba6bb76d8adffaeb7ad36cce8a3f17ab">displayIdentifierColour</a> ()</td></tr>
<tr class="memdesc:aba6bb76d8adffaeb7ad36cce8a3f17ab inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function, display the unique identifier colour, for picking in user interface. <br /></td></tr>
<tr class="separator:aba6bb76d8adffaeb7ad36cce8a3f17ab inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39c3f3a555a89e106c4afaaf81c72f6 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad39c3f3a555a89e106c4afaaf81c72f6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ad39c3f3a555a89e106c4afaaf81c72f6">setFg</a> (gsl_matrix *currFg)</td></tr>
<tr class="memdesc:ad39c3f3a555a89e106c4afaaf81c72f6 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the current grwoth deformation gradient matrix equal to input matrix. <br /></td></tr>
<tr class="separator:ad39c3f3a555a89e106c4afaaf81c72f6 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a100fb162232636bf666eb1603f023 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38a100fb162232636bf666eb1603f023"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a38a100fb162232636bf666eb1603f023">setGrowthWeightsViaTissuePlacement</a> (double periWeight)</td></tr>
<tr class="memdesc:a38a100fb162232636bf666eb1603f023 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the weight for growth rate scaling depending on tissue type. <br /></td></tr>
<tr class="separator:a38a100fb162232636bf666eb1603f023 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27bc09051d65ebc27e31b67462950070 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27bc09051d65ebc27e31b67462950070"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a27bc09051d65ebc27e31b67462950070">setYoungsModulus</a> (double <a class="el" href="classShapeBase.html#a6c1a3a0173841d6072a5268978463ff2">E</a>)</td></tr>
<tr class="memdesc:a27bc09051d65ebc27e31b67462950070 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the Young's modulus of the shape to inout double. <br /></td></tr>
<tr class="separator:a27bc09051d65ebc27e31b67462950070 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e051a82edb9b987edfbd783076e348 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ac4e051a82edb9b987edfbd783076e348">setViscosity</a> (double viscosityApical, double viscosityBasal, double viscosityMid)</td></tr>
<tr class="memdesc:ac4e051a82edb9b987edfbd783076e348 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the viscosity of the element depending on its placement in the tissue.  <a href="#ac4e051a82edb9b987edfbd783076e348">More...</a><br /></td></tr>
<tr class="separator:ac4e051a82edb9b987edfbd783076e348 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6ffc8d699795e4efb867efd065a679 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a8b6ffc8d699795e4efb867efd065a679">setViscosity</a> (double viscosityApical, double viscosityBasal)</td></tr>
<tr class="memdesc:a8b6ffc8d699795e4efb867efd065a679 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the viscosity of the element depending on its placement in the tissue.  <a href="#a8b6ffc8d699795e4efb867efd065a679">More...</a><br /></td></tr>
<tr class="separator:a8b6ffc8d699795e4efb867efd065a679 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17e8a052b0a2bf5b11f6d5498d61923 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae17e8a052b0a2bf5b11f6d5498d61923"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ae17e8a052b0a2bf5b11f6d5498d61923">setViscosity</a> (double viscosity)</td></tr>
<tr class="memdesc:ae17e8a052b0a2bf5b11f6d5498d61923 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the viscosity of the element depending on its placement in the tissue. <br /></td></tr>
<tr class="separator:ae17e8a052b0a2bf5b11f6d5498d61923 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eecbff8db98871f4b5f1ee0992f3d6d inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a3eecbff8db98871f4b5f1ee0992f3d6d">calculateEmergentShapeOrientation</a> ()</td></tr>
<tr class="memdesc:a3eecbff8db98871f4b5f1ee0992f3d6d inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This fucntion calculates the orientation of the emergent shape of an element in the xy plane of the tissue.  <a href="#a3eecbff8db98871f4b5f1ee0992f3d6d">More...</a><br /></td></tr>
<tr class="separator:a3eecbff8db98871f4b5f1ee0992f3d6d inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9cfd1ae56e018477dd3642d4d769d90 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ae9cfd1ae56e018477dd3642d4d769d90">isActinStiffnessChangeAppliedToElement</a> (bool ThereIsWholeTissueStiffnessPerturbation, bool ThereIsApicalStiffnessPerturbation, bool ThereIsBasalStiffnessPerturbation, bool ThereIsBasolateralWithApicalRelaxationStiffnessPerturbation, bool ThereIsBasolateralStiffnessPerturbation, std::vector&lt; int &gt; &amp;stiffnessPerturbationEllipseBandIds, int numberOfStiffnessPerturbationAppliesEllipseBands)</td></tr>
<tr class="memdesc:ae9cfd1ae56e018477dd3642d4d769d90 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function decides if the actin stiffness perturbation is applied to this element.  <a href="#ae9cfd1ae56e018477dd3642d4d769d90">More...</a><br /></td></tr>
<tr class="separator:ae9cfd1ae56e018477dd3642d4d769d90 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1572ddb1f68178e0607873a432f227c inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1572ddb1f68178e0607873a432f227c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ab1572ddb1f68178e0607873a432f227c">isECMChangeAppliedToElement</a> (bool changeApicalECM, bool changeBasalECM, std::vector&lt; int &gt; &amp;ECMChangeEllipseBandIds, int numberOfECMChangeEllipseBands)</td></tr>
<tr class="memdesc:ab1572ddb1f68178e0607873a432f227c inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function decides if the ECM perturbation is applied to this element. <br /></td></tr>
<tr class="separator:ab1572ddb1f68178e0607873a432f227c inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff9e4c602276e9aec411d7a05e83a118 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff9e4c602276e9aec411d7a05e83a118"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aff9e4c602276e9aec411d7a05e83a118">isShapeChangeAppliedToElement</a> (std::vector&lt; int &gt; &amp;ellipseBandIds, bool applyBasalECM, bool applyToLateralECM, bool applyApically, bool applyBasally, bool applyMidLayer)</td></tr>
<tr class="memdesc:aff9e4c602276e9aec411d7a05e83a118 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function decides if the shape change perturbation is applied to this element. <br /></td></tr>
<tr class="separator:aff9e4c602276e9aec411d7a05e83a118 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef460b84dc469f89742af7c19411454f inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aef460b84dc469f89742af7c19411454f">calculateStiffnessPerturbationRate</a> (bool ThereIsBasolateralWithApicalRelaxationStiffnessPerturbation, double stiffnessPerturbationBeginTimeInSec, double stiffnessPerturbationEndTimeInSec, double stiffnessChangedToFractionOfOriginal)</td></tr>
<tr class="memdesc:aef460b84dc469f89742af7c19411454f inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will calciulate the stiffness perturbation rate.  <a href="#aef460b84dc469f89742af7c19411454f">More...</a><br /></td></tr>
<tr class="separator:aef460b84dc469f89742af7c19411454f inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb97c0c1a988e77126809745b191c02 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4eb97c0c1a988e77126809745b191c02"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a4eb97c0c1a988e77126809745b191c02">updateStiffnessMultiplier</a> (double dt)</td></tr>
<tr class="memdesc:a4eb97c0c1a988e77126809745b191c02 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function will update the actin multiplier as a result of stiffness perturbations. <br /></td></tr>
<tr class="separator:a4eb97c0c1a988e77126809745b191c02 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c05f660fb3d68482c8ba751b68b2ed inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2c05f660fb3d68482c8ba751b68b2ed"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ac2c05f660fb3d68482c8ba751b68b2ed">calculateCurrentGrowthIncrement</a> (gsl_matrix *resultingGrowthIncrement, double dt, double growthx, double growthy, double growthz, gsl_matrix *ShearAngleRotationMatrix)</td></tr>
<tr class="memdesc:ac2c05f660fb3d68482c8ba751b68b2ed inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function calculates the current growth increment from the input of growth rate and the orientation rotation matrix. <br /></td></tr>
<tr class="separator:ac2c05f660fb3d68482c8ba751b68b2ed inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227d409b04d95e3110db851a9cb3ed8c inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a227d409b04d95e3110db851a9cb3ed8c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateShapeChangeRate</b> (double x, double y, double z, double xy, double yz, double xz)</td></tr>
<tr class="separator:a227d409b04d95e3110db851a9cb3ed8c inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ffd31ed76797d558b085fe754cc4b3 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a58ffd31ed76797d558b085fe754cc4b3">calculateCurrentGrownAndEmergentVolumes</a> ()</td></tr>
<tr class="memdesc:a58ffd31ed76797d558b085fe754cc4b3 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function to calculate hte current ideal volume of the element and its current apparent volume.  <a href="#a58ffd31ed76797d558b085fe754cc4b3">More...</a><br /></td></tr>
<tr class="separator:a58ffd31ed76797d558b085fe754cc4b3 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e7d2fb83a97d57922c145dcc9be2f09 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e7d2fb83a97d57922c145dcc9be2f09"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a5e7d2fb83a97d57922c145dcc9be2f09">writeInternalForcesTogeAndgv</a> (gsl_matrix *ge, gsl_matrix *gvInternal, std::vector&lt; std::array&lt; double, 3 &gt;&gt; &amp;SystemForces, const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes)</td></tr>
<tr class="memdesc:a5e7d2fb83a97d57922c145dcc9be2f09 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes the elemental elastic and viscous forces to the system scale force vector. <br /></td></tr>
<tr class="separator:a5e7d2fb83a97d57922c145dcc9be2f09 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e69d4ab492428c657941fa3b9423cef inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e69d4ab492428c657941fa3b9423cef"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>calculateForces</b> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes, gsl_matrix *displacementPerDt)</td></tr>
<tr class="separator:a7e69d4ab492428c657941fa3b9423cef inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14199858399bf70d6cc1b33cfdd6bf01 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14199858399bf70d6cc1b33cfdd6bf01"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a14199858399bf70d6cc1b33cfdd6bf01">updatePositions</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes)</td></tr>
<tr class="memdesc:a14199858399bf70d6cc1b33cfdd6bf01 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function updates the position array of the element from the updated nodal posiitons. <br /></td></tr>
<tr class="separator:a14199858399bf70d6cc1b33cfdd6bf01 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac06c53088788e3c1461233623f506dbb inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac06c53088788e3c1461233623f506dbb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ac06c53088788e3c1461233623f506dbb">setGrowthRate</a> (double dt, double rx, double ry, double rz)</td></tr>
<tr class="memdesc:ac06c53088788e3c1461233623f506dbb inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the growth of the element from the tome step and the input rates. <br /></td></tr>
<tr class="separator:ac06c53088788e3c1461233623f506dbb inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9572e9a52675224dfada4f4de366f05d inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9572e9a52675224dfada4f4de366f05d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a9572e9a52675224dfada4f4de366f05d">setGrowthRateViaInputTimeMultipliedMagnitude</a> (double x, double y, double z)</td></tr>
<tr class="memdesc:a9572e9a52675224dfada4f4de366f05d inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the growht rate to pre-calculated rates given as input. <br /></td></tr>
<tr class="separator:a9572e9a52675224dfada4f4de366f05d inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d7957431a1ae402347efb03ad94d0e inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7d7957431a1ae402347efb03ad94d0e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ad7d7957431a1ae402347efb03ad94d0e">updateGrowthIncrementFromRate</a> ()</td></tr>
<tr class="memdesc:ad7d7957431a1ae402347efb03ad94d0e inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function fills th egrowht increment matirx from the current growth rate matrix. <br /></td></tr>
<tr class="separator:ad7d7957431a1ae402347efb03ad94d0e inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda828c652c3253076530000226a5dbb inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeda828c652c3253076530000226a5dbb"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aeda828c652c3253076530000226a5dbb">calculateVolumeForInputShapeStructure</a> (std::vector&lt; std::array&lt; double, 3 &gt;&gt; shapePositions, size_t nTriangularFaces, std::vector&lt; std::array&lt; int, 3 &gt;&gt; triangularFaces, std::array&lt; double, 3 &gt; midPoint)</td></tr>
<tr class="memdesc:aeda828c652c3253076530000226a5dbb inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the volume of the shape, it is generalised such that the shape is defined as an array of triengles forming a convex hull. <br /></td></tr>
<tr class="separator:aeda828c652c3253076530000226a5dbb inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cde54fe712bac297fa73949d07c1bd4 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3cde54fe712bac297fa73949d07c1bd4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a3cde54fe712bac297fa73949d07c1bd4">calculatePrincipalStrains3D</a> (double &amp;e1, double &amp;e2, double &amp;e3, gsl_matrix *eigenVec)</td></tr>
<tr class="memdesc:a3cde54fe712bac297fa73949d07c1bd4 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the principal components of the strains through eigen values and eigen vectors in 3D. <br /></td></tr>
<tr class="separator:a3cde54fe712bac297fa73949d07c1bd4 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe833f9684db5cc1847761b6bbd9aa9 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fe833f9684db5cc1847761b6bbd9aa9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a6fe833f9684db5cc1847761b6bbd9aa9">calculatePrincipalStrains2D</a> (double &amp;e1, double &amp;e2, double &amp;e3, gsl_matrix *eigenVec)</td></tr>
<tr class="memdesc:a6fe833f9684db5cc1847761b6bbd9aa9 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the principal components of the strains through eigen values and eigen vectors in 2D. <br /></td></tr>
<tr class="separator:a6fe833f9684db5cc1847761b6bbd9aa9 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9f91384133d8953dbb38d71cc29d51 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a9f91384133d8953dbb38d71cc29d51"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a8a9f91384133d8953dbb38d71cc29d51">setShapeChangeRate</a> (double x, double y, double z, double xy, double yz, double xz)</td></tr>
<tr class="memdesc:a8a9f91384133d8953dbb38d71cc29d51 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the shape change rate to pre-calculated rates given as input. <br /></td></tr>
<tr class="separator:a8a9f91384133d8953dbb38d71cc29d51 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adacee19f788f056fe794bde14b934063 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adacee19f788f056fe794bde14b934063"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#adacee19f788f056fe794bde14b934063">setShapeChangeInrementToIdentity</a> ()</td></tr>
<tr class="memdesc:adacee19f788f056fe794bde14b934063 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the shape change deformation gradient increment to identity. <br /></td></tr>
<tr class="separator:adacee19f788f056fe794bde14b934063 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3292b2b5d9fd3430a21914031614ccdd inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3292b2b5d9fd3430a21914031614ccdd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a3292b2b5d9fd3430a21914031614ccdd">updateElementVolumesAndTissuePlacementsForSave</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes)</td></tr>
<tr class="memdesc:a3292b2b5d9fd3430a21914031614ccdd inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the reference volume, tissue placement and tissue type from nodal information. <br /></td></tr>
<tr class="separator:a3292b2b5d9fd3430a21914031614ccdd inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fba51323da7719de06fba53077eebc4 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4fba51323da7719de06fba53077eebc4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a4fba51323da7719de06fba53077eebc4">readNodeIdData</a> (std::ifstream &amp;file)</td></tr>
<tr class="memdesc:a4fba51323da7719de06fba53077eebc4 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads in the node Ids for the element from save file. <br /></td></tr>
<tr class="separator:a4fba51323da7719de06fba53077eebc4 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123de76dba6d7d9242c2931d79e47e37 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a123de76dba6d7d9242c2931d79e47e37"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a123de76dba6d7d9242c2931d79e47e37">readReferencePositionData</a> (std::ifstream &amp;file)</td></tr>
<tr class="memdesc:a123de76dba6d7d9242c2931d79e47e37 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads the reference element positions from save file. <br /></td></tr>
<tr class="separator:a123de76dba6d7d9242c2931d79e47e37 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aeacce216911def0e0c54b1bb4286bd inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4aeacce216911def0e0c54b1bb4286bd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a4aeacce216911def0e0c54b1bb4286bd">areanyOfMyNodesAtCircumference</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; &gt; &amp;Nodes)</td></tr>
<tr class="memdesc:a4aeacce216911def0e0c54b1bb4286bd inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function check if the element owns any node at tissue circumference. <br /></td></tr>
<tr class="separator:a4aeacce216911def0e0c54b1bb4286bd inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfdde187477364a5a0e2220ea6b2e0e inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2bfdde187477364a5a0e2220ea6b2e0e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a2bfdde187477364a5a0e2220ea6b2e0e">writeKelasticToMainKatrix</a> (gsl_matrix *K)</td></tr>
<tr class="memdesc:a2bfdde187477364a5a0e2220ea6b2e0e inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes the elemental elastic component of the Jacobian to system Jacobian. <br /></td></tr>
<tr class="separator:a2bfdde187477364a5a0e2220ea6b2e0e inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388d38c2d6588c7ddf622f1deed53853 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a388d38c2d6588c7ddf622f1deed53853"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a388d38c2d6588c7ddf622f1deed53853">writeKviscousToMainKatrix</a> (gsl_matrix *K)</td></tr>
<tr class="memdesc:a388d38c2d6588c7ddf622f1deed53853 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes the elemental viscous component of the Jacobian to system Jacobian. <br /></td></tr>
<tr class="separator:a388d38c2d6588c7ddf622f1deed53853 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922c41864d4826725cc72089046f818c inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a922c41864d4826725cc72089046f818c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a922c41864d4826725cc72089046f818c">calculateImplicitKElastic</a> ()</td></tr>
<tr class="memdesc:a922c41864d4826725cc72089046f818c inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the elemental elastic component of the Jacobian for implicit NR itaration. <br /></td></tr>
<tr class="separator:a922c41864d4826725cc72089046f818c inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c23d30b7f9f3bc7ed2fde542401aeb inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a20c23d30b7f9f3bc7ed2fde542401aeb">calculateImplicitKViscous</a> (gsl_matrix *displacementPerDt, double dt)</td></tr>
<tr class="memdesc:a20c23d30b7f9f3bc7ed2fde542401aeb inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the elemental viscous component of the Jacobian for implicit NR itaration.  <a href="#a20c23d30b7f9f3bc7ed2fde542401aeb">More...</a><br /></td></tr>
<tr class="separator:a20c23d30b7f9f3bc7ed2fde542401aeb inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9f16ddb320974584323d78ca4aec9c inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a9f16ddb320974584323d78ca4aec9c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a6a9f16ddb320974584323d78ca4aec9c">calculateForceFromStress</a> (int nodeId, gsl_matrix *Externalstress, gsl_matrix *ExternalNodalForces)</td></tr>
<tr class="memdesc:a6a9f16ddb320974584323d78ca4aec9c inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the elemental nodal forces from an input external stress matrix. <br /></td></tr>
<tr class="separator:a6a9f16ddb320974584323d78ca4aec9c inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570d553851b58e0c12f45f2d70344eea inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a570d553851b58e0c12f45f2d70344eea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a570d553851b58e0c12f45f2d70344eea">updateShapeFromSave</a> (std::ifstream &amp;file)</td></tr>
<tr class="memdesc:a570d553851b58e0c12f45f2d70344eea inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function updates the element geometric poroerties from save file. <br /></td></tr>
<tr class="separator:a570d553851b58e0c12f45f2d70344eea inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1912b0fe9cfe98ed4b377774c2f0c7 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef1912b0fe9cfe98ed4b377774c2f0c7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aef1912b0fe9cfe98ed4b377774c2f0c7">displayMatrix</a> (boost::numeric::ublas::matrix&lt; double &gt; &amp;mat, std::string matname)</td></tr>
<tr class="memdesc:aef1912b0fe9cfe98ed4b377774c2f0c7 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function, displays the input blas (double) matrix with the input name. <br /></td></tr>
<tr class="separator:aef1912b0fe9cfe98ed4b377774c2f0c7 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b74c35e2d5a2abed9c521c735f1954a inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b74c35e2d5a2abed9c521c735f1954a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a2b74c35e2d5a2abed9c521c735f1954a">displayMatrix</a> (boost::numeric::ublas::matrix&lt; int &gt; &amp;mat, std::string matname)</td></tr>
<tr class="memdesc:a2b74c35e2d5a2abed9c521c735f1954a inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function, displays the input blas (int) matrix with the input name. <br /></td></tr>
<tr class="separator:a2b74c35e2d5a2abed9c521c735f1954a inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662efa15155aa6e90ccc1102563dada8 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a662efa15155aa6e90ccc1102563dada8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a662efa15155aa6e90ccc1102563dada8">displayMatrix</a> (boost::numeric::ublas::vector&lt; double &gt; &amp;vec, std::string matname)</td></tr>
<tr class="memdesc:a662efa15155aa6e90ccc1102563dada8 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function, displays the input blas (double) vector with the input name. <br /></td></tr>
<tr class="separator:a662efa15155aa6e90ccc1102563dada8 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb781fb01957dfb519eb1863bb64d7ab inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb781fb01957dfb519eb1863bb64d7ab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#abb781fb01957dfb519eb1863bb64d7ab">displayMatrix</a> (gsl_matrix *mat, std::string matname)</td></tr>
<tr class="memdesc:abb781fb01957dfb519eb1863bb64d7ab inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function, displays the input gsl matrix with the input name. <br /></td></tr>
<tr class="separator:abb781fb01957dfb519eb1863bb64d7ab inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0283ac144e865859f4e7bb455e06bee9 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0283ac144e865859f4e7bb455e06bee9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a0283ac144e865859f4e7bb455e06bee9">displayMatrix</a> (gsl_vector *mat, std::string matname)</td></tr>
<tr class="memdesc:a0283ac144e865859f4e7bb455e06bee9 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function, displays the input gsl vector with the input name. <br /></td></tr>
<tr class="separator:a0283ac144e865859f4e7bb455e06bee9 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b37ec963a6078a7e03512d23470c257 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b37ec963a6078a7e03512d23470c257"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a4b37ec963a6078a7e03512d23470c257">createMatrixCopy</a> (gsl_matrix *dest, gsl_matrix *src)</td></tr>
<tr class="memdesc:a4b37ec963a6078a7e03512d23470c257 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function, creates a copy of the gsl matrix on new memory locaiton. <br /></td></tr>
<tr class="separator:a4b37ec963a6078a7e03512d23470c257 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f6cfbda8b021fd4e55ca1e3676f7c6 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31f6cfbda8b021fd4e55ca1e3676f7c6"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a31f6cfbda8b021fd4e55ca1e3676f7c6">calculateMagnitudeVector3D</a> (std::array&lt; double, 3 &gt; <a class="el" href="classShapeBase.html#a8b4c2d3bfbc6c9785c5181a56f929151">v</a>)</td></tr>
<tr class="memdesc:a31f6cfbda8b021fd4e55ca1e3676f7c6 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper algebraic function, calculates norm of the vector defined in the array&lt;double,3&gt;;. <br /></td></tr>
<tr class="separator:a31f6cfbda8b021fd4e55ca1e3676f7c6 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7ca6bbc30107ed82e73694f9c34717 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e7ca6bbc30107ed82e73694f9c34717"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a9e7ca6bbc30107ed82e73694f9c34717">normaliseVector3D</a> (gsl_vector *<a class="el" href="classShapeBase.html#a8b4c2d3bfbc6c9785c5181a56f929151">v</a>)</td></tr>
<tr class="memdesc:a9e7ca6bbc30107ed82e73694f9c34717 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper algebraic function, normalises the input gsl vector (the input vector is modified) <br /></td></tr>
<tr class="separator:a9e7ca6bbc30107ed82e73694f9c34717 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefffe34f00f3e65c0894dacdc5f5bf5 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acefffe34f00f3e65c0894dacdc5f5bf5"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#acefffe34f00f3e65c0894dacdc5f5bf5">normaliseVector3D</a> (std::array&lt; double, 3 &gt; &amp;<a class="el" href="classShapeBase.html#a8b4c2d3bfbc6c9785c5181a56f929151">v</a>)</td></tr>
<tr class="memdesc:acefffe34f00f3e65c0894dacdc5f5bf5 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper algebraic function, normalises the input array&lt;double,3&gt; (the input vector is modified) <br /></td></tr>
<tr class="separator:acefffe34f00f3e65c0894dacdc5f5bf5 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c436dca2006e445f7949bc34f08e3c inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38c436dca2006e445f7949bc34f08e3c"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a38c436dca2006e445f7949bc34f08e3c">getNormVector3D</a> (gsl_vector *<a class="el" href="classShapeBase.html#a8b4c2d3bfbc6c9785c5181a56f929151">v</a>)</td></tr>
<tr class="memdesc:a38c436dca2006e445f7949bc34f08e3c inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper algebraic function, calculates norm of the vector defined in the gsl vector, the vector is not modified. <br /></td></tr>
<tr class="separator:a38c436dca2006e445f7949bc34f08e3c inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86161effaf1c7c607aba51609a99e70 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad86161effaf1c7c607aba51609a99e70"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ad86161effaf1c7c607aba51609a99e70">determinant3by3Matrix</a> (boost::numeric::ublas::matrix&lt; double &gt; &amp;Mat)</td></tr>
<tr class="memdesc:ad86161effaf1c7c607aba51609a99e70 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper algebraic function, calculates determinant of 3by3 boost matrix. <br /></td></tr>
<tr class="separator:ad86161effaf1c7c607aba51609a99e70 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52dce091d2e8369f546df9adeb1e6c0 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af52dce091d2e8369f546df9adeb1e6c0"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#af52dce091d2e8369f546df9adeb1e6c0">determinant3by3Matrix</a> (gsl_matrix *Mat)</td></tr>
<tr class="memdesc:af52dce091d2e8369f546df9adeb1e6c0 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper algebraic function, calculates determinant of 3by3 gsl matrix. <br /></td></tr>
<tr class="separator:af52dce091d2e8369f546df9adeb1e6c0 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f1a594c4be91e71f567cc04290a7f5 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32f1a594c4be91e71f567cc04290a7f5"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a32f1a594c4be91e71f567cc04290a7f5">determinant2by2Matrix</a> (boost::numeric::ublas::matrix&lt; double &gt; &amp;Mat)</td></tr>
<tr class="memdesc:a32f1a594c4be91e71f567cc04290a7f5 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper algebraic function, calculates determinant of 2by2 boost matrix. <br /></td></tr>
<tr class="separator:a32f1a594c4be91e71f567cc04290a7f5 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8334f4c3c865792f57ffb456ea61212b inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8334f4c3c865792f57ffb456ea61212b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>calculateRotationAngleSinCos</b> (std::array&lt; double, 3 &gt; &amp;u, std::array&lt; double, 3 &gt; &amp;<a class="el" href="classShapeBase.html#a8b4c2d3bfbc6c9785c5181a56f929151">v</a>, double &amp;c, double &amp;s)</td></tr>
<tr class="separator:a8334f4c3c865792f57ffb456ea61212b inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06df78e90e5d7bcb9898c2844ecf2e60 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06df78e90e5d7bcb9898c2844ecf2e60"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a06df78e90e5d7bcb9898c2844ecf2e60">calculateRotationAxis</a> (const std::array&lt; double, 3 &gt; &amp;u, const std::array&lt; double, 3 &gt; &amp;<a class="el" href="classShapeBase.html#a8b4c2d3bfbc6c9785c5181a56f929151">v</a>, std::array&lt; double, 3 &gt; &amp;rotAx, double c)</td></tr>
<tr class="memdesc:a06df78e90e5d7bcb9898c2844ecf2e60 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper algebraic function calculates the sine and cosine of the rotation angle needed to align vector u onto v. <br /></td></tr>
<tr class="separator:a06df78e90e5d7bcb9898c2844ecf2e60 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ea30d81c19c9f7c904af66310c750b inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ac5ea30d81c19c9f7c904af66310c750b">constructRotationMatrix</a> (double c, double s, double *rotAx, double *rotMat)</td></tr>
<tr class="memdesc:ac5ea30d81c19c9f7c904af66310c750b inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper algebraic function calculates the rotation axis needed to align vector u onto v.  <a href="#ac5ea30d81c19c9f7c904af66310c750b">More...</a><br /></td></tr>
<tr class="separator:ac5ea30d81c19c9f7c904af66310c750b inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c9e11497d04d084fdfe72654bbfb174 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c9e11497d04d084fdfe72654bbfb174"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a4c9e11497d04d084fdfe72654bbfb174">constructRotationMatrix</a> (double c, double s, std::array&lt; double, 3 &gt; &amp;rotAx, std::array&lt; double, 9 &gt; &amp;rotMat)</td></tr>
<tr class="memdesc:a4c9e11497d04d084fdfe72654bbfb174 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper algebraic functio calculates the rotation matrix from input sine, cosine of the rotation angle and the rotation axis. Writes the matrix into the input rotMat. <br /></td></tr>
<tr class="separator:a4c9e11497d04d084fdfe72654bbfb174 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad803a237b7e7c06d419a308625a599e0 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad803a237b7e7c06d419a308625a599e0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ad803a237b7e7c06d419a308625a599e0">rotateVectorByRotationMatrix</a> (double *u, double *rotMat)</td></tr>
<tr class="memdesc:ad803a237b7e7c06d419a308625a599e0 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper algebraic function rotates the input vector v by rotation matrix rotMat. <br /></td></tr>
<tr class="separator:ad803a237b7e7c06d419a308625a599e0 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a573072213ea91314c8f1101f106bb inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14a573072213ea91314c8f1101f106bb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a14a573072213ea91314c8f1101f106bb">rotateVectorByRotationMatrix</a> (double *u, gsl_matrix *rotMat)</td></tr>
<tr class="memdesc:a14a573072213ea91314c8f1101f106bb inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper algebraic function rotates the input vector v by rotation matrix rotMat. <br /></td></tr>
<tr class="separator:a14a573072213ea91314c8f1101f106bb inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb9c0192df7d4de8232b52e7e3009ec5 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb9c0192df7d4de8232b52e7e3009ec5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#adb9c0192df7d4de8232b52e7e3009ec5">rotateVectorByRotationMatrix</a> (std::array&lt; double, 3 &gt; &amp;u, std::array&lt; double, 9 &gt; rotMat)</td></tr>
<tr class="memdesc:adb9c0192df7d4de8232b52e7e3009ec5 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper algebraic function rotates the input vector v by rotation matrix rotMat. <br /></td></tr>
<tr class="separator:adb9c0192df7d4de8232b52e7e3009ec5 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae4c5fc8817528493502e3f75c9a984 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a9ae4c5fc8817528493502e3f75c9a984">CalculateGrowthRotationByF</a> ()</td></tr>
<tr class="memdesc:a9ae4c5fc8817528493502e3f75c9a984 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the rigid body rotation of the element around the z axis of the tissue from hte fecormation gradient.  <a href="#a9ae4c5fc8817528493502e3f75c9a984">More...</a><br /></td></tr>
<tr class="separator:a9ae4c5fc8817528493502e3f75c9a984 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5e95f38f271d28f2856109b0256aa0 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f5e95f38f271d28f2856109b0256aa0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a5f5e95f38f271d28f2856109b0256aa0">calculateTriPointFForRatation</a> ()</td></tr>
<tr class="memdesc:a5f5e95f38f271d28f2856109b0256aa0 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the current deformaiton gradient as averaged at all Gauss points, for rigid body rotation extraction. <br /></td></tr>
<tr class="separator:a5f5e95f38f271d28f2856109b0256aa0 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36cea09cbf418a9e37454016c5b3f30 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa36cea09cbf418a9e37454016c5b3f30"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aa36cea09cbf418a9e37454016c5b3f30">setPlasticDeformationIncrement</a> (double xx, double yy, double zz)</td></tr>
<tr class="memdesc:aa36cea09cbf418a9e37454016c5b3f30 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets diagonal of the plastic deformation gradient increment from input values. <br /></td></tr>
<tr class="separator:aa36cea09cbf418a9e37454016c5b3f30 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ee0eeca30fdd381d294b383c3baf0c inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a29ee0eeca30fdd381d294b383c3baf0c">growShapeByFg</a> ()</td></tr>
<tr class="memdesc:a29ee0eeca30fdd381d294b383c3baf0c inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function updates the current growth deformaiton gradient with the growt/shape change/plastic deformation increments and their respective rotations.  <a href="#a29ee0eeca30fdd381d294b383c3baf0c">More...</a><br /></td></tr>
<tr class="separator:a29ee0eeca30fdd381d294b383c3baf0c inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5409de18ee9e47af0bb977f4a1e608fb inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a5409de18ee9e47af0bb977f4a1e608fb">changeShapeByFsc</a> (double dt)</td></tr>
<tr class="memdesc:a5409de18ee9e47af0bb977f4a1e608fb inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the shape change increment from shape change rates.  <a href="#a5409de18ee9e47af0bb977f4a1e608fb">More...</a><br /></td></tr>
<tr class="separator:a5409de18ee9e47af0bb977f4a1e608fb inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff5db36385d757b38b7caa117686ec1 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afff5db36385d757b38b7caa117686ec1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#afff5db36385d757b38b7caa117686ec1">checkIfInsideEllipseBands</a> (int nMarkerEllipseRanges, std::vector&lt; double &gt; markerEllipseBandXCentres, std::vector&lt; double &gt; markerEllipseBandR1Ranges, std::vector&lt; double &gt; markerEllipseBandR2Ranges, const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes)</td></tr>
<tr class="memdesc:afff5db36385d757b38b7caa117686ec1 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if the element is inside any marker bands for perturbatins. <br /></td></tr>
<tr class="separator:afff5db36385d757b38b7caa117686ec1 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7fdc8e749b8b709b6c80248dc2bc3f inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a2e7fdc8e749b8b709b6c80248dc2bc3f">checkZCappingInRemodelling</a> (bool volumeConserved, double zRemodellingLowerThreshold, double zRemodellingUpperThreshold, gsl_matrix *increment, gsl_matrix *eigenVec)</td></tr>
<tr class="memdesc:a2e7fdc8e749b8b709b6c80248dc2bc3f inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if the remodelling of the element in z axis have reached the specified cap.  <a href="#a2e7fdc8e749b8b709b6c80248dc2bc3f">More...</a><br /></td></tr>
<tr class="separator:a2e7fdc8e749b8b709b6c80248dc2bc3f inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1370385074f4bdc2911b567b184308 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade1370385074f4bdc2911b567b184308"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ade1370385074f4bdc2911b567b184308">assignSoftHinge</a> (double lowHingeLimit, double highHingeLimit, double softnessLevel)</td></tr>
<tr class="memdesc:ade1370385074f4bdc2911b567b184308 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function modulates the stiffness of the hinge domain of the tissue with the input level. The domain is defined in relative x position boundaries. <br /></td></tr>
<tr class="separator:ade1370385074f4bdc2911b567b184308 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c9eda4ef1eb0b23620235039bab921 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aa1c9eda4ef1eb0b23620235039bab921">calculatePlasticDeformation3D</a> (bool volumeConserved, double dt, double plasticDeformationHalfLife, double zRemodellingLowerThreshold, double zRemodellingUpperThreshold)</td></tr>
<tr class="memdesc:aa1c9eda4ef1eb0b23620235039bab921 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the plastic deformation (remodelling) from the current elastic deformation gradient.  <a href="#aa1c9eda4ef1eb0b23620235039bab921">More...</a><br /></td></tr>
<tr class="separator:aa1c9eda4ef1eb0b23620235039bab921 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a9f16148650a7acce1ec74aa693930 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9a9f16148650a7acce1ec74aa693930"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ac9a9f16148650a7acce1ec74aa693930">displayDebuggingMatrices</a> ()</td></tr>
<tr class="memdesc:ac9a9f16148650a7acce1ec74aa693930 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function displays a selected set of matricex for debugging purposes. <br /></td></tr>
<tr class="separator:ac9a9f16148650a7acce1ec74aa693930 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4c893952a6afad718a2037e0635296 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed4c893952a6afad718a2037e0635296"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aed4c893952a6afad718a2037e0635296">DoesPointBelogToMe</a> (int IdNode)</td></tr>
<tr class="memdesc:aed4c893952a6afad718a2037e0635296 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if the input node belogs to the element. <br /></td></tr>
<tr class="separator:aed4c893952a6afad718a2037e0635296 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4348dcb67c58e31020346cdc0a5e7cc7 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4348dcb67c58e31020346cdc0a5e7cc7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a4348dcb67c58e31020346cdc0a5e7cc7">assignVolumesToNodes</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes)</td></tr>
<tr class="memdesc:a4348dcb67c58e31020346cdc0a5e7cc7 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function distributes element's total volume among its owner nodes. <br /></td></tr>
<tr class="separator:a4348dcb67c58e31020346cdc0a5e7cc7 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc9c0bb828f73c105321fd5a25be8cc inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bc9c0bb828f73c105321fd5a25be8cc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a4bc9c0bb828f73c105321fd5a25be8cc">calculateZProjectedAreas</a> ()</td></tr>
<tr class="memdesc:a4bc9c0bb828f73c105321fd5a25be8cc inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculated the z-projected (to world xy plane) apical and basal areas of the element. <br /></td></tr>
<tr class="separator:a4bc9c0bb828f73c105321fd5a25be8cc inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb53c1b619993aa5b7afd840771cfb0 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6cb53c1b619993aa5b7afd840771cfb0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a6cb53c1b619993aa5b7afd840771cfb0">assignZProjectedAreas</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes)</td></tr>
<tr class="memdesc:a6cb53c1b619993aa5b7afd840771cfb0 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function distributes element's z-projected areas among its owner nodes. <br /></td></tr>
<tr class="separator:a6cb53c1b619993aa5b7afd840771cfb0 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc759e8bef0a7b02e8153d6bfb4272c inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bc759e8bef0a7b02e8153d6bfb4272c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a4bc759e8bef0a7b02e8153d6bfb4272c">assignElementToConnectedNodes</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes)</td></tr>
<tr class="memdesc:a4bc759e8bef0a7b02e8153d6bfb4272c inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function assigns the element to the nodes it owns, necessary to construc the owner and connectivity list of nodes. <br /></td></tr>
<tr class="separator:a4bc759e8bef0a7b02e8153d6bfb4272c inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f114984fe31a847a9b5485d4622ca1 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a48f114984fe31a847a9b5485d4622ca1">setECMMimicing</a> (bool IsECMMimicing)</td></tr>
<tr class="memdesc:a48f114984fe31a847a9b5485d4622ca1 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This funciton sets the element as an ECM mimicking element (distinct domain in terms of physical characteristics).  <a href="#a48f114984fe31a847a9b5485d4622ca1">More...</a><br /></td></tr>
<tr class="separator:a48f114984fe31a847a9b5485d4622ca1 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42c9ed461be059e0558740ed965a8d6 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac42c9ed461be059e0558740ed965a8d6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ac42c9ed461be059e0558740ed965a8d6">setActinMimicing</a> (bool <a class="el" href="classShapeBase.html#a892e478508ed8a375f0816b330e36ac1">isActinMimicing</a>)</td></tr>
<tr class="memdesc:ac42c9ed461be059e0558740ed965a8d6 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This funciton sets the element as an actin mimicking element (distinct domain in terms of physical characteristics). <br /></td></tr>
<tr class="separator:ac42c9ed461be059e0558740ed965a8d6 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384ff1314700f9c7157e702c277d2819 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a384ff1314700f9c7157e702c277d2819"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a384ff1314700f9c7157e702c277d2819">calculateViscositySurfaces</a> ()</td></tr>
<tr class="memdesc:a384ff1314700f9c7157e702c277d2819 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calls for the assignment of exposed surfaces if the element has viscosity. <br /></td></tr>
<tr class="separator:a384ff1314700f9c7157e702c277d2819 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91f3d3cddf8cc01ce06562185c291ba inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa91f3d3cddf8cc01ce06562185c291ba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aa91f3d3cddf8cc01ce06562185c291ba">assignViscositySurfaceAreaToNodes</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes)</td></tr>
<tr class="memdesc:aa91f3d3cddf8cc01ce06562185c291ba inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function distributes elemenbt's exposed surfaces to nodes. <br /></td></tr>
<tr class="separator:aa91f3d3cddf8cc01ce06562185c291ba inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af616bee3616ec9d1f99628745f330ad7 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af616bee3616ec9d1f99628745f330ad7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#af616bee3616ec9d1f99628745f330ad7">calculateEmergentRotationAngles</a> ()</td></tr>
<tr class="memdesc:af616bee3616ec9d1f99628745f330ad7 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the emergent rotation of the element in xy plane for display purposes. <br /></td></tr>
<tr class="separator:af616bee3616ec9d1f99628745f330ad7 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e339624fd36c39f22a0ef8a40b56329 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e339624fd36c39f22a0ef8a40b56329"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a2e339624fd36c39f22a0ef8a40b56329">updateReferencePositionMatrixFromMeshInput</a> (std::ifstream &amp;file)</td></tr>
<tr class="memdesc:a2e339624fd36c39f22a0ef8a40b56329 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function updates the reference position of the element from save file. <br /></td></tr>
<tr class="separator:a2e339624fd36c39f22a0ef8a40b56329 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea16f414d8c6318719badfef575a090d inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea16f414d8c6318719badfef575a090d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aea16f414d8c6318719badfef575a090d">fillNodeNeighbourhood</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes)</td></tr>
<tr class="memdesc:aea16f414d8c6318719badfef575a090d inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function fills in the node neightbourhood, needed for constrction of the connectivity of nodes. <br /></td></tr>
<tr class="separator:aea16f414d8c6318719badfef575a090d inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe3c0f97f5ea130d95cc74be439c0d1 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fe3c0f97f5ea130d95cc74be439c0d1"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a6fe3c0f97f5ea130d95cc74be439c0d1">dotProduct3D</a> (std::array&lt; double, 3 &gt; &amp;u, std::array&lt; double, 3 &gt; &amp;<a class="el" href="classShapeBase.html#a8b4c2d3bfbc6c9785c5181a56f929151">v</a>)</td></tr>
<tr class="memdesc:a6fe3c0f97f5ea130d95cc74be439c0d1 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper algebraic function, calculates dot product of two arrays &lt;double,3&gt; <br /></td></tr>
<tr class="separator:a6fe3c0f97f5ea130d95cc74be439c0d1 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334a6cec6a698ac49006d8216a93ced9 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a334a6cec6a698ac49006d8216a93ced9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a334a6cec6a698ac49006d8216a93ced9">crossProduct3D</a> (gsl_vector *u, gsl_vector *<a class="el" href="classShapeBase.html#a8b4c2d3bfbc6c9785c5181a56f929151">v</a>, gsl_vector *cross)</td></tr>
<tr class="memdesc:a334a6cec6a698ac49006d8216a93ced9 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper algebraic function, calculates cross product of two gsl_vectors, writes into the third input gls vector. <br /></td></tr>
<tr class="separator:a334a6cec6a698ac49006d8216a93ced9 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52860af5f883c90296e52ddb194568ff inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52860af5f883c90296e52ddb194568ff"></a>
std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a52860af5f883c90296e52ddb194568ff">crossProduct3D</a> (std::array&lt; double, 3 &gt; u, std::array&lt; double, 3 &gt; <a class="el" href="classShapeBase.html#a8b4c2d3bfbc6c9785c5181a56f929151">v</a>)</td></tr>
<tr class="memdesc:a52860af5f883c90296e52ddb194568ff inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper algebraic function, calculates cross product of two arrays &lt;double,3&gt; <br /></td></tr>
<tr class="separator:a52860af5f883c90296e52ddb194568ff inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8763ab46f90adb819ec776a5829573c5 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a8763ab46f90adb819ec776a5829573c5">isElementFlippedInPotentialNewShape</a> (int nodeId, double newX, double newY, double newZ)</td></tr>
<tr class="memdesc:a8763ab46f90adb819ec776a5829573c5 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if the element will plip in the case that its node (nodeID) is moved to the new x,y,z coordintes specified in the input. Necessary in node collapsing.  <a href="#a8763ab46f90adb819ec776a5829573c5">More...</a><br /></td></tr>
<tr class="separator:a8763ab46f90adb819ec776a5829573c5 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346f4ec76554bea282a5cab7ea28dfa2 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a346f4ec76554bea282a5cab7ea28dfa2">checkForCollapsedNodes</a> (int TissueHeightDiscretisationLayers, const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes, const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classShapeBase.html">ShapeBase</a> &gt;&gt; &amp;Elements)</td></tr>
<tr class="memdesc:a346f4ec76554bea282a5cab7ea28dfa2 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if any of the edges of the element is shortened to the extent that it should be collapsed.  <a href="#a346f4ec76554bea282a5cab7ea28dfa2">More...</a><br /></td></tr>
<tr class="separator:a346f4ec76554bea282a5cab7ea28dfa2 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae223927913b48f7044be8aa52a60575c inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae223927913b48f7044be8aa52a60575c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ae223927913b48f7044be8aa52a60575c">hasEnoughNodesOnCurve</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; &gt; &amp;Nodes)</td></tr>
<tr class="memdesc:ae223927913b48f7044be8aa52a60575c inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if the majority of the nodes of teh element reside in a curved region, to assign it to specific curvature dependent perturbations. <br /></td></tr>
<tr class="separator:ae223927913b48f7044be8aa52a60575c inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf53d1dd8f8707d05c6a252b94093282 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf53d1dd8f8707d05c6a252b94093282"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#abf53d1dd8f8707d05c6a252b94093282">assignEllipseBandIdToWholeTissueColumn</a> (size_t TissueHeightDiscretisationLayers, const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes, const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classShapeBase.html">ShapeBase</a> &gt;&gt; &amp;Elements)</td></tr>
<tr class="memdesc:abf53d1dd8f8707d05c6a252b94093282 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function assigns the marker ID of the apical elemetn ot all its connected elements in the tissue hight (all column of the element). <br /></td></tr>
<tr class="separator:abf53d1dd8f8707d05c6a252b94093282 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcdcb7ee31af4717efbd5b3c99698218 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcdcb7ee31af4717efbd5b3c99698218"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#afcdcb7ee31af4717efbd5b3c99698218">assignEllipseBandId</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes, int selectedEllipseBandId)</td></tr>
<tr class="memdesc:afcdcb7ee31af4717efbd5b3c99698218 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function assigns the marking ellipse band ID of the element depending on the definition of nodes it is consturcted of. <br /></td></tr>
<tr class="separator:afcdcb7ee31af4717efbd5b3c99698218 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88977dbe166e6694ad6698b93abfa22 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa88977dbe166e6694ad6698b93abfa22"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aa88977dbe166e6694ad6698b93abfa22">assignEllipseBandIdToNodes</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes)</td></tr>
<tr class="memdesc:aa88977dbe166e6694ad6698b93abfa22 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function assigns the marker ID of the elemetn to all its nodes. <br /></td></tr>
<tr class="separator:aa88977dbe166e6694ad6698b93abfa22 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677fceb50ab5626dbc9c4f8079829d59 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a677fceb50ab5626dbc9c4f8079829d59"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addToElementalElasticSystemForces</b> (int i, int j, double value)</td></tr>
<tr class="separator:a677fceb50ab5626dbc9c4f8079829d59 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8e11261fb35bc925259151218eebf3 inherit pub_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a2e8e11261fb35bc925259151218eebf3">addToTriPointKe</a> (int i, int j, double value)</td></tr>
<tr class="memdesc:a2e8e11261fb35bc925259151218eebf3 inherit pub_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is to add the input value, to the (i,j)th element of the ElementalElasticSystemForces.  <a href="#a2e8e11261fb35bc925259151218eebf3">More...</a><br /></td></tr>
<tr class="separator:a2e8e11261fb35bc925259151218eebf3 inherit pub_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a3c252dc104a1ca7208b23c72737cd916"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#a3c252dc104a1ca7208b23c72737cd916">getCurrRelaxedShape</a> (gsl_matrix *CurrRelaxedShape)</td></tr>
<tr class="memdesc:a3c252dc104a1ca7208b23c72737cd916"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes the current relaxed shape of the elemetn in the gsl_matrix pointed by the provided input gsl_matrix pointer.  <a href="#a3c252dc104a1ca7208b23c72737cd916">More...</a><br /></td></tr>
<tr class="separator:a3c252dc104a1ca7208b23c72737cd916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a4d3411d1f3dc05816ec01dcfa8310"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#aa1a4d3411d1f3dc05816ec01dcfa8310">setShapeFunctionDerivatives</a> (gsl_matrix *ShapeFuncDer, double eta, double zeta, double nu)</td></tr>
<tr class="memdesc:aa1a4d3411d1f3dc05816ec01dcfa8310"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates and writes the shape function derivatives on the gsl_matrix pointed by the provided input gsl_matrix pointer, for the provided barycentric coordinates.  <a href="#aa1a4d3411d1f3dc05816ec01dcfa8310">More...</a><br /></td></tr>
<tr class="separator:aa1a4d3411d1f3dc05816ec01dcfa8310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f76f3cabdd00eb057f41cebbaa466d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#aa1f76f3cabdd00eb057f41cebbaa466d">setShapeFunctionDerivativeStack</a> (gsl_matrix *ShapeFuncDer, gsl_matrix *ShapeFuncDerStack)</td></tr>
<tr class="memdesc:aa1f76f3cabdd00eb057f41cebbaa466d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes the input gsl_matrix ShapeFuncDer into a stack form, in the matrix ShapeFuncDerStack. Both matrices must be allocated prior to calling the function.  <a href="#aa1f76f3cabdd00eb057f41cebbaa466d">More...</a><br /></td></tr>
<tr class="separator:aa1f76f3cabdd00eb057f41cebbaa466d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0575442613f8b7d9428c58cef19ab219"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#a0575442613f8b7d9428c58cef19ab219">setCoeffMat</a> ()</td></tr>
<tr class="memdesc:a0575442613f8b7d9428c58cef19ab219"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes the coefficient matrix that is collating the calculated stresses in the form of the vector form of elemental stress and strain vectors.  <a href="#a0575442613f8b7d9428c58cef19ab219">More...</a><br /></td></tr>
<tr class="separator:a0575442613f8b7d9428c58cef19ab219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf622277c72a0ee0372c0a30a15ae6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1bf622277c72a0ee0372c0a30a15ae6d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#a1bf622277c72a0ee0372c0a30a15ae6d">calculateDVector</a> ()</td></tr>
<tr class="memdesc:a1bf622277c72a0ee0372c0a30a15ae6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the elasticity tensor for a Kirshoff material. <br /></td></tr>
<tr class="separator:a1bf622277c72a0ee0372c0a30a15ae6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad339c17c6a056074dc4e642de9492c57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#ad339c17c6a056074dc4e642de9492c57">calculateD81Tensor</a> ()</td></tr>
<tr class="memdesc:ad339c17c6a056074dc4e642de9492c57"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the Lagrangian elasticity tensor for a neo-hookean material.  <a href="#ad339c17c6a056074dc4e642de9492c57">More...</a><br /></td></tr>
<tr class="separator:ad339c17c6a056074dc4e642de9492c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa433244f86cdf23a611a1adc3391c3f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa433244f86cdf23a611a1adc3391c3f0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#aa433244f86cdf23a611a1adc3391c3f0">calculateCurrk</a> (boost::numeric::ublas::matrix&lt; double &gt; &amp;currk, boost::numeric::ublas::matrix&lt; double &gt; &amp;currB, boost::numeric::ublas::matrix&lt; double &gt; &amp;currBE, boost::numeric::ublas::matrix&lt; double &gt; &amp;currBo, double eta, double zeta, double nu)</td></tr>
<tr class="memdesc:aa433244f86cdf23a611a1adc3391c3f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the elemental jacobian for current Gauss Point. <br /></td></tr>
<tr class="separator:aa433244f86cdf23a611a1adc3391c3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606fbf422f9d652e0f697ea93dc2e088"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#a606fbf422f9d652e0f697ea93dc2e088">calculateCurrNodalForces</a> (gsl_matrix *gslcurrge, gsl_matrix *gslcurrgv, gsl_matrix *gslcurrF, gsl_matrix *displacementPerDt, int pointNo)</td></tr>
<tr class="memdesc:a606fbf422f9d652e0f697ea93dc2e088"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the nodal forces of teh prism for the current Gauss Point.  <a href="#a606fbf422f9d652e0f697ea93dc2e088">More...</a><br /></td></tr>
<tr class="separator:a606fbf422f9d652e0f697ea93dc2e088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9403142a217a005a4d588a6e472be27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#ae9403142a217a005a4d588a6e472be27">calculateCurrTriPointFForRotation</a> (gsl_matrix *currF, int pointNo)</td></tr>
<tr class="memdesc:ae9403142a217a005a4d588a6e472be27"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the deformation gradient of the prism for rigid body rotation rotation extractions, for the current Gauss Point.  <a href="#ae9403142a217a005a4d588a6e472be27">More...</a><br /></td></tr>
<tr class="separator:ae9403142a217a005a4d588a6e472be27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea58fd729a2bbef20530200978a8f75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ea58fd729a2bbef20530200978a8f75"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#a4ea58fd729a2bbef20530200978a8f75">calculateReferenceVolume</a> ()</td></tr>
<tr class="memdesc:a4ea58fd729a2bbef20530200978a8f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculateds the volume of the reference element. <br /></td></tr>
<tr class="separator:a4ea58fd729a2bbef20530200978a8f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76072439f768fd9a6bc6e5c23e3fa617"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76072439f768fd9a6bc6e5c23e3fa617"></a>
std::array&lt; std::array&lt; double, 3 &gt;, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#a76072439f768fd9a6bc6e5c23e3fa617">calculatePlaneNormals</a> ()</td></tr>
<tr class="memdesc:a76072439f768fd9a6bc6e5c23e3fa617"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the plane normals for the triangular surfaces constructing the prism. <br /></td></tr>
<tr class="separator:a76072439f768fd9a6bc6e5c23e3fa617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07401eaf9dde65f81895606575ecf48"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af07401eaf9dde65f81895606575ecf48"></a>
std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#af07401eaf9dde65f81895606575ecf48">assignNodalVector</a> (size_t id0, size_t id1)</td></tr>
<tr class="memdesc:af07401eaf9dde65f81895606575ecf48"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the 3D vector from nodes indexed at id0 to id1. <br /></td></tr>
<tr class="separator:af07401eaf9dde65f81895606575ecf48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1f1f37d08fd9aefebc42cb6f63efab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d1f1f37d08fd9aefebc42cb6f63efab"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#a4d1f1f37d08fd9aefebc42cb6f63efab">checkNodePlaneConsistency</a> (std::array&lt; std::array&lt; double, 3 &gt;, 8 &gt; &amp;normals)</td></tr>
<tr class="memdesc:a4d1f1f37d08fd9aefebc42cb6f63efab"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions checks the planes of the elemetn as part of health check. <br /></td></tr>
<tr class="separator:a4d1f1f37d08fd9aefebc42cb6f63efab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19996bf8336c7c6d3fc11bdc45bf8992"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19996bf8336c7c6d3fc11bdc45bf8992"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#a19996bf8336c7c6d3fc11bdc45bf8992">setInitialEdgeLenghts</a> ()</td></tr>
<tr class="memdesc:a19996bf8336c7c6d3fc11bdc45bf8992"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the initial edge lengths of the element, will be essential in deciding if the elemetn should collapse its surfaces to avoid flipping. <br /></td></tr>
<tr class="separator:a19996bf8336c7c6d3fc11bdc45bf8992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a57c74e857e937883bb4581cd982da1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#a0a57c74e857e937883bb4581cd982da1">checkEdgeLenghtsForBinding</a> (std::vector&lt; int &gt; &amp;masterIds, std::vector&lt; int &gt; &amp;slaveIds)</td></tr>
<tr class="memdesc:a0a57c74e857e937883bb4581cd982da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks the edge lengths of the prism to decide if the elemetn should collapse its surfaces to avoid flipping.  <a href="#a0a57c74e857e937883bb4581cd982da1">More...</a><br /></td></tr>
<tr class="separator:a0a57c74e857e937883bb4581cd982da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc59ccf5e1b5f459a8fb871c2a78fe8e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc59ccf5e1b5f459a8fb871c2a78fe8e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#acc59ccf5e1b5f459a8fb871c2a78fe8e">getApicalSideLengthAverage</a> ()</td></tr>
<tr class="memdesc:acc59ccf5e1b5f459a8fb871c2a78fe8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the average edge length of the apical surface. <br /></td></tr>
<tr class="separator:acc59ccf5e1b5f459a8fb871c2a78fe8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628c31f0b9dbaa6a1fee8adb68cb6cd6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a628c31f0b9dbaa6a1fee8adb68cb6cd6"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#a628c31f0b9dbaa6a1fee8adb68cb6cd6">getBasalSideLengthAverage</a> ()</td></tr>
<tr class="memdesc:a628c31f0b9dbaa6a1fee8adb68cb6cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the average edge length of the basal surface. <br /></td></tr>
<tr class="separator:a628c31f0b9dbaa6a1fee8adb68cb6cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c5d2fbf2d87550855a7ae958c82e13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8c5d2fbf2d87550855a7ae958c82e13"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#af8c5d2fbf2d87550855a7ae958c82e13">assignExposedSurfaceAreaIndices</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes)</td></tr>
<tr class="memdesc:af8c5d2fbf2d87550855a7ae958c82e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function assigns the indices of externally exposed surfaces of the prism. <br /></td></tr>
<tr class="separator:af8c5d2fbf2d87550855a7ae958c82e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classShapeBase"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classShapeBase')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classShapeBase.html">ShapeBase</a></td></tr>
<tr class="memitem:a4cc6c721ed24f27baa71fe9398edd87a inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a4cc6c721ed24f27baa71fe9398edd87a">setShapeType</a> (std::string TypeName)</td></tr>
<tr class="memdesc:a4cc6c721ed24f27baa71fe9398edd87a inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function sets the type of the shape.  <a href="#a4cc6c721ed24f27baa71fe9398edd87a">More...</a><br /></td></tr>
<tr class="separator:a4cc6c721ed24f27baa71fe9398edd87a inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96dae3d137adec217bb0bc6ed2cace97 inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a96dae3d137adec217bb0bc6ed2cace97">readNodeIds</a> (const std::vector&lt; int &gt; &amp;inpNodeIds)</td></tr>
<tr class="memdesc:a96dae3d137adec217bb0bc6ed2cace97 inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function sets the <a class="el" href="classNode.html#a1bd379569cc1a8b96432e61971aed4d9" title="The unique identification number of the node. ">Node::Id</a> array that constructs the shape.  <a href="#a96dae3d137adec217bb0bc6ed2cace97">More...</a><br /></td></tr>
<tr class="separator:a96dae3d137adec217bb0bc6ed2cace97 inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474774dd9db4c42990de569b3d8cd52e inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a474774dd9db4c42990de569b3d8cd52e">setPositionMatrix</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes)</td></tr>
<tr class="memdesc:a474774dd9db4c42990de569b3d8cd52e inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function sets the <a class="el" href="classShapeBase.html#a6a6bd8c65e2a0bfea3a956604bc05cb9" title="The vector storing the positions of the nodes constructing the element. ">ShapeBase::Positions</a> matrix to define the locations of each constructing node.  <a href="#a474774dd9db4c42990de569b3d8cd52e">More...</a><br /></td></tr>
<tr class="separator:a474774dd9db4c42990de569b3d8cd52e inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3777927e49e4b09bfb524b4f4ac889ad inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a3777927e49e4b09bfb524b4f4ac889ad">setTissuePlacement</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes)</td></tr>
<tr class="memdesc:a3777927e49e4b09bfb524b4f4ac889ad inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function sets the placement of the element within the tissue.  <a href="#a3777927e49e4b09bfb524b4f4ac889ad">More...</a><br /></td></tr>
<tr class="separator:a3777927e49e4b09bfb524b4f4ac889ad inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f0b9431be849133a4eab5484fbb1f8 inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ad5f0b9431be849133a4eab5484fbb1f8">setTissueType</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes)</td></tr>
<tr class="memdesc:ad5f0b9431be849133a4eab5484fbb1f8 inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function sets the tissue type of the element.  <a href="#ad5f0b9431be849133a4eab5484fbb1f8">More...</a><br /></td></tr>
<tr class="separator:ad5f0b9431be849133a4eab5484fbb1f8 inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa260269fe9605765f5adb494d1a99737 inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aa260269fe9605765f5adb494d1a99737">setReferencePositionMatrix</a> ()</td></tr>
<tr class="memdesc:aa260269fe9605765f5adb494d1a99737 inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function sets the RefereneceShapeBase::Positions matrix to define the reference positions of the element.  <a href="#aa260269fe9605765f5adb494d1a99737">More...</a><br /></td></tr>
<tr class="separator:aa260269fe9605765f5adb494d1a99737 inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dafd8524fe5aa5326173aa49a8f78a0 inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a8dafd8524fe5aa5326173aa49a8f78a0">setIdentificationColour</a> ()</td></tr>
<tr class="memdesc:a8dafd8524fe5aa5326173aa49a8f78a0 inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function sets the unique <a class="el" href="classShapeBase.html#a8c6daae25e30af2e55599b7d1ecfbddb" title="The unique identifier colour of the element, this is used for &quot;picking&quot; in the visual interface...">ShapeBase::IdentifierColour</a> colour for the element, which is used in element picking from the user interface.  <a href="#a8dafd8524fe5aa5326173aa49a8f78a0">More...</a><br /></td></tr>
<tr class="separator:a8dafd8524fe5aa5326173aa49a8f78a0 inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed871c8f50f35cf1e506528583804ad inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeed871c8f50f35cf1e506528583804ad"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aeed871c8f50f35cf1e506528583804ad">rotateReferenceElementByRotationMatrix</a> (std::array&lt; double, 9 &gt; rotMat)</td></tr>
<tr class="memdesc:aeed871c8f50f35cf1e506528583804ad inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function rotates the reference of the element (<a class="el" href="classShapeBase.html#a93270dee7f71d075c73d1720c8279a44" title="The pointer to the reference shape object that defines th reference shape of this element...">ShapeBase::ReferenceShape</a>) by input rotation matrix, provided as a double pointer of 9 doubles. <br /></td></tr>
<tr class="separator:aeed871c8f50f35cf1e506528583804ad inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab887eaa6a0be56e3b50f549326dbe87a inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab887eaa6a0be56e3b50f549326dbe87a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ab887eaa6a0be56e3b50f549326dbe87a">InvertMatrix</a> (boost::numeric::ublas::matrix&lt; double &gt; &amp;input, boost::numeric::ublas::matrix&lt; double &gt; &amp;inverse)</td></tr>
<tr class="memdesc:ab887eaa6a0be56e3b50f549326dbe87a inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function takes the first input matrix, and writes the inverse on the second input. False is returned if the matrix is not inverted. Input format is ublas matrices (slow). <br /></td></tr>
<tr class="separator:ab887eaa6a0be56e3b50f549326dbe87a inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a890c07a2fa8ac45fa50bdbfe6b0d9 inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0a890c07a2fa8ac45fa50bdbfe6b0d9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ab0a890c07a2fa8ac45fa50bdbfe6b0d9">InvertMatrix</a> (gsl_matrix *input, gsl_matrix *inverse)</td></tr>
<tr class="memdesc:ab0a890c07a2fa8ac45fa50bdbfe6b0d9 inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function takes the first input matrix, and writes the inverse on the second input. False is returned if the matrix is not inverted. Input format is gsl matrices (fast). <br /></td></tr>
<tr class="separator:ab0a890c07a2fa8ac45fa50bdbfe6b0d9 inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92927e610d4e389c32a023554d805fc7 inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92927e610d4e389c32a023554d805fc7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a92927e610d4e389c32a023554d805fc7">updateNodeIdsFromSave</a> (std::ifstream &amp;file)</td></tr>
<tr class="memdesc:a92927e610d4e389c32a023554d805fc7 inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function reads the <a class="el" href="classShapeBase.html#af96e17fa9a23289fb743ff0722a7dc64" title="The vector storing the unique IDs (Node::Id) of nodes constructing this element. Their order is consi...">ShapeBase::NodeIds</a> of the current shape from save file provided as input. <br /></td></tr>
<tr class="separator:a92927e610d4e389c32a023554d805fc7 inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a742964154a791aacdae8e783c19c4 inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93a742964154a791aacdae8e783c19c4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a93a742964154a791aacdae8e783c19c4">updateReferencePositionMatrixFromSave</a> (std::ifstream &amp;file)</td></tr>
<tr class="memdesc:a93a742964154a791aacdae8e783c19c4 inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function reads and updates the <a class="el" href="classShapeBase.html#a93270dee7f71d075c73d1720c8279a44" title="The pointer to the reference shape object that defines th reference shape of this element...">ShapeBase::ReferenceShape</a> positions (<a class="el" href="classReferenceShapeBase.html#a6b20aebb733d845a8e2b7cd4f69722cb" title="The pointer to the position matrix of the reference element. The array itself is declared within the ...">ReferenceShapeBase::Positions</a>) of the current shape from save file provided as input. <br /></td></tr>
<tr class="separator:a93a742964154a791aacdae8e783c19c4 inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf9c7c8ae6a3195ec9c6b6bdaf847ab inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bf9c7c8ae6a3195ec9c6b6bdaf847ab"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a8bf9c7c8ae6a3195ec9c6b6bdaf847ab">calculateGrowthStrainsRotMat</a> (double *<a class="el" href="classShapeBase.html#a8b4c2d3bfbc6c9785c5181a56f929151">v</a>)</td></tr>
<tr class="memdesc:a8bf9c7c8ae6a3195ec9c6b6bdaf847ab inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function calculates the rotation matrix to apply on growth strains to align growth with the current x axis of the tissue. <br /></td></tr>
<tr class="separator:a8bf9c7c8ae6a3195ec9c6b6bdaf847ab inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1afbb15d92215f337090262753eb24ab inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a1afbb15d92215f337090262753eb24ab">calculateForces3D</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes, gsl_matrix *displacementPerDt)</td></tr>
<tr class="memdesc:a1afbb15d92215f337090262753eb24ab inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function calculates the viscous and elastic forces generated by the element.  <a href="#a1afbb15d92215f337090262753eb24ab">More...</a><br /></td></tr>
<tr class="separator:a1afbb15d92215f337090262753eb24ab inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347fb2687678294a252a12820842cb0d inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a347fb2687678294a252a12820842cb0d">calculateEForNodalForcesKirshoff</a> (gsl_matrix *C)</td></tr>
<tr class="memdesc:a347fb2687678294a252a12820842cb0d inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the green strains for a Kirshoff material model.  <a href="#a347fb2687678294a252a12820842cb0d">More...</a><br /></td></tr>
<tr class="separator:a347fb2687678294a252a12820842cb0d inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09cb91359e10677889c3f59c3f5d70a inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ae09cb91359e10677889c3f59c3f5d70a">calculateCauchyGreenDeformationTensor</a> (gsl_matrix *Fe)</td></tr>
<tr class="memdesc:ae09cb91359e10677889c3f59c3f5d70a inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the Caucy-Green deformation tensor, from the elastic part of the deformation gradient.  <a href="#ae09cb91359e10677889c3f59c3f5d70a">More...</a><br /></td></tr>
<tr class="separator:ae09cb91359e10677889c3f59c3f5d70a inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c79b3bced80eac8af18a0a81d3898ab inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a9c79b3bced80eac8af18a0a81d3898ab">calculateSForNodalForcesKirshoff</a> (gsl_matrix *<a class="el" href="classShapeBase.html#a6c1a3a0173841d6072a5268978463ff2">E</a>)</td></tr>
<tr class="memdesc:a9c79b3bced80eac8af18a0a81d3898ab inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the Secons order Piola-Kirshoff stress tensor for Kirshoff material model.  <a href="#a9c79b3bced80eac8af18a0a81d3898ab">More...</a><br /></td></tr>
<tr class="separator:a9c79b3bced80eac8af18a0a81d3898ab inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697f24754441df216b4245e7eb467b13 inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a697f24754441df216b4245e7eb467b13">calculateSForNodalForcesNeoHookean</a> (gsl_matrix *invC, double lnJ)</td></tr>
<tr class="memdesc:a697f24754441df216b4245e7eb467b13 inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the Secons order Piola-Kirshoff stress tensor for Neo-Hookean material model.v.  <a href="#a697f24754441df216b4245e7eb467b13">More...</a><br /></td></tr>
<tr class="separator:a697f24754441df216b4245e7eb467b13 inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606ddc7f909062e9faae9f4a311ccd8a inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a606ddc7f909062e9faae9f4a311ccd8a">updateLagrangianElasticityTensorNeoHookean</a> (gsl_matrix *invC, double lnJ, int pointNo)</td></tr>
<tr class="memdesc:a606ddc7f909062e9faae9f4a311ccd8a inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calcualtes the Lagrangian elasticity tensor for Neo-Hookean material model.  <a href="#a606ddc7f909062e9faae9f4a311ccd8a">More...</a><br /></td></tr>
<tr class="separator:a606ddc7f909062e9faae9f4a311ccd8a inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e588bb8d290158200c6e35826f7566 inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a56e588bb8d290158200c6e35826f7566">calculateCompactStressForNodalForces</a> (double detFe, gsl_matrix *Fe, gsl_matrix *S, gsl_matrix *Stress)</td></tr>
<tr class="memdesc:a56e588bb8d290158200c6e35826f7566 inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates elemental stress in Voigt notation.  <a href="#a56e588bb8d290158200c6e35826f7566">More...</a><br /></td></tr>
<tr class="separator:a56e588bb8d290158200c6e35826f7566 inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9eaa594e8955de91b2f4b0368c85bae inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9eaa594e8955de91b2f4b0368c85bae"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ac9eaa594e8955de91b2f4b0368c85bae">calculateInverseJacobianStackForNodalForces</a> (gsl_matrix *Jacobian)</td></tr>
<tr class="memdesc:ac9eaa594e8955de91b2f4b0368c85bae inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the stack matrix of inverse Jacobians, used to calculate the nodal forces. <br /></td></tr>
<tr class="separator:ac9eaa594e8955de91b2f4b0368c85bae inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67919694a1d780e31f6d539781377be inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad67919694a1d780e31f6d539781377be"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ad67919694a1d780e31f6d539781377be">calculateBTforNodalForces</a> (gsl_matrix *InvJacobianStack, gsl_matrix *ShapeFuncDerStack, gsl_matrix *B, gsl_matrix *invJShFuncDerS)</td></tr>
<tr class="memdesc:ad67919694a1d780e31f6d539781377be inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the B matrix, to calculate the nodal force. <br /></td></tr>
<tr class="separator:ad67919694a1d780e31f6d539781377be inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d984ddba5bbeae91cb3180897a5a3e7 inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d984ddba5bbeae91cb3180897a5a3e7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a8d984ddba5bbeae91cb3180897a5a3e7">calculateInvJShFuncDerSWithFe</a> (gsl_matrix *currFe, gsl_matrix *InvDXde, gsl_matrix *ShapeFuncDerStack, gsl_matrix *invJShFuncDerSWithF)</td></tr>
<tr class="memdesc:a8d984ddba5bbeae91cb3180897a5a3e7 inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the collated matrix from inverse jaconians and shape function derivatives. <br /></td></tr>
<tr class="separator:a8d984ddba5bbeae91cb3180897a5a3e7 inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb0d14adc7ac116191bcff4a7837e98 inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aafb0d14adc7ac116191bcff4a7837e98">calculateVelocityGradientTensor</a> (gsl_matrix *B, gsl_matrix *displacementPerDt)</td></tr>
<tr class="memdesc:aafb0d14adc7ac116191bcff4a7837e98 inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the velocity gradient tensor.  <a href="#aafb0d14adc7ac116191bcff4a7837e98">More...</a><br /></td></tr>
<tr class="separator:aafb0d14adc7ac116191bcff4a7837e98 inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcdbbe37a746ade52a1af70a9aa12b9f inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#afcdbbe37a746ade52a1af70a9aa12b9f">constructElementalDisplacementMatrix</a> (gsl_matrix *displacement)</td></tr>
<tr class="memdesc:afcdbbe37a746ade52a1af70a9aa12b9f inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will assemble elemental node displacement matrix from the input displacement matrix for the whole system.  <a href="#afcdbbe37a746ade52a1af70a9aa12b9f">More...</a><br /></td></tr>
<tr class="separator:afcdbbe37a746ade52a1af70a9aa12b9f inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbf191777e8787a0e8307d30ce0aa9d inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#afbbf191777e8787a0e8307d30ce0aa9d">calculateRateOfDeformationTensor</a> (gsl_matrix *l)</td></tr>
<tr class="memdesc:afbbf191777e8787a0e8307d30ce0aa9d inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will calculate rate of deformation tensor from velocity gradient tensor.  <a href="#afbbf191777e8787a0e8307d30ce0aa9d">More...</a><br /></td></tr>
<tr class="separator:afbbf191777e8787a0e8307d30ce0aa9d inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ffae25fafb0fa584a3a4d0196af7aa inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a22ffae25fafb0fa584a3a4d0196af7aa">calculateViscousStress</a> (gsl_matrix *d, gsl_matrix *<a class="el" href="classShapeBase.html#a29f180dc41c5b6e12b9468dd557bb524">viscousStress</a>)</td></tr>
<tr class="memdesc:a22ffae25fafb0fa584a3a4d0196af7aa inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will calculate internal viscous stress of the element from rate of deformation matrix.  <a href="#a22ffae25fafb0fa584a3a4d0196af7aa">More...</a><br /></td></tr>
<tr class="separator:a22ffae25fafb0fa584a3a4d0196af7aa inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d10225f251fa1bd8a2e6ffc8feb5326 inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a4d10225f251fa1bd8a2e6ffc8feb5326">calculateViscousForces</a> (gsl_matrix *gv, gsl_matrix *BTdetFdetdXde, gsl_matrix *<a class="el" href="classShapeBase.html#a29f180dc41c5b6e12b9468dd557bb524">viscousStress</a>)</td></tr>
<tr class="memdesc:a4d10225f251fa1bd8a2e6ffc8feb5326 inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will calculate the elemental viscous forces from viscous stress.  <a href="#a4d10225f251fa1bd8a2e6ffc8feb5326">More...</a><br /></td></tr>
<tr class="separator:a4d10225f251fa1bd8a2e6ffc8feb5326 inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae9fb15fa6e3f99173841ea910710c1 inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ae9fb15fa6e3f99173841ea910710c1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a7ae9fb15fa6e3f99173841ea910710c1">consturctBaTBb</a> (gsl_matrix *B, gsl_matrix *BaT, gsl_matrix *Bb, int a, int b)</td></tr>
<tr class="memdesc:a7ae9fb15fa6e3f99173841ea910710c1 inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function constructs nodal subrange of B matrix for node couple a &amp; b. <br /></td></tr>
<tr class="separator:a7ae9fb15fa6e3f99173841ea910710c1 inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb02278c3894e00fdbc0cd2e379111ce inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb02278c3894e00fdbc0cd2e379111ce"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#abb02278c3894e00fdbc0cd2e379111ce">calculateElasticKIntegral1</a> (gsl_matrix *currElementalK, int pointNo)</td></tr>
<tr class="memdesc:abb02278c3894e00fdbc0cd2e379111ce inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calcultes the first part of the integral for the stiffness matirx, the elastic part of the system Jacobian. <br /></td></tr>
<tr class="separator:abb02278c3894e00fdbc0cd2e379111ce inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a5f7382e5d4038e4396d3f4a198105 inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74a5f7382e5d4038e4396d3f4a198105"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a74a5f7382e5d4038e4396d3f4a198105">calculateElasticKIntegral2</a> (gsl_matrix *currElementalK, int pointNo)</td></tr>
<tr class="memdesc:a74a5f7382e5d4038e4396d3f4a198105 inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calcultes the second part of the integral for the stiffness matirx, the elastic part of the system Jacobian. <br /></td></tr>
<tr class="separator:a74a5f7382e5d4038e4396d3f4a198105 inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cdcb5b445291f28d3ed3d83c582f534 inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5cdcb5b445291f28d3ed3d83c582f534"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a5cdcb5b445291f28d3ed3d83c582f534">calculateViscousKIntegral1</a> (gsl_matrix *currElementalK, gsl_matrix *paranthesisTermForKv1, int pointNo)</td></tr>
<tr class="memdesc:a5cdcb5b445291f28d3ed3d83c582f534 inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calcultes the first part of the integral for the internal viscous part of the system Jacobian. <br /></td></tr>
<tr class="separator:a5cdcb5b445291f28d3ed3d83c582f534 inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9795e5aad1361070df5ecdd735d9361b inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9795e5aad1361070df5ecdd735d9361b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a9795e5aad1361070df5ecdd735d9361b">calculateViscousKIntegral2</a> (gsl_matrix *currElementalK, int pointNo)</td></tr>
<tr class="memdesc:a9795e5aad1361070df5ecdd735d9361b inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calcultes the second part of the integral for the viscous part of the system Jacobian. <br /></td></tr>
<tr class="separator:a9795e5aad1361070df5ecdd735d9361b inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858ee3ff9bc490dc6584741f786c9478 inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a858ee3ff9bc490dc6584741f786c9478"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a858ee3ff9bc490dc6584741f786c9478">calculateVelocityGradient</a> (gsl_matrix *velocityGradient, gsl_matrix *displacementPerDt, int pointNo)</td></tr>
<tr class="memdesc:a858ee3ff9bc490dc6584741f786c9478 inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the velocity gradient. <br /></td></tr>
<tr class="separator:a858ee3ff9bc490dc6584741f786c9478 inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a71f51dacb8bdf18e1a9914e763016 inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4a71f51dacb8bdf18e1a9914e763016"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ac4a71f51dacb8bdf18e1a9914e763016">calculateOuterProduct</a> (gsl_matrix *a, gsl_matrix *b, gsl_matrix *outerProduct)</td></tr>
<tr class="memdesc:ac4a71f51dacb8bdf18e1a9914e763016 inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the outer product, maths helper function. <br /></td></tr>
<tr class="separator:ac4a71f51dacb8bdf18e1a9914e763016 inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5eefd4db5c7a4e8495a197f76446a8 inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e5eefd4db5c7a4e8495a197f76446a8"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a2e5eefd4db5c7a4e8495a197f76446a8">calculateSymmetricisedTensorProduct</a> (gsl_matrix *a, gsl_matrix *b)</td></tr>
<tr class="memdesc:a2e5eefd4db5c7a4e8495a197f76446a8 inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the symetricised tensor product, maths helper function. <br /></td></tr>
<tr class="separator:a2e5eefd4db5c7a4e8495a197f76446a8 inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a660608ede71c5bfdd1c4956843760 inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a91a660608ede71c5bfdd1c4956843760">disassembleRotationMatrixForZ</a> (gsl_matrix *rotMat)</td></tr>
<tr class="memdesc:a91a660608ede71c5bfdd1c4956843760 inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function extracts the z rotation from a rotation matrix.  <a href="#a91a660608ede71c5bfdd1c4956843760">More...</a><br /></td></tr>
<tr class="separator:a91a660608ede71c5bfdd1c4956843760 inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b249ac3da27e7eeb6e0604a76f15faf inherit pro_methods_classShapeBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a9b249ac3da27e7eeb6e0604a76f15faf">calculate3DRotMatFromF</a> (gsl_matrix *rotMat)</td></tr>
<tr class="memdesc:a9b249ac3da27e7eeb6e0604a76f15faf inherit pro_methods_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function dissects the deformation gradient of the element into the rigid body rotation and deformation.  <a href="#a9b249ac3da27e7eeb6e0604a76f15faf">More...</a><br /></td></tr>
<tr class="separator:a9b249ac3da27e7eeb6e0604a76f15faf inherit pro_methods_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a8852b1bc7b1b3c616c257170772c32cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8852b1bc7b1b3c616c257170772c32cb"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#a8852b1bc7b1b3c616c257170772c32cb">initialApilcalEdgeLengthsSq</a> [3]</td></tr>
<tr class="memdesc:a8852b1bc7b1b3c616c257170772c32cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array storing the squares of the apical edge lengths. <br /></td></tr>
<tr class="separator:a8852b1bc7b1b3c616c257170772c32cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1fc00413e365495117d6faaf3ec278"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f1fc00413e365495117d6faaf3ec278"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrism.html#a9f1fc00413e365495117d6faaf3ec278">initialBasalEdgeLengthsSq</a> [3]</td></tr>
<tr class="memdesc:a9f1fc00413e365495117d6faaf3ec278"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array storing the squares of the apical edge lengths. <br /></td></tr>
<tr class="separator:a9f1fc00413e365495117d6faaf3ec278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classShapeBase"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classShapeBase')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classShapeBase.html">ShapeBase</a></td></tr>
<tr class="memitem:a36aedd41e8465a186a0b0c454b5b76f3 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36aedd41e8465a186a0b0c454b5b76f3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a36aedd41e8465a186a0b0c454b5b76f3">ShapeType</a></td></tr>
<tr class="memdesc:a36aedd41e8465a186a0b0c454b5b76f3 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The integer defining the type of the shape, Prisms shape type = 1;. <br /></td></tr>
<tr class="separator:a36aedd41e8465a186a0b0c454b5b76f3 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0daa5629b1335ca3e1be089a006fe897 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0daa5629b1335ca3e1be089a006fe897"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a0daa5629b1335ca3e1be089a006fe897">nNodes</a></td></tr>
<tr class="memdesc:a0daa5629b1335ca3e1be089a006fe897 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of nodes of the element, it is based on <a class="el" href="classShapeBase.html#a36aedd41e8465a186a0b0c454b5b76f3" title="The integer defining the type of the shape, Prisms shape type = 1;. ">ShapeBase::ShapeType</a>. <br /></td></tr>
<tr class="separator:a0daa5629b1335ca3e1be089a006fe897 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae4246d158f4d66b5bd1644df40f150 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ae4246d158f4d66b5bd1644df40f150"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a0ae4246d158f4d66b5bd1644df40f150">nDim</a></td></tr>
<tr class="memdesc:a0ae4246d158f4d66b5bd1644df40f150 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of dimensions for the positions of each of the nodes of the element. <br /></td></tr>
<tr class="separator:a0ae4246d158f4d66b5bd1644df40f150 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6daae25e30af2e55599b7d1ecfbddb inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c6daae25e30af2e55599b7d1ecfbddb"></a>
std::array&lt; int, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a8c6daae25e30af2e55599b7d1ecfbddb">IdentifierColour</a></td></tr>
<tr class="memdesc:a8c6daae25e30af2e55599b7d1ecfbddb inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unique identifier colour of the element, this is used for "picking" in the visual interface. <br /></td></tr>
<tr class="separator:a8c6daae25e30af2e55599b7d1ecfbddb inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af537b85b81aa4f0812508e7a95b8b67a inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af537b85b81aa4f0812508e7a95b8b67a"></a>
std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#af537b85b81aa4f0812508e7a95b8b67a">GrowthRate</a></td></tr>
<tr class="memdesc:af537b85b81aa4f0812508e7a95b8b67a inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Growth rate recording for display purposes only. The recorded growth rate in x, y, and z coordinates, does not record shear deformation induced in growth. Recorded in exponential form through time step, converted to rate per hour for display within the visual interface. <br /></td></tr>
<tr class="separator:af537b85b81aa4f0812508e7a95b8b67a inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af553856335d7344ea67ab10f9cc3babf inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af553856335d7344ea67ab10f9cc3babf"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#af553856335d7344ea67ab10f9cc3babf">growthIncrement</a></td></tr>
<tr class="memdesc:af553856335d7344ea67ab10f9cc3babf inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matrix (3,3) representing the incremental growth in current time step. Reset to identity at the beginning of each time step, updated in growth functions, and utilised to update Fg. <br /></td></tr>
<tr class="separator:af553856335d7344ea67ab10f9cc3babf inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61c4a1f4132f54c362ea6296389abf6 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab61c4a1f4132f54c362ea6296389abf6"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ab61c4a1f4132f54c362ea6296389abf6">plasticDeformationIncrement</a></td></tr>
<tr class="memdesc:ab61c4a1f4132f54c362ea6296389abf6 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matrix (3,3) representing the incremental plastic deformation (treated as growth) in current time step. Set in plastic deformation calculation at each step, and utilised to update Fg. <br /></td></tr>
<tr class="separator:ab61c4a1f4132f54c362ea6296389abf6 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db4859942429aa4e3efc26a119a5aa3 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2db4859942429aa4e3efc26a119a5aa3"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a2db4859942429aa4e3efc26a119a5aa3">shapeChangeIncrement</a></td></tr>
<tr class="memdesc:a2db4859942429aa4e3efc26a119a5aa3 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matrix (3,3) representing the incremental shape change in current time step. Reset to identity at the beginning of each time step, updated in shape change functions, and utilised to update Fg. <br /></td></tr>
<tr class="separator:a2db4859942429aa4e3efc26a119a5aa3 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc566eb70e64da9fc3fa222b16999da inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0dc566eb70e64da9fc3fa222b16999da"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a0dc566eb70e64da9fc3fa222b16999da">zRemodellingSoFar</a></td></tr>
<tr class="memdesc:a0dc566eb70e64da9fc3fa222b16999da inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The z remodelling that have been applied to elemetn up to the current time step. This parameter is used to limit extreme thinning or elongation of elements. <br /></td></tr>
<tr class="separator:a0dc566eb70e64da9fc3fa222b16999da inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134d82ba500ef829b6aa3e3a83783c9a inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a134d82ba500ef829b6aa3e3a83783c9a"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a134d82ba500ef829b6aa3e3a83783c9a">columnarGrowthWeight</a></td></tr>
<tr class="memdesc:a134d82ba500ef829b6aa3e3a83783c9a inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fraction defining how close to the columnar layer the element is. 1.0 for columnar layer, 0.0 for peripodial membrane elements, and scaled according to position in the elements surrounding the lumen. <br /></td></tr>
<tr class="separator:a134d82ba500ef829b6aa3e3a83783c9a inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3663f3220016756b1bd5a92477325ec2 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3663f3220016756b1bd5a92477325ec2"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a3663f3220016756b1bd5a92477325ec2">peripodialGrowthWeight</a></td></tr>
<tr class="memdesc:a3663f3220016756b1bd5a92477325ec2 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fraction defining how close to the peripodial membrane the element is. 0.0 for columnar layer, 1.0 for peripodial membrane elements, and scaled according to position in the elements surrounding the lumen. <br /></td></tr>
<tr class="separator:a3663f3220016756b1bd5a92477325ec2 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3b7ef81761fc22f3bad866570f3d13 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb3b7ef81761fc22f3bad866570f3d13"></a>
std::array&lt; double, 6 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#acb3b7ef81761fc22f3bad866570f3d13">ShapeChangeRate</a></td></tr>
<tr class="memdesc:acb3b7ef81761fc22f3bad866570f3d13 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shape change rate of the elements, only orthagonal shape changes are allowed (x, y, z). Shape changes will be scaled to conserve volume, thus three values will not be independent. <br /></td></tr>
<tr class="separator:acb3b7ef81761fc22f3bad866570f3d13 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6a2cd267d49404f5442a48c867860f inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee6a2cd267d49404f5442a48c867860f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aee6a2cd267d49404f5442a48c867860f">rotatedGrowth</a></td></tr>
<tr class="memdesc:aee6a2cd267d49404f5442a48c867860f inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean stating if the element has rotated from the growth axis, hence the calculated growth requires further rotation to follow tissue axes. <br /></td></tr>
<tr class="separator:aee6a2cd267d49404f5442a48c867860f inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e2ed2804c9d949810f2b9288c1d6ba inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1e2ed2804c9d949810f2b9288c1d6ba"></a>
std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#af1e2ed2804c9d949810f2b9288c1d6ba">relativePosInBoundingBox</a></td></tr>
<tr class="memdesc:af1e2ed2804c9d949810f2b9288c1d6ba inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The relative position on x-y plane, within the bounding box of the tissue(x,y). <br /></td></tr>
<tr class="separator:af1e2ed2804c9d949810f2b9288c1d6ba inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37eecd113e033c1b5cd64c5a6fefedc1 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37eecd113e033c1b5cd64c5a6fefedc1"></a>
std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a37eecd113e033c1b5cd64c5a6fefedc1">initialRelativePosInBoundingBox</a></td></tr>
<tr class="memdesc:a37eecd113e033c1b5cd64c5a6fefedc1 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The relative position on x-y plane, within the bounding box of the tissue(x,y) at the beginning of simulation. This is used when growth rates are pinned to the initial structure of the tissue. <br /></td></tr>
<tr class="separator:a37eecd113e033c1b5cd64c5a6fefedc1 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6847e4087010221acd07ad298c5c0bd inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6847e4087010221acd07ad298c5c0bd"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ab6847e4087010221acd07ad298c5c0bd">initialRelativePositionInZ</a></td></tr>
<tr class="memdesc:ab6847e4087010221acd07ad298c5c0bd inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The relative position on z-height of tissue, taken not in z direction but in tissue layers, 0 being on the apical surface and 1 being on the basal surface. <br /></td></tr>
<tr class="separator:ab6847e4087010221acd07ad298c5c0bd inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c80fec4188317146cb31b74c36c7640 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c80fec4188317146cb31b74c36c7640"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a5c80fec4188317146cb31b74c36c7640">numberOfGaussPoints</a></td></tr>
<tr class="memdesc:a5c80fec4188317146cb31b74c36c7640 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of Gauss points used in numerical deforamtion calculation. <br /></td></tr>
<tr class="separator:a5c80fec4188317146cb31b74c36c7640 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f6b579cace44139825e3105c101431 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9f6b579cace44139825e3105c101431"></a>
std::array&lt; std::array&lt; double, 3 &gt;, 6 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ad9f6b579cace44139825e3105c101431">gaussPoints</a></td></tr>
<tr class="memdesc:ad9f6b579cace44139825e3105c101431 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array contianing all the Gauss points for element. Set up is for 6, can work for any number as loops are kept indexed up to numberOfGaussPoints. <br /></td></tr>
<tr class="separator:ad9f6b579cace44139825e3105c101431 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ec0d74748313a30a280258bd1e1827 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50ec0d74748313a30a280258bd1e1827"></a>
std::array&lt; double, 6 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a50ec0d74748313a30a280258bd1e1827">gaussWeights</a></td></tr>
<tr class="memdesc:a50ec0d74748313a30a280258bd1e1827 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array for storing the weights of each Gauss point for element. <br /></td></tr>
<tr class="separator:a50ec0d74748313a30a280258bd1e1827 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9451400710c0458e286c9183b8014a71 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9451400710c0458e286c9183b8014a71"></a>
std::vector&lt; gsl_matrix * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a9451400710c0458e286c9183b8014a71">ShapeFuncDerivatives</a></td></tr>
<tr class="memdesc:a9451400710c0458e286c9183b8014a71 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array of matrices for shape function derivatives. The array stores a <a class="el" href="classShapeBase.html#a0ae4246d158f4d66b5bd1644df40f150" title="The number of dimensions for the positions of each of the nodes of the element. ">ShapeBase::nDim</a> by <a class="el" href="classShapeBase.html#a0daa5629b1335ca3e1be089a006fe897" title="The number of nodes of the element, it is based on ShapeBase::ShapeType. ">ShapeBase::nNodes</a> matrix for each gauss point (there are 3 Gauss points for prisms). <br /></td></tr>
<tr class="separator:a9451400710c0458e286c9183b8014a71 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21657fc100e70eaec475616adf308f81 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21657fc100e70eaec475616adf308f81"></a>
std::vector&lt; gsl_matrix * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a21657fc100e70eaec475616adf308f81">ShapeFuncDerStacks</a></td></tr>
<tr class="memdesc:a21657fc100e70eaec475616adf308f81 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array of matrices of shape function derivatives in stacked format for ease of matrix operations. The array stores a (<a class="el" href="classShapeBase.html#a0ae4246d158f4d66b5bd1644df40f150" title="The number of dimensions for the positions of each of the nodes of the element. ">ShapeBase::nDim</a> * <a class="el" href="classShapeBase.html#a0ae4246d158f4d66b5bd1644df40f150" title="The number of dimensions for the positions of each of the nodes of the element. ">ShapeBase::nDim</a>) by (<a class="el" href="classShapeBase.html#a0ae4246d158f4d66b5bd1644df40f150" title="The number of dimensions for the positions of each of the nodes of the element. ">ShapeBase::nDim</a> * <a class="el" href="classShapeBase.html#a0daa5629b1335ca3e1be089a006fe897" title="The number of nodes of the element, it is based on ShapeBase::ShapeType. ">ShapeBase::nNodes</a>) matrix for each gauss point (there are 3 Gauss points for prisms). <br /></td></tr>
<tr class="separator:a21657fc100e70eaec475616adf308f81 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad96a4f7ac584f37627a341f1c6a6156 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad96a4f7ac584f37627a341f1c6a6156"></a>
std::vector&lt; gsl_matrix * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aad96a4f7ac584f37627a341f1c6a6156">InvdXdes</a></td></tr>
<tr class="memdesc:aad96a4f7ac584f37627a341f1c6a6156 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array stores inverse of the matrix for derivatives of world coordinates with respect to barycentric coordinates (dX / de). The array stores an <a class="el" href="classShapeBase.html#a0ae4246d158f4d66b5bd1644df40f150" title="The number of dimensions for the positions of each of the nodes of the element. ">ShapeBase::nDim</a> by <a class="el" href="classShapeBase.html#a0ae4246d158f4d66b5bd1644df40f150" title="The number of dimensions for the positions of each of the nodes of the element. ">ShapeBase::nDim</a> matrix for each gauss point (there are 3 Gauss points for prisms). <br /></td></tr>
<tr class="separator:aad96a4f7ac584f37627a341f1c6a6156 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f25110de54965266cb29b66eaf5b81 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37f25110de54965266cb29b66eaf5b81"></a>
std::array&lt; double, 6 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a37f25110de54965266cb29b66eaf5b81">detdXdes</a></td></tr>
<tr class="memdesc:a37f25110de54965266cb29b66eaf5b81 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array stores the determinants of the matrices for derivatives of world coordinates with respect to barycentric coordinates (dX / de). The array stores a double value for each gauss point (there are 3 Gauss points for prisms). <br /></td></tr>
<tr class="separator:a37f25110de54965266cb29b66eaf5b81 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04079b2f81481d44a9b3efb8916c8423 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04079b2f81481d44a9b3efb8916c8423"></a>
std::vector&lt; gsl_matrix * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a04079b2f81481d44a9b3efb8916c8423">Bmatrices</a></td></tr>
<tr class="memdesc:a04079b2f81481d44a9b3efb8916c8423 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array stores the B matrix for the calculation of stiffness matrix, see for <a class="el" href="classShapeBase.html#ad67919694a1d780e31f6d539781377be" title="This function calculates the B matrix, to calculate the nodal force. ">ShapeBase::calculateBTforNodalForces</a> calculation. The array stores an <a class="el" href="classShapeBase.html#a0daa5629b1335ca3e1be089a006fe897" title="The number of nodes of the element, it is based on ShapeBase::ShapeType. ">ShapeBase::nNodes</a> by (<a class="el" href="classShapeBase.html#a0ae4246d158f4d66b5bd1644df40f150" title="The number of dimensions for the positions of each of the nodes of the element. ">ShapeBase::nDim</a>*ShapeBase<a class="el" href="classShapeBase.html#a0daa5629b1335ca3e1be089a006fe897" title="The number of nodes of the element, it is based on ShapeBase::ShapeType. ">nNodes</a>) matrix for each Gauss point (there are 3 Gauss points for prisms). <br /></td></tr>
<tr class="separator:a04079b2f81481d44a9b3efb8916c8423 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6b0d0bc99f2c07986522fd866312ea inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae6b0d0bc99f2c07986522fd866312ea"></a>
std::vector&lt; gsl_matrix * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aae6b0d0bc99f2c07986522fd866312ea">FeMatrices</a></td></tr>
<tr class="memdesc:aae6b0d0bc99f2c07986522fd866312ea inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array stores the elastic part of the deformation matrix. The array stores an <a class="el" href="classShapeBase.html#a0ae4246d158f4d66b5bd1644df40f150" title="The number of dimensions for the positions of each of the nodes of the element. ">ShapeBase::nDim</a> by <a class="el" href="classShapeBase.html#a0ae4246d158f4d66b5bd1644df40f150" title="The number of dimensions for the positions of each of the nodes of the element. ">ShapeBase::nDim</a> matrix for each Gauss point (there are 6 Gauss points for prisms). <br /></td></tr>
<tr class="separator:aae6b0d0bc99f2c07986522fd866312ea inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ef46748c8632768c6be10987f1c0e3 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18ef46748c8632768c6be10987f1c0e3"></a>
std::vector&lt; gsl_matrix * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a18ef46748c8632768c6be10987f1c0e3">invJShapeFuncDerStack</a></td></tr>
<tr class="memdesc:a18ef46748c8632768c6be10987f1c0e3 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array stores the shape function derivatives multiplied by the inverse Jacobian stack, for each Gauss point. See <a class="el" href="classShapeBase.html#ad67919694a1d780e31f6d539781377be" title="This function calculates the B matrix, to calculate the nodal force. ">ShapeBase::calculateBTforNodalForces</a> for calculation. <br /></td></tr>
<tr class="separator:a18ef46748c8632768c6be10987f1c0e3 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90987ba8732360351b3994e6566c6093 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90987ba8732360351b3994e6566c6093"></a>
std::vector&lt; gsl_matrix * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a90987ba8732360351b3994e6566c6093">invJShapeFuncDerStackwithFe</a></td></tr>
<tr class="memdesc:a90987ba8732360351b3994e6566c6093 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="classShapeBase.html#a8d984ddba5bbeae91cb3180897a5a3e7" title="This function calculates the collated matrix from inverse jaconians and shape function derivatives...">ShapeBase::calculateInvJShFuncDerSWithFe</a> for calculation. <br /></td></tr>
<tr class="separator:a90987ba8732360351b3994e6566c6093 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec28da3cbed6bf4aad8370bd5cdad81 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adec28da3cbed6bf4aad8370bd5cdad81"></a>
std::vector&lt; gsl_matrix * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#adec28da3cbed6bf4aad8370bd5cdad81">elasticStress</a></td></tr>
<tr class="memdesc:adec28da3cbed6bf4aad8370bd5cdad81 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array of matrices for elastic stress of the element. The array stores a 6 by 6 matrix for each Gauss point (there are 6 Gauss points for prisms). <br /></td></tr>
<tr class="separator:adec28da3cbed6bf4aad8370bd5cdad81 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f180dc41c5b6e12b9468dd557bb524 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29f180dc41c5b6e12b9468dd557bb524"></a>
std::vector&lt; gsl_matrix * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a29f180dc41c5b6e12b9468dd557bb524">viscousStress</a></td></tr>
<tr class="memdesc:a29f180dc41c5b6e12b9468dd557bb524 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array of matrices for internal viscous stress of the element. The array stores a 6 by 6 matrix for each Gauss point (there are 6 Gauss points for prisms). <br /></td></tr>
<tr class="separator:a29f180dc41c5b6e12b9468dd557bb524 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ac8f14929ab37e8eae5fcaf93b18a8 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7ac8f14929ab37e8eae5fcaf93b18a8"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ab7ac8f14929ab37e8eae5fcaf93b18a8">TriPointF</a></td></tr>
<tr class="memdesc:ab7ac8f14929ab37e8eae5fcaf93b18a8 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The deformation matrix of the element resulting from iteration over all Gauss points. The dimensions of the matrix is <a class="el" href="classShapeBase.html#a0ae4246d158f4d66b5bd1644df40f150" title="The number of dimensions for the positions of each of the nodes of the element. ">ShapeBase::nDim</a> by <a class="el" href="classShapeBase.html#a0ae4246d158f4d66b5bd1644df40f150" title="The number of dimensions for the positions of each of the nodes of the element. ">ShapeBase::nDim</a>. <br /></td></tr>
<tr class="separator:ab7ac8f14929ab37e8eae5fcaf93b18a8 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d201c88c73283f2e9711d1cc038e02 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94d201c88c73283f2e9711d1cc038e02"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a94d201c88c73283f2e9711d1cc038e02">ElementalElasticSystemForces</a></td></tr>
<tr class="memdesc:a94d201c88c73283f2e9711d1cc038e02 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matrix stores the elemental elastic forces. The dimensions of the matrix is <a class="el" href="classShapeBase.html#a0daa5629b1335ca3e1be089a006fe897" title="The number of nodes of the element, it is based on ShapeBase::ShapeType. ">ShapeBase::nNodes</a> by <a class="el" href="classShapeBase.html#a0ae4246d158f4d66b5bd1644df40f150" title="The number of dimensions for the positions of each of the nodes of the element. ">ShapeBase::nDim</a>. <br /></td></tr>
<tr class="separator:a94d201c88c73283f2e9711d1cc038e02 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b5ebd33ad4ed5739c0431bf0d4346d inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54b5ebd33ad4ed5739c0431bf0d4346d"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a54b5ebd33ad4ed5739c0431bf0d4346d">ElementalInternalViscousSystemForces</a></td></tr>
<tr class="memdesc:a54b5ebd33ad4ed5739c0431bf0d4346d inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matrix stores the elemental internal viscous forces. The dimensions of the matrix is <a class="el" href="classShapeBase.html#a0daa5629b1335ca3e1be089a006fe897" title="The number of nodes of the element, it is based on ShapeBase::ShapeType. ">ShapeBase::nNodes</a> by <a class="el" href="classShapeBase.html#a0ae4246d158f4d66b5bd1644df40f150" title="The number of dimensions for the positions of each of the nodes of the element. ">ShapeBase::nDim</a>. <br /></td></tr>
<tr class="separator:a54b5ebd33ad4ed5739c0431bf0d4346d inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d3d2738b44a003e08a6a6b96c0b91e inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01d3d2738b44a003e08a6a6b96c0b91e"></a>
std::array&lt; double, 6 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a01d3d2738b44a003e08a6a6b96c0b91e">detFs</a></td></tr>
<tr class="memdesc:a01d3d2738b44a003e08a6a6b96c0b91e inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array stores the determinant of the deformation matrix for each Gauss point. <br /></td></tr>
<tr class="separator:a01d3d2738b44a003e08a6a6b96c0b91e inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a8101057e2771172a4716c128705d7 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51a8101057e2771172a4716c128705d7"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a51a8101057e2771172a4716c128705d7">ZProjectedBasalArea</a></td></tr>
<tr class="memdesc:a51a8101057e2771172a4716c128705d7 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The z-projected area of the basal surface of the element. <br /></td></tr>
<tr class="separator:a51a8101057e2771172a4716c128705d7 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7043ddacbcd92480cb54467a2777627 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7043ddacbcd92480cb54467a2777627"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aa7043ddacbcd92480cb54467a2777627">ZProjectedApicalArea</a></td></tr>
<tr class="memdesc:aa7043ddacbcd92480cb54467a2777627 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The z-projected area of the apical surface of the element. <br /></td></tr>
<tr class="separator:aa7043ddacbcd92480cb54467a2777627 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae2b0b1dfd0672a39897e780d861254 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ae2b0b1dfd0672a39897e780d861254"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a2ae2b0b1dfd0672a39897e780d861254">BasalArea</a></td></tr>
<tr class="memdesc:a2ae2b0b1dfd0672a39897e780d861254 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The area of the basal surface of the element. <br /></td></tr>
<tr class="separator:a2ae2b0b1dfd0672a39897e780d861254 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4227c13db7e34dd1af182d143af47b inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb4227c13db7e34dd1af182d143af47b"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#adb4227c13db7e34dd1af182d143af47b">ApicalArea</a></td></tr>
<tr class="memdesc:adb4227c13db7e34dd1af182d143af47b inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The area of the apical surface of the element. <br /></td></tr>
<tr class="separator:adb4227c13db7e34dd1af182d143af47b inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29dcfc319798bd21b3bc2b50ac401c8 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac29dcfc319798bd21b3bc2b50ac401c8"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ac29dcfc319798bd21b3bc2b50ac401c8">exposedLateralAreaApicalSide</a></td></tr>
<tr class="memdesc:ac29dcfc319798bd21b3bc2b50ac401c8 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The area of the element on a linker position, and has lateral sides exposed to outside of the tissue, on the apical side, therefore should feel external viscosity. <br /></td></tr>
<tr class="separator:ac29dcfc319798bd21b3bc2b50ac401c8 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba637ddf764ae673d616f7318270866 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ba637ddf764ae673d616f7318270866"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a3ba637ddf764ae673d616f7318270866">exposedLateralAreaBasalSide</a></td></tr>
<tr class="memdesc:a3ba637ddf764ae673d616f7318270866 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The area of the element on a linker position, and has lateral sides exposed to outside of the tissue, on the basal side, therefore should feel external viscosity. <br /></td></tr>
<tr class="separator:a3ba637ddf764ae673d616f7318270866 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5dfa04e7a8c7f2c33bea431ca441674 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5dfa04e7a8c7f2c33bea431ca441674"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ab5dfa04e7a8c7f2c33bea431ca441674">elementHasExposedApicalSurface</a></td></tr>
<tr class="memdesc:ab5dfa04e7a8c7f2c33bea431ca441674 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean stating if the element has any apical surface exposed to the environment. <br /></td></tr>
<tr class="separator:ab5dfa04e7a8c7f2c33bea431ca441674 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194437fa296d9e12e58cc14fa8d66931 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a194437fa296d9e12e58cc14fa8d66931"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a194437fa296d9e12e58cc14fa8d66931">elementHasExposedBasalSurface</a></td></tr>
<tr class="memdesc:a194437fa296d9e12e58cc14fa8d66931 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean stating if the element has any basal surface exposed to the environment. <br /></td></tr>
<tr class="separator:a194437fa296d9e12e58cc14fa8d66931 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7987e6fc21a5035fc04558f1b366406a inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7987e6fc21a5035fc04558f1b366406a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a7987e6fc21a5035fc04558f1b366406a">exposedApicalSurfaceNodeIds</a> [3]</td></tr>
<tr class="memdesc:a7987e6fc21a5035fc04558f1b366406a inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The int array of size 3, listing the node IDs of element that form the exposed apical surface. The IDs are the node IDs on the element (0-5 for prism), not the actual <a class="el" href="classNode.html#a1bd379569cc1a8b96432e61971aed4d9" title="The unique identification number of the node. ">Node::Id</a>. <br /></td></tr>
<tr class="separator:a7987e6fc21a5035fc04558f1b366406a inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc7714f5622b21ec7fba51e1136803f inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7bc7714f5622b21ec7fba51e1136803f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a7bc7714f5622b21ec7fba51e1136803f">exposedBasalSurfaceNodeIds</a> [3]</td></tr>
<tr class="memdesc:a7bc7714f5622b21ec7fba51e1136803f inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The int array of size 3, listing the node IDs of element that form the exposed basal surface. The IDs are the node IDs on the element (0-5 for prism), not the actual <a class="el" href="classNode.html#a1bd379569cc1a8b96432e61971aed4d9" title="The unique identification number of the node. ">Node::Id</a>. <br /></td></tr>
<tr class="separator:a7bc7714f5622b21ec7fba51e1136803f inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2724f82bbf8c657c075826f953f0b7f2 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2724f82bbf8c657c075826f953f0b7f2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a2724f82bbf8c657c075826f953f0b7f2">exposedLateralAreaApicalSideNodeIds</a> [4]</td></tr>
<tr class="memdesc:a2724f82bbf8c657c075826f953f0b7f2 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The int array of size 4, listing the node IDs of element that form the lateral surface exposed apically. The IDs are the node IDs on the element (0-5 for prism), not the actual <a class="el" href="classNode.html#a1bd379569cc1a8b96432e61971aed4d9" title="The unique identification number of the node. ">Node::Id</a>. <br /></td></tr>
<tr class="separator:a2724f82bbf8c657c075826f953f0b7f2 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b58f2840dd8ffd571c647534ad9f0b inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28b58f2840dd8ffd571c647534ad9f0b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a28b58f2840dd8ffd571c647534ad9f0b">exposedLateralAreaBasalSideNodeIds</a> [4]</td></tr>
<tr class="memdesc:a28b58f2840dd8ffd571c647534ad9f0b inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The int array of size 4, listing the node IDs of element that form the lateral surface exposed basally. The IDs are the node IDs on the element (0-5 for prism), not the actual <a class="el" href="classNode.html#a1bd379569cc1a8b96432e61971aed4d9" title="The unique identification number of the node. ">Node::Id</a>. <br /></td></tr>
<tr class="separator:a28b58f2840dd8ffd571c647534ad9f0b inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433035a8df676eec3fbac2e510d483b4 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a433035a8df676eec3fbac2e510d483b4"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a433035a8df676eec3fbac2e510d483b4">nLateralSurfaceAreaNodeNumber</a></td></tr>
<tr class="memdesc:a433035a8df676eec3fbac2e510d483b4 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nodes that form the lateral surfaces for the element. <br /></td></tr>
<tr class="separator:a433035a8df676eec3fbac2e510d483b4 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3795d719f61808a05327aa4e3cf0355 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3795d719f61808a05327aa4e3cf0355"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ad3795d719f61808a05327aa4e3cf0355">nSurfaceAreaNodeNumber</a></td></tr>
<tr class="memdesc:ad3795d719f61808a05327aa4e3cf0355 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nodes that form the apical/basal surfaces for the element. <br /></td></tr>
<tr class="separator:ad3795d719f61808a05327aa4e3cf0355 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525290b7f6921e964666d946b5d6774d inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a525290b7f6921e964666d946b5d6774d"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a525290b7f6921e964666d946b5d6774d">stiffnessPerturbationRateInSec</a></td></tr>
<tr class="memdesc:a525290b7f6921e964666d946b5d6774d inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The rate at which the stiffness of the element will be perturbed, used with the model inputs from "Stiffness_Perturbation:" header in model input file. <br /></td></tr>
<tr class="separator:a525290b7f6921e964666d946b5d6774d inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9988f025f39118d8d29696709e6660d6 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9988f025f39118d8d29696709e6660d6"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a9988f025f39118d8d29696709e6660d6">minimumValueOfStiffnessMultiplier</a></td></tr>
<tr class="memdesc:a9988f025f39118d8d29696709e6660d6 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lower bound of stiffness modification multiplier, exists to prevent elements reaching unintended zero or negative stiffness values. <br /></td></tr>
<tr class="separator:a9988f025f39118d8d29696709e6660d6 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915634dcedd74abf27fd746758bfe935 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a915634dcedd74abf27fd746758bfe935"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a915634dcedd74abf27fd746758bfe935">maximumValueOfStiffnessMultiplier</a></td></tr>
<tr class="memdesc:a915634dcedd74abf27fd746758bfe935 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The upper bound of stiffness modification multiplier, exists to prevent elements reaching unrealistic hard stiffness values. <br /></td></tr>
<tr class="separator:a915634dcedd74abf27fd746758bfe935 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ee77fed372f7702889bebb67875136 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35ee77fed372f7702889bebb67875136"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a35ee77fed372f7702889bebb67875136">mutationGrowthRatePerSec</a></td></tr>
<tr class="memdesc:a35ee77fed372f7702889bebb67875136 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The growth rate set by a mutant clone covering this element. <br /></td></tr>
<tr class="separator:a35ee77fed372f7702889bebb67875136 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b83cb76a8f4ec11a4a6292c2899ba2 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7b83cb76a8f4ec11a4a6292c2899ba2"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ac7b83cb76a8f4ec11a4a6292c2899ba2">mutationGrowthFold</a></td></tr>
<tr class="memdesc:ac7b83cb76a8f4ec11a4a6292c2899ba2 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The rate of fold change in growth rate set by a mutant clone covering this element. <br /></td></tr>
<tr class="separator:ac7b83cb76a8f4ec11a4a6292c2899ba2 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1878efccfc629e53748e8907386825b0 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1878efccfc629e53748e8907386825b0"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a1878efccfc629e53748e8907386825b0">D</a></td></tr>
<tr class="memdesc:a1878efccfc629e53748e8907386825b0 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">elasticity tensor for Kirshoff material <br /></td></tr>
<tr class="separator:a1878efccfc629e53748e8907386825b0 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7266beef6c849298c3786a53259bd467 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7266beef6c849298c3786a53259bd467"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a7266beef6c849298c3786a53259bd467">CoeffMat</a></td></tr>
<tr class="memdesc:a7266beef6c849298c3786a53259bd467 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The coefficient matrix relating the shape function derivative stack to the Voigt notation of elemental stress nad strain. <br /></td></tr>
<tr class="separator:a7266beef6c849298c3786a53259bd467 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90cb382c78aa293d53bb027f84fe04b inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad90cb382c78aa293d53bb027f84fe04b"></a>
std::vector&lt; std::array&lt; std::array&lt; std::array&lt; std::array&lt; double, 3 &gt;, 3 &gt;, 3 &gt;, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ad90cb382c78aa293d53bb027f84fe04b">D81</a></td></tr>
<tr class="memdesc:ad90cb382c78aa293d53bb027f84fe04b inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lagrangian elasticity tensor, vector for the number of Gauss points in simulaiton. <br /></td></tr>
<tr class="separator:ad90cb382c78aa293d53bb027f84fe04b inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1a3a0173841d6072a5268978463ff2 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c1a3a0173841d6072a5268978463ff2"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a6c1a3a0173841d6072a5268978463ff2">E</a></td></tr>
<tr class="memdesc:a6c1a3a0173841d6072a5268978463ff2 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Young's modulus of the element. <br /></td></tr>
<tr class="separator:a6c1a3a0173841d6072a5268978463ff2 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4c2d3bfbc6c9785c5181a56f929151 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b4c2d3bfbc6c9785c5181a56f929151"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a8b4c2d3bfbc6c9785c5181a56f929151">v</a></td></tr>
<tr class="memdesc:a8b4c2d3bfbc6c9785c5181a56f929151 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poisson's ratio of the element. <br /></td></tr>
<tr class="separator:a8b4c2d3bfbc6c9785c5181a56f929151 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd0830ee5d4e64bb68e58aa77736757 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fd0830ee5d4e64bb68e58aa77736757"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a7fd0830ee5d4e64bb68e58aa77736757">internalViscosity</a></td></tr>
<tr class="memdesc:a7fd0830ee5d4e64bb68e58aa77736757 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current internal viscosity of the element. <br /></td></tr>
<tr class="separator:a7fd0830ee5d4e64bb68e58aa77736757 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5abc42a65cd840e1c65a1a026aa3bb65 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5abc42a65cd840e1c65a1a026aa3bb65"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a5abc42a65cd840e1c65a1a026aa3bb65">originalInternalViscosity</a></td></tr>
<tr class="memdesc:a5abc42a65cd840e1c65a1a026aa3bb65 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal viscosity of the element at the beginning of the simulation, prior to physical property perturbations. <br /></td></tr>
<tr class="separator:a5abc42a65cd840e1c65a1a026aa3bb65 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16b41d5791fc15531cbee067c502a5d inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa16b41d5791fc15531cbee067c502a5d"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aa16b41d5791fc15531cbee067c502a5d">lambda</a></td></tr>
<tr class="memdesc:aa16b41d5791fc15531cbee067c502a5d inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lame's second parameter, driven from Young's modulus and Poisson's ratio of the element. <br /></td></tr>
<tr class="separator:aa16b41d5791fc15531cbee067c502a5d inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5819d0d117e5510611259177c477af8 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5819d0d117e5510611259177c477af8"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ac5819d0d117e5510611259177c477af8">mu</a></td></tr>
<tr class="memdesc:ac5819d0d117e5510611259177c477af8 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sheer modulus of the element. <br /></td></tr>
<tr class="separator:ac5819d0d117e5510611259177c477af8 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7cb600a9316597a16512ab7b6fcd6f inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe7cb600a9316597a16512ab7b6fcd6f"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#afe7cb600a9316597a16512ab7b6fcd6f">InvFg</a></td></tr>
<tr class="memdesc:afe7cb600a9316597a16512ab7b6fcd6f inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse of growth matrix. <br /></td></tr>
<tr class="separator:afe7cb600a9316597a16512ab7b6fcd6f inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d7f6e8f098a7b5985c615842062014 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08d7f6e8f098a7b5985c615842062014"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a08d7f6e8f098a7b5985c615842062014">Fsc</a></td></tr>
<tr class="memdesc:a08d7f6e8f098a7b5985c615842062014 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shape change matrix. <br /></td></tr>
<tr class="separator:a08d7f6e8f098a7b5985c615842062014 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72828aab0668c993f57727123aa96be inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad72828aab0668c993f57727123aa96be"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ad72828aab0668c993f57727123aa96be">InvFsc</a></td></tr>
<tr class="memdesc:ad72828aab0668c993f57727123aa96be inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse of shape change matrix. <br /></td></tr>
<tr class="separator:ad72828aab0668c993f57727123aa96be inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace20710f27099833509c474b221c25df inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace20710f27099833509c474b221c25df"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ace20710f27099833509c474b221c25df">TriPointKe</a></td></tr>
<tr class="memdesc:ace20710f27099833509c474b221c25df inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current elastic part of the Jacobian (stiffness matrix) of the system, averaged over all Gauss Points. <br /></td></tr>
<tr class="separator:ace20710f27099833509c474b221c25df inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa5b1338e405a2c75c8d010f4153b05 inherit pro_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fa5b1338e405a2c75c8d010f4153b05"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a7fa5b1338e405a2c75c8d010f4153b05">TriPointKv</a></td></tr>
<tr class="memdesc:a7fa5b1338e405a2c75c8d010f4153b05 inherit pro_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current viscous part of the Jacobian of the system, averaged over all Gauss Points. <br /></td></tr>
<tr class="separator:a7fa5b1338e405a2c75c8d010f4153b05 inherit pro_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_attribs_classShapeBase"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classShapeBase')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classShapeBase.html">ShapeBase</a></td></tr>
<tr class="memitem:a9cff4a8549b3399fec12309d18b6db70 inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9cff4a8549b3399fec12309d18b6db70"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a9cff4a8549b3399fec12309d18b6db70">stiffnessMultiplier</a></td></tr>
<tr class="memdesc:a9cff4a8549b3399fec12309d18b6db70 inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current stiffness multiplier of the element, initially 1.0, modulated by stiffness perturbations ///&lt; The double for the multiplier that will define Young's modulus stress stiffening. <br /></td></tr>
<tr class="separator:a9cff4a8549b3399fec12309d18b6db70 inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8b443e4b55479a9d2a7a7eacd62b69 inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e8b443e4b55479a9d2a7a7eacd62b69"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a0e8b443e4b55479a9d2a7a7eacd62b69">remodellingPlaneRotationMatrix</a></td></tr>
<tr class="memdesc:a0e8b443e4b55479a9d2a7a7eacd62b69 inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The rotation matrix converting the xyz coordinate system to the plane of remodelling for the lateral elements. <br /></td></tr>
<tr class="separator:a0e8b443e4b55479a9d2a7a7eacd62b69 inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4156d7c7f91f0b528214b74277279df0 inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4156d7c7f91f0b528214b74277279df0"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a4156d7c7f91f0b528214b74277279df0">Fg</a></td></tr>
<tr class="memdesc:a4156d7c7f91f0b528214b74277279df0 inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Growth deformation gradient. <br /></td></tr>
<tr class="separator:a4156d7c7f91f0b528214b74277279df0 inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae097764dd4d607b54710d7ca0f7e12f8 inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae097764dd4d607b54710d7ca0f7e12f8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#ae097764dd4d607b54710d7ca0f7e12f8">Id</a></td></tr>
<tr class="memdesc:ae097764dd4d607b54710d7ca0f7e12f8 inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unique ID of the element, without remodelling, equal to its indes on the <a class="el" href="classSimulation.html#a96e0aaea7b40dbb5bc11329fc7d34559" title="The vector storing the unique pointers ot the elements of the simulation. ">Simulation::Elements</a> vector. <br /></td></tr>
<tr class="separator:ae097764dd4d607b54710d7ca0f7e12f8 inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d740b60433d7a9104c2d09b0d52703d inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d740b60433d7a9104c2d09b0d52703d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a4d740b60433d7a9104c2d09b0d52703d">ShapeDim</a></td></tr>
<tr class="memdesc:a4d740b60433d7a9104c2d09b0d52703d inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dimension of the shape in workd coordiantes (2D vs 3D). <br /></td></tr>
<tr class="separator:a4d740b60433d7a9104c2d09b0d52703d inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96e17fa9a23289fb743ff0722a7dc64 inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af96e17fa9a23289fb743ff0722a7dc64"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#af96e17fa9a23289fb743ff0722a7dc64">NodeIds</a></td></tr>
<tr class="memdesc:af96e17fa9a23289fb743ff0722a7dc64 inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector storing the unique IDs (<a class="el" href="classNode.html#a1bd379569cc1a8b96432e61971aed4d9" title="The unique identification number of the node. ">Node::Id</a>) of nodes constructing this element. Their order is consistent for a given shape type. <br /></td></tr>
<tr class="separator:af96e17fa9a23289fb743ff0722a7dc64 inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6bd8c65e2a0bfea3a956604bc05cb9 inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a6bd8c65e2a0bfea3a956604bc05cb9"></a>
std::vector&lt; std::array&lt; double, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a6a6bd8c65e2a0bfea3a956604bc05cb9">Positions</a></td></tr>
<tr class="memdesc:a6a6bd8c65e2a0bfea3a956604bc05cb9 inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector storing the positions of the nodes constructing the element. <br /></td></tr>
<tr class="separator:a6a6bd8c65e2a0bfea3a956604bc05cb9 inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93270dee7f71d075c73d1720c8279a44 inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93270dee7f71d075c73d1720c8279a44"></a>
std::unique_ptr&lt; <a class="el" href="classReferenceShapeBase.html">ReferenceShapeBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a93270dee7f71d075c73d1720c8279a44">ReferenceShape</a></td></tr>
<tr class="memdesc:a93270dee7f71d075c73d1720c8279a44 inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pointer to the reference shape object that defines th reference shape of this element. <br /></td></tr>
<tr class="separator:a93270dee7f71d075c73d1720c8279a44 inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bda00f80968d836c647afe5f6d1fb36 inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bda00f80968d836c647afe5f6d1fb36"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a4bda00f80968d836c647afe5f6d1fb36">Strain</a></td></tr>
<tr class="memdesc:a4bda00f80968d836c647afe5f6d1fb36 inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The gsl_matrix pointer, storing the address of the current strains on the element. <br /></td></tr>
<tr class="separator:a4bda00f80968d836c647afe5f6d1fb36 inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da6d64116b5d73e2bb27d378035df41 inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3da6d64116b5d73e2bb27d378035df41"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a3da6d64116b5d73e2bb27d378035df41">isFlipped</a></td></tr>
<tr class="memdesc:a3da6d64116b5d73e2bb27d378035df41 inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if the element is flipped. The simulation will be stopped if there are flipped elements. <br /></td></tr>
<tr class="separator:a3da6d64116b5d73e2bb27d378035df41 inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994acea5e6f2cf92c94f485e7ba5afc9 inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a994acea5e6f2cf92c94f485e7ba5afc9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsChangingShape</b></td></tr>
<tr class="separator:a994acea5e6f2cf92c94f485e7ba5afc9 inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff63b1fcb823bbfdb5b19fe78dea59b8 inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff63b1fcb823bbfdb5b19fe78dea59b8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aff63b1fcb823bbfdb5b19fe78dea59b8">tissuePlacement</a></td></tr>
<tr class="memdesc:aff63b1fcb823bbfdb5b19fe78dea59b8 inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 -&gt; apical, 0 -&gt; basal, 2-&gt;middle, 3 -&gt; lateral <br /></td></tr>
<tr class="separator:aff63b1fcb823bbfdb5b19fe78dea59b8 inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d56f7eb3fed744adc268bc4da7a790f inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d56f7eb3fed744adc268bc4da7a790f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a1d56f7eb3fed744adc268bc4da7a790f">tissueType</a></td></tr>
<tr class="memdesc:a1d56f7eb3fed744adc268bc4da7a790f inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The tissue type is 000 for columnar layer, 1 for peripodial membrane, and 2 for linker zone. <br /></td></tr>
<tr class="separator:a1d56f7eb3fed744adc268bc4da7a790f inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adafe85bbee6173d2a321408cd8b63db3 inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adafe85bbee6173d2a321408cd8b63db3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#adafe85bbee6173d2a321408cd8b63db3">spansWholeTissue</a></td></tr>
<tr class="memdesc:adafe85bbee6173d2a321408cd8b63db3 inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean staing is the element spans the whole tissue. This is used to identify mid-layer tagged tissues (tissuePlacement = 2), that should still have apical abd basal responses. <br /></td></tr>
<tr class="separator:adafe85bbee6173d2a321408cd8b63db3 inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47bfa280bf33fc0557e8d804aab3936c inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47bfa280bf33fc0557e8d804aab3936c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a47bfa280bf33fc0557e8d804aab3936c">compartmentType</a></td></tr>
<tr class="memdesc:a47bfa280bf33fc0557e8d804aab3936c inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">integer identifying the compartment of the tissue in DV axis, 0 pouch, 1 hinge, 2 notum <br /></td></tr>
<tr class="separator:a47bfa280bf33fc0557e8d804aab3936c inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada8d021521dbe6815a887bc0cb28cc8 inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aada8d021521dbe6815a887bc0cb28cc8"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aada8d021521dbe6815a887bc0cb28cc8">compartmentIdentityFraction</a></td></tr>
<tr class="memdesc:aada8d021521dbe6815a887bc0cb28cc8 inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The weight defining the constibution of each compartment to the physical identity of this element. <br /></td></tr>
<tr class="separator:aada8d021521dbe6815a887bc0cb28cc8 inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e442b31d2341cbe477d7c33195a576c inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e442b31d2341cbe477d7c33195a576c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a5e442b31d2341cbe477d7c33195a576c">isECMMimicing</a></td></tr>
<tr class="memdesc:a5e442b31d2341cbe477d7c33195a576c inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if the element is an ECM element. <br /></td></tr>
<tr class="separator:a5e442b31d2341cbe477d7c33195a576c inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25330a1d76d3ada08bd0dced22fb79b inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa25330a1d76d3ada08bd0dced22fb79b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#aa25330a1d76d3ada08bd0dced22fb79b">isECMMimimcingAtCircumference</a></td></tr>
<tr class="memdesc:aa25330a1d76d3ada08bd0dced22fb79b inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if the element is an ECM element at the circumference of the tissue. <br /></td></tr>
<tr class="separator:aa25330a1d76d3ada08bd0dced22fb79b inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd1d4807f83e12b2df7606acb7518b3 inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcd1d4807f83e12b2df7606acb7518b3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#afcd1d4807f83e12b2df7606acb7518b3">atBasalBorderOfECM</a></td></tr>
<tr class="memdesc:afcd1d4807f83e12b2df7606acb7518b3 inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if the element is at the basal border of the cellular layer, linking to ECM elements. <br /></td></tr>
<tr class="separator:afcd1d4807f83e12b2df7606acb7518b3 inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892e478508ed8a375f0816b330e36ac1 inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a892e478508ed8a375f0816b330e36ac1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a892e478508ed8a375f0816b330e36ac1">isActinMimicing</a></td></tr>
<tr class="memdesc:a892e478508ed8a375f0816b330e36ac1 inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if the element is forming the actin dense layer on the apical surface. <br /></td></tr>
<tr class="separator:a892e478508ed8a375f0816b330e36ac1 inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c9fe02c9c42e0617900c3282e4403a inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95c9fe02c9c42e0617900c3282e4403a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a95c9fe02c9c42e0617900c3282e4403a">atApicalBorderOfActin</a></td></tr>
<tr class="memdesc:a95c9fe02c9c42e0617900c3282e4403a inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if the element is at the apical border of the soft cellular layer, linking to actin dense layer. <br /></td></tr>
<tr class="separator:a95c9fe02c9c42e0617900c3282e4403a inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f09d39d079bfe95ea7c25f5d3de6c09 inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f09d39d079bfe95ea7c25f5d3de6c09"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a4f09d39d079bfe95ea7c25f5d3de6c09">IsAblated</a></td></tr>
<tr class="memdesc:a4f09d39d079bfe95ea7c25f5d3de6c09 inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if the element is laser ablated, therefore dead. <br /></td></tr>
<tr class="separator:a4f09d39d079bfe95ea7c25f5d3de6c09 inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d15f14d23230682242ed063872617af inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d15f14d23230682242ed063872617af"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a3d15f14d23230682242ed063872617af">atSymetricityBoundary</a></td></tr>
<tr class="memdesc:a3d15f14d23230682242ed063872617af inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if the element is at the symmetricity boundary. <br /></td></tr>
<tr class="separator:a3d15f14d23230682242ed063872617af inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d48903871978d77a77cb77f569975c0 inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d48903871978d77a77cb77f569975c0"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a3d48903871978d77a77cb77f569975c0">CurrShapeChangeToAdd</a> [3]</td></tr>
<tr class="memdesc:a3d48903871978d77a77cb77f569975c0 inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current shape change to be applied to the element, in form of 3D rates. <br /></td></tr>
<tr class="separator:a3d48903871978d77a77cb77f569975c0 inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1bafcaf21f040dd137abfe434a75a9 inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a1bafcaf21f040dd137abfe434a75a9"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a8a1bafcaf21f040dd137abfe434a75a9">GrownVolume</a></td></tr>
<tr class="memdesc:a8a1bafcaf21f040dd137abfe434a75a9 inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current volume of the element after growth. <br /></td></tr>
<tr class="separator:a8a1bafcaf21f040dd137abfe434a75a9 inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59943ecb9f8ec139c0f564c1fb91d876 inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59943ecb9f8ec139c0f564c1fb91d876"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a59943ecb9f8ec139c0f564c1fb91d876">VolumePerNode</a></td></tr>
<tr class="memdesc:a59943ecb9f8ec139c0f564c1fb91d876 inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume per node of the element. <br /></td></tr>
<tr class="separator:a59943ecb9f8ec139c0f564c1fb91d876 inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21420915ac7c8444e0e5b5f4e98d7322 inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21420915ac7c8444e0e5b5f4e98d7322"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a21420915ac7c8444e0e5b5f4e98d7322">capElement</a></td></tr>
<tr class="memdesc:a21420915ac7c8444e0e5b5f4e98d7322 inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if the element is capped at its remodelling due to restrictions in z remodelling (avoiding too thin ot too thick layers due to numerical error). <br /></td></tr>
<tr class="separator:a21420915ac7c8444e0e5b5f4e98d7322 inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef483e9f69872329b0a6365803dc8ff inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ef483e9f69872329b0a6365803dc8ff"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a5ef483e9f69872329b0a6365803dc8ff">elementsIdsOnSameColumn</a></td></tr>
<tr class="memdesc:a5ef483e9f69872329b0a6365803dc8ff inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector storing the unique element IDs of each element that is on the same columnar region of the tissue, i.e. the elements share apical/basal surfaces. <br /></td></tr>
<tr class="separator:a5ef483e9f69872329b0a6365803dc8ff inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7515f99cadce806894a7c254186a85f7 inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7515f99cadce806894a7c254186a85f7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a7515f99cadce806894a7c254186a85f7">basalNeigElementId</a></td></tr>
<tr class="memdesc:a7515f99cadce806894a7c254186a85f7 inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is recorded only for apical nodes of the columnar layer. If not recorded, id is -1. <br /></td></tr>
<tr class="separator:a7515f99cadce806894a7c254186a85f7 inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1571eea2fb8259868afa5814540fe61d inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1571eea2fb8259868afa5814540fe61d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a1571eea2fb8259868afa5814540fe61d">insideEllipseBand</a></td></tr>
<tr class="memdesc:a1571eea2fb8259868afa5814540fe61d inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if the element is marked by any identifier bands for physical perturbation. <br /></td></tr>
<tr class="separator:a1571eea2fb8259868afa5814540fe61d inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2b9ded0e51df7c23499ccc3f4da9fc inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d2b9ded0e51df7c23499ccc3f4da9fc"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a8d2b9ded0e51df7c23499ccc3f4da9fc">coveringEllipseBandId</a></td></tr>
<tr class="memdesc:a8d2b9ded0e51df7c23499ccc3f4da9fc inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unique ID of the covering perturbation band. <br /></td></tr>
<tr class="separator:a8d2b9ded0e51df7c23499ccc3f4da9fc inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1484f5942bbd147ce0e9e1d842919103 inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1484f5942bbd147ce0e9e1d842919103"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a1484f5942bbd147ce0e9e1d842919103">emergentShapeLongAxis</a> [2]</td></tr>
<tr class="memdesc:a1484f5942bbd147ce0e9e1d842919103 inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The long axis of the emergent shape. This is necessary for analysis of emergent growth orientations. <br /></td></tr>
<tr class="separator:a1484f5942bbd147ce0e9e1d842919103 inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c845ab5c6b7e8083faa1a9833765f7 inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60c845ab5c6b7e8083faa1a9833765f7"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a60c845ab5c6b7e8083faa1a9833765f7">emergentShapeShortAxis</a> [2]</td></tr>
<tr class="memdesc:a60c845ab5c6b7e8083faa1a9833765f7 inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The short axis of the emergent shape. This is necessary for analysis of emergent growth orientations. <br /></td></tr>
<tr class="separator:a60c845ab5c6b7e8083faa1a9833765f7 inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30219b72a2e37fad6ad5dfbcb371a85e inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30219b72a2e37fad6ad5dfbcb371a85e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a30219b72a2e37fad6ad5dfbcb371a85e">plasticDeformationHalfLifeMultiplier</a></td></tr>
<tr class="memdesc:a30219b72a2e37fad6ad5dfbcb371a85e inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The multiplier to modify the remodelling half-life upon physical property perturbation. <br /></td></tr>
<tr class="separator:a30219b72a2e37fad6ad5dfbcb371a85e inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3633ac9356d82c0259770ace63ca3d3d inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3633ac9356d82c0259770ace63ca3d3d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a3633ac9356d82c0259770ace63ca3d3d">isMutated</a></td></tr>
<tr class="memdesc:a3633ac9356d82c0259770ace63ca3d3d inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if the element is mutated. <br /></td></tr>
<tr class="separator:a3633ac9356d82c0259770ace63ca3d3d inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4ab7a9dcb19f182cde416757397b7c inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb4ab7a9dcb19f182cde416757397b7c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#afb4ab7a9dcb19f182cde416757397b7c">thereIsGrowthRedistribution</a></td></tr>
<tr class="memdesc:afb4ab7a9dcb19f182cde416757397b7c inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if there is redistribution of growth among mesh elements. <br /></td></tr>
<tr class="separator:afb4ab7a9dcb19f182cde416757397b7c inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7112715f6a436f2500793f67991b612c inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7112715f6a436f2500793f67991b612c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a7112715f6a436f2500793f67991b612c">growthRedistributionShrinksElement</a></td></tr>
<tr class="memdesc:a7112715f6a436f2500793f67991b612c inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean stating if the growth distribution is taking material out of thes element to redistribute ot others. <br /></td></tr>
<tr class="separator:a7112715f6a436f2500793f67991b612c inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7adb65c236a91a84acd9c1add5dc50 inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c7adb65c236a91a84acd9c1add5dc50"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a0c7adb65c236a91a84acd9c1add5dc50">growthRedistributionScale</a></td></tr>
<tr class="memdesc:a0c7adb65c236a91a84acd9c1add5dc50 inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The extent of the redistribution of volume. <br /></td></tr>
<tr class="separator:a0c7adb65c236a91a84acd9c1add5dc50 inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64f900d51cec3e48a488fdd8a51eacf inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af64f900d51cec3e48a488fdd8a51eacf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#af64f900d51cec3e48a488fdd8a51eacf">RotatedElement</a></td></tr>
<tr class="memdesc:af64f900d51cec3e48a488fdd8a51eacf inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean stating if the elemetn has rigid body rotation. <br /></td></tr>
<tr class="separator:af64f900d51cec3e48a488fdd8a51eacf inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1408c3e89b91787fec7e913cac1f58 inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc1408c3e89b91787fec7e913cac1f58"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#acc1408c3e89b91787fec7e913cac1f58">GrowthStrainsRotMat</a></td></tr>
<tr class="memdesc:acc1408c3e89b91787fec7e913cac1f58 inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The rotation matrix needed to correct for the rigid body rotations of the element. <br /></td></tr>
<tr class="separator:acc1408c3e89b91787fec7e913cac1f58 inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e7fb504d13f5d98d75c766e39e0143 inherit pub_attribs_classShapeBase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38e7fb504d13f5d98d75c766e39e0143"></a>
std::array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classShapeBase.html#a38e7fb504d13f5d98d75c766e39e0143">apicalNormalCurrentShape</a></td></tr>
<tr class="memdesc:a38e7fb504d13f5d98d75c766e39e0143 inherit pub_attribs_classShapeBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">The apical normal of the current shape. <br /></td></tr>
<tr class="separator:a38e7fb504d13f5d98d75c766e39e0143 inherit pub_attribs_classShapeBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a606fbf422f9d652e0f697ea93dc2e088"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Prism::calculateCurrNodalForces </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>gslcurrge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>gslcurrgv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>gslcurrF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>displacementPerDt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pointNo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function calculates the nodal forces of teh prism for the current Gauss Point. </p>
<p>&lt; Removing growth </p>

<p>Reimplemented from <a class="el" href="classShapeBase.html#acca6ea9484bbc995d941f1a7bb25e1db">ShapeBase</a>.</p>

</div>
</div>
<a class="anchor" id="ae9403142a217a005a4d588a6e472be27"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Prism::calculateCurrTriPointFForRotation </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>currF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pointNo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function calculates the deformation gradient of the prism for rigid body rotation rotation extractions, for the current Gauss Point. </p>
<p>This function calcultes the defrmation gradient \( \boldsymbol{F} \) for the input gauss point number pointNo. The calculated deformation gradient is recorded in the in input gsl_matrix pointer currF, the matrix must be allocated prior to calling the function. <br />
The deformation gradient is the derivative of current nodal positions of an element ( \( \boldsymbol{x} \) ) with respect to the reference shape positions ( \( \boldsymbol{X} \) ).</p>
<p class="formulaDsp">
\begin{eqnarray*} \frac{\partial \boldsymbol{x}} {\partial \boldsymbol{X}} \end{eqnarray*}
</p>

<p>Reimplemented from <a class="el" href="classShapeBase.html">ShapeBase</a>.</p>

</div>
</div>
<a class="anchor" id="ad339c17c6a056074dc4e642de9492c57"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Prism::calculateD81Tensor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function calculates the Lagrangian elasticity tensor for a neo-hookean material. </p>
<p>This function calculates the Lagrangian elasticity tensor for a neo-hookean material. The Lagrangian elasticity tensor depends on the deformation gradient through the Cauchy-Green Deformation tensor, and the physical material properties, namely Lame's second parameter \( \lambda \) and the sheer modulus \( \mu \). <br />
 \(\boldsymbol {\mathcal D} \) can be obtained in the Voigt notation: </p><p class="formulaDsp">
\begin{eqnarray*} \mathcal{D}_{ijkl} = \lambda \boldsymbol{C}^{-1}_{ij} \boldsymbol{C}^{-1}_{kl} + 2 \left( \mu - \lambda ln(J)\right) \mathcal{I}_{ijkl} \end{eqnarray*}
</p>
<p> where \( \mathcal{I}_{ijkl} \) is defined as: </p><p class="formulaDsp">
\begin{eqnarray*} \mathcal{I}_{ijkl} = \frac{1}{2} \left[ \boldsymbol{C}^{-1}_{ik} \boldsymbol{C}^{-1}_{jl} + \boldsymbol{C}^{-1}_{il} \boldsymbol{C}^{-1}_{jk}\right] \end{eqnarray*}
</p>
<p> where the indices $ i,j,k,l $ go through 3 dimensions.<br />
</p>

</div>
</div>
<a class="anchor" id="a9a877cebf651015b88af641f1e045699"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Prism::calculateElementShapeFunctionDerivatives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function calculates the shape function derivatives of the prism. </p>
<p>This function calculates the Shape Function Derivatives for all Gauss points, and then calculates the derivative of reference coordiantes with respect to barycentric coordinates \( \frac{\partial \boldsymbol{X}}{\partial \boldsymbol{\zeta}} \). The determnant of htis derivative is recorded for next steps of calculation.<br />
First the matrices for the reference shape and the \( \frac{\partial \boldsymbol{X}}{\partial \boldsymbol{\zeta}} \) for one gauss point are allocated.</p>
<p>The reference shape cordinates are obtained through function ShapeBase::getCurrRelaxedShape.</p>
<p>Looping over all the gauss points as listed in constructor <a class="el" href="classPrism.html#a9dcd242eef25b663bd3d43554ca5aeb4" title="Constructor. ">Prism::Prism</a>, the shape function derivatives are obtained in stack form via ShapeBase::setShapeFunctionDerivatives and ShapeBase::setShapeFunctionDerivativeStack functions. Then \( \frac{\partial \boldsymbol{X}}{\partial \boldsymbol{\zeta}} \), its determinant recorded in the array <a class="el" href="classShapeBase.html#a37f25110de54965266cb29b66eaf5b81" title="The array stores the determinants of the matrices for derivatives of world coordinates with respect t...">ShapeBase::detdXdes</a>.</p>

<p>Reimplemented from <a class="el" href="classShapeBase.html#ab86b6c4eef2ea6232dd1d0c300ae5602">ShapeBase</a>.</p>

</div>
</div>
<a class="anchor" id="a0a57c74e857e937883bb4581cd982da1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Prism::checkEdgeLenghtsForBinding </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>masterIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>slaveIds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function checks the edge lengths of the prism to decide if the elemetn should collapse its surfaces to avoid flipping. </p>
<p>This function returns the nodes to collapse together if any of the element surfaces are shrinking below the set threshold of 10% of the original side length (set in thresholdFraction variable).<br />
</p>
<p>The top side of the element will only be checked if the element top surface is at the exposed top surface of the tissue (apical surface, <a class="el" href="classShapeBase.html#aff63b1fcb823bbfdb5b19fe78dea59b8" title="1 -> apical, 0 -> basal, 2->middle, 3 -> lateral ">ShapeBase::tissuePlacement</a> = 0 or the element spans the whole tissue, <a class="el" href="classShapeBase.html#adafe85bbee6173d2a321408cd8b63db3" title="Boolean staing is the element spans the whole tissue. This is used to identify mid-layer tagged tissu...">ShapeBase::spansWholeTissue</a> = true).</p>
<p>The bottom side of the element will only be checked if the element bottom surface is at the exposed bottom surface of the tissue (basal surface, <a class="el" href="classShapeBase.html#aff63b1fcb823bbfdb5b19fe78dea59b8" title="1 -> apical, 0 -> basal, 2->middle, 3 -> lateral ">ShapeBase::tissuePlacement</a> = 1 or the element spans the whole tissue, <a class="el" href="classShapeBase.html#adafe85bbee6173d2a321408cd8b63db3" title="Boolean staing is the element spans the whole tissue. This is used to identify mid-layer tagged tissu...">ShapeBase::spansWholeTissue</a> = true).</p>

<p>Reimplemented from <a class="el" href="classShapeBase.html#ab277fb6868925516b675821add019cef">ShapeBase</a>.</p>

</div>
</div>
<a class="anchor" id="a3c252dc104a1ca7208b23c72737cd916"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Prism::getCurrRelaxedShape </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>CurrRelaxedShape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function writes the current relaxed shape of the elemetn in the gsl_matrix pointed by the provided input gsl_matrix pointer. </p>
<p>This function writes the current relaxed shape of the elemetn in the gsl_matrix pointed by the provided input gsl_matrix pointer. The matrix must be allocated before the call to the function.</p>

</div>
</div>
<a class="anchor" id="a6d95fcc54232f1b7777e988cdee98727"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Prism::setBasalNeigElementId </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classShapeBase.html">ShapeBase</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>elementsList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function sets the basal neighboiur of this element, which has an apical surface overlapping completely with teh basal surface of this prism. </p>
<p>This funciton sets the basal neighbours of all elemetns qualifying for a basal neighbour element. The check is only carried out on the apical elements of the coumnar tissue (<a class="el" href="classShapeBase.html#aff63b1fcb823bbfdb5b19fe78dea59b8" title="1 -> apical, 0 -> basal, 2->middle, 3 -> lateral ">ShapeBase::tissuePlacement</a> = 0, ShapeBase::TissueType = 0). The columnar elements bordering the basal extracellualar matrix (<a class="el" href="classShapeBase.html#afcd1d4807f83e12b2df7606acb7518b3" title="Boolean stating if the element is at the basal border of the cellular layer, linking to ECM elements...">ShapeBase::atBasalBorderOfECM</a> = true), and the basal extracellular matrix itself (<a class="el" href="classShapeBase.html#a5e442b31d2341cbe477d7c33195a576c" title="Boolean stating if the element is an ECM element. ">ShapeBase::isECMMimicing</a>) are not labelled, as these elements do not hold a basal neighbour that is a tissue piece.</p>
<p>Basal nodes of a prism are hte nodes recorded in <a class="el" href="classShapeBase.html#af96e17fa9a23289fb743ff0722a7dc64" title="The vector storing the unique IDs (Node::Id) of nodes constructing this element. Their order is consi...">ShapeBase::NodeIds</a> array indices 0-2.</p>
<p>When all three nodes are owned as apical nodes by another element, this is the neighbour I am looking for. If the element is NOT an explicit ECM element (<a class="el" href="classShapeBase.html#a5e442b31d2341cbe477d7c33195a576c" title="Boolean stating if the element is an ECM element. ">ShapeBase::isECMMimicing</a> = false), then the new Id is recorded into the <a class="el" href="classShapeBase.html#a7515f99cadce806894a7c254186a85f7" title="This is recorded only for apical nodes of the columnar layer. If not recorded, id is -1...">ShapeBase::basalNeigElementId</a>.</p>
<p>Once the element is found, break the loop regardless of the ECM status. If the loop has reached an ECM element then this element does not have a basal bordering tissue. It should not have this case anyway, as elemetns atBasalBorderOfECM are skipped.</p>

<p>Reimplemented from <a class="el" href="classShapeBase.html">ShapeBase</a>.</p>

</div>
</div>
<a class="anchor" id="a0575442613f8b7d9428c58cef19ab219"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Prism::setCoeffMat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function writes the coefficient matrix that is collating the calculated stresses in the form of the vector form of elemental stress and strain vectors. </p>
<p>The coefficient matrix collating the calculated stresses in the form of the vector form of elemental strss and strain vectors:</p>
<p class="formulaDsp">
\begin{eqnarray*} \boldsymbol{c} = \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\ 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\ \end{bmatrix} \sim \begin{bmatrix} \epsilon_{x} \\ \epsilon_{y} \\ \epsilon_{z}\\ \gamma_{x,y} \\ \gamma_{x,z} \\ \gamma_{y,z} \end{bmatrix} \sim \begin{bmatrix} \sigma_{x} \\ \sigma_{y} \\ \sigma_{z}\\ \sigma_{x,y} \\ \sigma_{x,z} \\ \sigma_{y,z} \end{bmatrix}. \end{eqnarray*}
</p>

</div>
</div>
<a class="anchor" id="aa1a4d3411d1f3dc05816ec01dcfa8310"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Prism::setShapeFunctionDerivatives </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>ShapeFuncDer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>zeta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>nu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function calculates and writes the shape function derivatives on the gsl_matrix pointed by the provided input gsl_matrix pointer, for the provided barycentric coordinates. </p>
<p>This function calculates and writes the shape function derivatives on the gsl_matrix pointed by the provided input gsl_matrix pointer, for the provided barycentric coordinates. The matrix must be allocated prior to calling the function. <br />
For the prism, the shape functions and their derivatives are given as:</p>
<p class="formulaDsp">
\begin{tabular}{|c|c|c|c|c|} \multicolumn{5}{|c|}{ $\lambda = 1 - \xi - \eta$ } \\ \multicolumn{5}{|c|}{ $\alpha = \left( 1-\zeta \right) /2$ } \\ \multicolumn{5}{|c|}{ $b = \left(1+\zeta\right)/2$ } \\ Node &amp; Shape function. &amp; Shape function &amp; Shape function &amp; Shape function. \\ &amp; &amp; derivative wrt $\xi$ &amp; derivative wrt $\zeta$ &amp; derivative wrt $\eta$ \\ &amp; $N$ &amp; $\frac{\partial{N}}{ \partial \xi}$ &amp; $\frac{\partial{N}}{\partial \zeta}$ &amp; $\frac{\partial{N}}{\partial \eta}$ \\ 1 &amp; $\lambda \alpha$ &amp; $- \alpha$ &amp; $- \alpha$ &amp; $ \frac{-\lambda} {2}$ \\ 2 &amp; $\xi \alpha$ &amp; $\alpha$ &amp; 0 &amp; $\frac{-\xi} {2} $ \\ 3 &amp; $\eta \alpha$ &amp; 0 &amp; $\alpha$ &amp; $\frac{-\nu} {2} $ \\ 4 &amp; $\lambda b$ &amp; $-b$ &amp; $-b$ &amp; $\frac{\lambda} {2} $ \\ 5 &amp; $\xi b$ &amp; $b$ &amp;0 &amp; $\frac{\xi} {2} $ \\ 6 &amp; $\eta b$ &amp; 0 &amp; $b$ &amp; $\frac{\eta} {2} $ \\ \end{tabular}
</p>
<p>The shape function derivatives matrix has the form: </p><p class="formulaDsp">
\begin{eqnarray*} \begin{bmatrix} \frac{\partial N_0}{ \partial \xi} &amp; ... &amp; \frac{\partial N_n}{ \partial \xi} \\ \frac{\partial N_0}{ \partial \zeta} &amp; ... &amp; \frac{\partial N_n}{ \partial \zeta} \\ \frac{\partial N_0}{ \partial \eta} &amp; ... &amp; \frac{\partial N_n}{ \partial \eta} \end{bmatrix} \end{eqnarray*}
</p>

</div>
</div>
<a class="anchor" id="aa1f76f3cabdd00eb057f41cebbaa466d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Prism::setShapeFunctionDerivativeStack </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>ShapeFuncDer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>ShapeFuncDerStack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function writes the input gsl_matrix ShapeFuncDer into a stack form, in the matrix ShapeFuncDerStack. Both matrices must be allocated prior to calling the function. </p>
<p>This function writes the input gsl_matrix ShapeFuncDer into a stack form, in the matrix ShapeFuncDerStack. Both matrices must be allocated prior to calling the function. This stack is for direct multiplication with B matrix during calculation of stresses. with the notation \( N_{i, \xi} \) being the short hand for \( \partial \boldsymbol{x_{i}} / \partial {\xi} \) for node i, the stack for of the shape function derivatives in open form is:</p>
<p class="formulaDsp">
\begin{eqnarray*} \begin{bmatrix} N_{0,\xi} &amp; 0 &amp; 0 &amp; N_{1,\xi} &amp; \cdots &amp;N_{n-1,\xi} &amp; 0 &amp; 0 \\ N_{0,\zeta} &amp; 0 &amp; 0 &amp; N_{1,\zeta} &amp; \cdots &amp;N_{n-1,\zeta} &amp; 0 &amp; 0 \\ N_{0,\nu} &amp; 0 &amp; 0 &amp; N_{1,\nu} &amp; \cdots &amp;N_{n-1,\nu} &amp; 0 &amp; 0 \\ 0 &amp; N_{0,\xi} &amp; 0 &amp; 0 &amp; \cdots &amp;0 &amp; N_{n-1,\xi} &amp; 0 \\ 0 &amp; N_{0,\zeta} &amp; 0 &amp; 0 &amp; \cdots &amp;0 &amp; N_{n-1,\zeta} &amp; 0 \\ 0 &amp; N_{0,\nu} &amp; 0 &amp; 0 &amp; \cdots &amp;0 &amp; N_{n-1,\nu} &amp; 0 \\ 0 &amp; 0 &amp; N_{0,\xi} &amp; 0 &amp; \cdots &amp;0 &amp;0 &amp; N_{n-1,\xi} \\ 0 &amp; 0 &amp; N_{0,\zeta} &amp; 0 &amp; \cdots &amp;0 &amp;0 &amp; N_{n-1,\zeta} \\ 0 &amp; 0 &amp; N_{0,\nu} &amp; 0 &amp; \cdots &amp;0 &amp;0 &amp; N_{n-1,\nu} . \end{bmatrix} \end{eqnarray*}
</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/melda/Documents/nonAcademic/TissueFoldingFefractor/TissueFoldingRefractor/TissueFoldingLinux/TissueFolding/SourceCode/<a class="el" href="Prism_8h_source.html">Prism.h</a></li>
<li>/home/melda/Documents/nonAcademic/TissueFoldingFefractor/TissueFoldingRefractor/TissueFoldingLinux/TissueFolding/SourceCode/Prism.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classPrism.html">Prism</a></li>
    <li class="footer">Generated on Wed May 29 2019 16:14:30 for Tissue Origami by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
