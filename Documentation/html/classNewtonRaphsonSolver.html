<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Tissue Origami: NewtonRaphsonSolver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tissue Origami
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classNewtonRaphsonSolver.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classNewtonRaphsonSolver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">NewtonRaphsonSolver Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="NewtonRaphsonSolver_8h_source.html">NewtonRaphsonSolver.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3cd02ecd63a37d6b621ece7f781aeefd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNewtonRaphsonSolver.html#a3cd02ecd63a37d6b621ece7f781aeefd">NewtonRaphsonSolver</a> (int nDim, int nNodes)</td></tr>
<tr class="memdesc:a3cd02ecd63a37d6b621ece7f781aeefd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructer of the N-R solver.  <a href="#a3cd02ecd63a37d6b621ece7f781aeefd">More...</a><br /></td></tr>
<tr class="separator:a3cd02ecd63a37d6b621ece7f781aeefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84bf8e492138670ee2a9355c65b35904"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84bf8e492138670ee2a9355c65b35904"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNewtonRaphsonSolver.html#a84bf8e492138670ee2a9355c65b35904">~NewtonRaphsonSolver</a> ()</td></tr>
<tr class="memdesc:a84bf8e492138670ee2a9355c65b35904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Desturctor of the N-R solver. <br /></td></tr>
<tr class="separator:a84bf8e492138670ee2a9355c65b35904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d01456ea07e72b0f02ae2e8d2b8ec9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d01456ea07e72b0f02ae2e8d2b8ec9e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNewtonRaphsonSolver.html#a3d01456ea07e72b0f02ae2e8d2b8ec9e">setMatricesToZeroAtTheBeginningOfIteration</a> ()</td></tr>
<tr class="memdesc:a3d01456ea07e72b0f02ae2e8d2b8ec9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function setting the calculation matrices to zero at the beginning of each iteration. <br /></td></tr>
<tr class="separator:a3d01456ea07e72b0f02ae2e8d2b8ec9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d647a13f9942e90e288a42c5444c4d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36d647a13f9942e90e288a42c5444c4d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNewtonRaphsonSolver.html#a36d647a13f9942e90e288a42c5444c4d">setMatricesToZeroInsideIteration</a> ()</td></tr>
<tr class="memdesc:a36d647a13f9942e90e288a42c5444c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function setting the relevant matrices to zero at each iteration. <br /></td></tr>
<tr class="separator:a36d647a13f9942e90e288a42c5444c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af759360cc54ea9515deb3cc2ecc83377"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af759360cc54ea9515deb3cc2ecc83377"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNewtonRaphsonSolver.html#af759360cc54ea9515deb3cc2ecc83377">constructUnMatrix</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; &gt; &amp;Nodes)</td></tr>
<tr class="memdesc:af759360cc54ea9515deb3cc2ecc83377"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function constructs <a class="el" href="classNewtonRaphsonSolver.html#a89a6e2f583c785b77b967e6f0e9f5893" title="The initial positions of the nodes, as calculated at the end of previous step &quot;n&quot;. ">NewtonRaphsonSolver::un</a> matrix at the beginning of the iterations. <br /></td></tr>
<tr class="separator:af759360cc54ea9515deb3cc2ecc83377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b7753542f36889cd030104937d76a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48b7753542f36889cd030104937d76a3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNewtonRaphsonSolver.html#a48b7753542f36889cd030104937d76a3">initialteUkMatrix</a> ()</td></tr>
<tr class="memdesc:a48b7753542f36889cd030104937d76a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initiates <a class="el" href="classNewtonRaphsonSolver.html#ad217268afdeb4838d3b58f075762de95" title="The matrix storing the position of each node at iteration &quot;k&quot;. Initiated in function NewtonRaphsonSol...">NewtonRaphsonSolver::uk</a> matrix at the beginning of the iterations, it is initiated to be equal to <a class="el" href="classNewtonRaphsonSolver.html#a89a6e2f583c785b77b967e6f0e9f5893" title="The initial positions of the nodes, as calculated at the end of previous step &quot;n&quot;. ">NewtonRaphsonSolver::un</a>. <br /></td></tr>
<tr class="separator:a48b7753542f36889cd030104937d76a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e2ec4519853c9acfaf120c4b513651"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNewtonRaphsonSolver.html#aa1e2ec4519853c9acfaf120c4b513651">calculateBoundKWithSlavesMasterDoF</a> ()</td></tr>
<tr class="memdesc:aa1e2ec4519853c9acfaf120c4b513651"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function updates the Jacobian of the system, <a class="el" href="classNewtonRaphsonSolver.html#a4e9ffc424dd37c6c00f9de3d7ac455ed" title="The Jacobian matrix, derivative of sum of forces acting on each node with respect to displacements...">NewtonRaphsonSolver::K</a>, to reflect degrees of freedom binding.  <a href="#aa1e2ec4519853c9acfaf120c4b513651">More...</a><br /></td></tr>
<tr class="separator:aa1e2ec4519853c9acfaf120c4b513651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1670a14238d705e839d7bd80fb42c13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1670a14238d705e839d7bd80fb42c13"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNewtonRaphsonSolver.html#ad1670a14238d705e839d7bd80fb42c13">equateSlaveDisplacementsToMasters</a> ()</td></tr>
<tr class="memdesc:ad1670a14238d705e839d7bd80fb42c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function moves the slaves of bound couples with a displacement equivalent to the masters'. <br /></td></tr>
<tr class="separator:ad1670a14238d705e839d7bd80fb42c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ce333a40397fd113f9b9fc47bcb6ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNewtonRaphsonSolver.html#aa0ce333a40397fd113f9b9fc47bcb6ca">calculateDisplacementMatrix</a> (double dt)</td></tr>
<tr class="memdesc:aa0ce333a40397fd113f9b9fc47bcb6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the displacement of each node in current iteration "k", from their positions at the end of the previous step "n" (<a class="el" href="classNewtonRaphsonSolver.html#ad217268afdeb4838d3b58f075762de95" title="The matrix storing the position of each node at iteration &quot;k&quot;. Initiated in function NewtonRaphsonSol...">NewtonRaphsonSolver::uk</a> - <a class="el" href="classNewtonRaphsonSolver.html#a89a6e2f583c785b77b967e6f0e9f5893" title="The initial positions of the nodes, as calculated at the end of previous step &quot;n&quot;. ">NewtonRaphsonSolver::un</a>)  <a href="#aa0ce333a40397fd113f9b9fc47bcb6ca">More...</a><br /></td></tr>
<tr class="separator:aa0ce333a40397fd113f9b9fc47bcb6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfaaed8f038167756f352b566b8455d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNewtonRaphsonSolver.html#acfaaed8f038167756f352b566b8455d7">calcutateFixedK</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes)</td></tr>
<tr class="memdesc:acfaaed8f038167756f352b566b8455d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function updates the Jacobian to account for nodes that are fixed in certain dimensions in space, as part of boundary conditions.  <a href="#acfaaed8f038167756f352b566b8455d7">More...</a><br /></td></tr>
<tr class="separator:acfaaed8f038167756f352b566b8455d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5793ee41a3a4d97c0c944347f1f6da8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNewtonRaphsonSolver.html#a5793ee41a3a4d97c0c944347f1f6da8e">calculateForcesAndJacobianMatrixNR</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes, const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classShapeBase.html">ShapeBase</a> &gt;&gt; &amp;Elements, double dt)</td></tr>
<tr class="memdesc:a5793ee41a3a4d97c0c944347f1f6da8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates elemental forces and Jacobians, later to be combined in <a class="el" href="classNewtonRaphsonSolver.html#a4e9ffc424dd37c6c00f9de3d7ac455ed" title="The Jacobian matrix, derivative of sum of forces acting on each node with respect to displacements...">NewtonRaphsonSolver::K</a> and <a class="el" href="classNewtonRaphsonSolver.html#a843bd105e92dfa1c9205e4efa134a406" title="The matrix containing sum of NewtonRaphsonSolver::ge, NewtonRaphsonSolver::gvInternal, NewtonRaphsonSolver::gvExternal, NewtonRaphsonSolver::gExt. Organisation is [Node0,x ; Node0,y ; Node0,z; ... ; Noden,x ; Noden,y ; Noden,z]. ">NewtonRaphsonSolver::gSum</a>.  <a href="#a5793ee41a3a4d97c0c944347f1f6da8e">More...</a><br /></td></tr>
<tr class="separator:a5793ee41a3a4d97c0c944347f1f6da8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7345c1d02bf38b1c36cf1f5110f869"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca7345c1d02bf38b1c36cf1f5110f869"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNewtonRaphsonSolver.html#aca7345c1d02bf38b1c36cf1f5110f869">writeForcesTogeAndgvInternal</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes, const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classShapeBase.html">ShapeBase</a> &gt;&gt; &amp;Elements, std::vector&lt; std::array&lt; double, 3 &gt;&gt; &amp;SystemForces)</td></tr>
<tr class="memdesc:aca7345c1d02bf38b1c36cf1f5110f869"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes the values of elemental elastic (ShapeBase::ge) and internal viscous forces (ShapeBase::gvInternal) into the system elastic and internal viscous forces, <a class="el" href="classNewtonRaphsonSolver.html#a3b2a215e49d3c1d6d12eb7c8c73e9ff6" title="The matrix containing elastic forces on each node, size (nDim*nNodes,1). Organisation is [Node0...">NewtonRaphsonSolver::ge</a>, and <a class="el" href="classNewtonRaphsonSolver.html#a79fd12919ceb329bc177f16f3ce897b6" title="The matrix containing internal viscous forces on each node, size (nDim*nNodes,1). Organisation is [No...">NewtonRaphsonSolver::gvInternal</a>, respectively. <br /></td></tr>
<tr class="separator:aca7345c1d02bf38b1c36cf1f5110f869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6e3a4d0cf1c6e4fdf2753c7f08df13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNewtonRaphsonSolver.html#a0d6e3a4d0cf1c6e4fdf2753c7f08df13">writeImplicitElementalKToJacobian</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classShapeBase.html">ShapeBase</a> &gt;&gt; &amp;Elements)</td></tr>
<tr class="memdesc:a0d6e3a4d0cf1c6e4fdf2753c7f08df13"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes the elemental values for elastic part of the Jacobian - stiffness matrix - (<a class="el" href="classShapeBase.html#ace20710f27099833509c474b221c25df" title="Current elastic part of the Jacobian (stiffness matrix) of the system, averaged over all Gauss Points...">ShapeBase::TriPointKe</a>) and for viscous part of Jacobian (<a class="el" href="classShapeBase.html#a7fa5b1338e405a2c75c8d010f4153b05" title="Current viscous part of the Jacobian of the system, averaged over all Gauss Points. ">ShapeBase::TriPointKv</a>) into the system Jacobian <a class="el" href="classNewtonRaphsonSolver.html#a4e9ffc424dd37c6c00f9de3d7ac455ed" title="The Jacobian matrix, derivative of sum of forces acting on each node with respect to displacements...">NewtonRaphsonSolver::K</a>.  <a href="#a0d6e3a4d0cf1c6e4fdf2753c7f08df13">More...</a><br /></td></tr>
<tr class="separator:a0d6e3a4d0cf1c6e4fdf2753c7f08df13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39200f7babf1a3761a010c1a43f7c22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNewtonRaphsonSolver.html#ad39200f7babf1a3761a010c1a43f7c22">calculateExternalViscousForcesForNR</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes)</td></tr>
<tr class="memdesc:ad39200f7babf1a3761a010c1a43f7c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the external viscous forces acting on each node, the values are sotred in <a class="el" href="classNewtonRaphsonSolver.html#a80160d7bfb04a39e3b8910b68f66aa6d" title="The matrix containing external viscous forces on each node, size (nDim*nNodes,1). Organisation is [No...">NewtonRaphsonSolver::gvExternal</a>.  <a href="#ad39200f7babf1a3761a010c1a43f7c22">More...</a><br /></td></tr>
<tr class="separator:ad39200f7babf1a3761a010c1a43f7c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78759a96ed41bf35e8401b7c63180ea2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNewtonRaphsonSolver.html#a78759a96ed41bf35e8401b7c63180ea2">addImplicitKViscousExternalToJacobian</a> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;Nodes, double dt)</td></tr>
<tr class="memdesc:a78759a96ed41bf35e8401b7c63180ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function adds the external related terms of the Jacobian to the system Jacobian <a class="el" href="classNewtonRaphsonSolver.html#a4e9ffc424dd37c6c00f9de3d7ac455ed" title="The Jacobian matrix, derivative of sum of forces acting on each node with respect to displacements...">NewtonRaphsonSolver::K</a>.  <a href="#a78759a96ed41bf35e8401b7c63180ea2">More...</a><br /></td></tr>
<tr class="separator:a78759a96ed41bf35e8401b7c63180ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40dee8332c648b53cb9b1c8f2f2861ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNewtonRaphsonSolver.html#a40dee8332c648b53cb9b1c8f2f2861ee">checkJacobianForAblatedNodes</a> (std::vector&lt; int &gt; &amp;AblatedNodes)</td></tr>
<tr class="memdesc:a40dee8332c648b53cb9b1c8f2f2861ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions checks the Jacobian to ensure the diagonal terms are non-zero for ablated nodes.  <a href="#a40dee8332c648b53cb9b1c8f2f2861ee">More...</a><br /></td></tr>
<tr class="separator:a40dee8332c648b53cb9b1c8f2f2861ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9098983f90b6237a9d32ea633bcb7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba9098983f90b6237a9d32ea633bcb7f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNewtonRaphsonSolver.html#aba9098983f90b6237a9d32ea633bcb7f">calculateSumOfInternalForces</a> ()</td></tr>
<tr class="memdesc:aba9098983f90b6237a9d32ea633bcb7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function adds the ealsticity and viscosity related forces (<a class="el" href="classNewtonRaphsonSolver.html#a3b2a215e49d3c1d6d12eb7c8c73e9ff6" title="The matrix containing elastic forces on each node, size (nDim*nNodes,1). Organisation is [Node0...">NewtonRaphsonSolver::ge</a>, <a class="el" href="classNewtonRaphsonSolver.html#a79fd12919ceb329bc177f16f3ce897b6" title="The matrix containing internal viscous forces on each node, size (nDim*nNodes,1). Organisation is [No...">NewtonRaphsonSolver::gvInternal</a>, <a class="el" href="classNewtonRaphsonSolver.html#a80160d7bfb04a39e3b8910b68f66aa6d" title="The matrix containing external viscous forces on each node, size (nDim*nNodes,1). Organisation is [No...">NewtonRaphsonSolver::gvExternal</a>) to sum of forces, <a class="el" href="classNewtonRaphsonSolver.html#a843bd105e92dfa1c9205e4efa134a406" title="The matrix containing sum of NewtonRaphsonSolver::ge, NewtonRaphsonSolver::gvInternal, NewtonRaphsonSolver::gvExternal, NewtonRaphsonSolver::gExt. Organisation is [Node0,x ; Node0,y ; Node0,z; ... ; Noden,x ; Noden,y ; Noden,z]. ">NewtonRaphsonSolver::gSum</a>. <br /></td></tr>
<tr class="separator:aba9098983f90b6237a9d32ea633bcb7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f8fb47b9c29dd9856228ba0602f69e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNewtonRaphsonSolver.html#a24f8fb47b9c29dd9856228ba0602f69e">addExernalForces</a> ()</td></tr>
<tr class="separator:a24f8fb47b9c29dd9856228ba0602f69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8efb09b253b7d19bd978296314d65c24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNewtonRaphsonSolver.html#a8efb09b253b7d19bd978296314d65c24">solveForDeltaU</a> ()</td></tr>
<tr class="memdesc:a8efb09b253b7d19bd978296314d65c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function solves for the displacements within the N-R step.  <a href="#a8efb09b253b7d19bd978296314d65c24">More...</a><br /></td></tr>
<tr class="separator:a8efb09b253b7d19bd978296314d65c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710aa89593ea0236da8bf6e4594dbe3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a710aa89593ea0236da8bf6e4594dbe3d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>solveWithPardiso</b> (double *a, double *b, int *ia, int *ja, const int n_variables)</td></tr>
<tr class="separator:a710aa89593ea0236da8bf6e4594dbe3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfef5ffb5b0c224dd707c5cb5a79e77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="addfef5ffb5b0c224dd707c5cb5a79e77"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>constructiaForPardiso</b> (int *ia, const int nmult, std::vector&lt; int &gt; &amp;ja_vec, std::vector&lt; double &gt; &amp;a_vec)</td></tr>
<tr class="separator:addfef5ffb5b0c224dd707c5cb5a79e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1821e3689ccc552557a6704bcd1e1b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1821e3689ccc552557a6704bcd1e1b4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>writeKinPardisoFormat</b> (const int nNonzero, std::vector&lt; int &gt; &amp;ja_vec, std::vector&lt; double &gt; &amp;a_vec, int *ja, double *a)</td></tr>
<tr class="separator:aa1821e3689ccc552557a6704bcd1e1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78957a2905c38a9170a5c27d6f49326d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78957a2905c38a9170a5c27d6f49326d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>writeginPardisoFormat</b> (double *b, const int n)</td></tr>
<tr class="separator:a78957a2905c38a9170a5c27d6f49326d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3653a563e32649e0c90407aa089a995b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNewtonRaphsonSolver.html#a3653a563e32649e0c90407aa089a995b">checkConvergenceViaDeltaU</a> ()</td></tr>
<tr class="memdesc:a3653a563e32649e0c90407aa089a995b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for cenvergence with the norm of displacements vector,against the threshold NewtonRaphsonSolver::threshold.  <a href="#a3653a563e32649e0c90407aa089a995b">More...</a><br /></td></tr>
<tr class="separator:a3653a563e32649e0c90407aa089a995b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16edb5206c079476a0d6c2c956c65f25"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNewtonRaphsonSolver.html#a16edb5206c079476a0d6c2c956c65f25">checkConvergenceViaForce</a> ()</td></tr>
<tr class="memdesc:a16edb5206c079476a0d6c2c956c65f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for cenvergence with the norm of forces vector,against the threshold NewtonRaphsonSolver::threshold.  <a href="#a16edb5206c079476a0d6c2c956c65f25">More...</a><br /></td></tr>
<tr class="separator:a16edb5206c079476a0d6c2c956c65f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e457b3608c6fbd71767cd6eed07b2f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNewtonRaphsonSolver.html#a5e457b3608c6fbd71767cd6eed07b2f7">updateUkInIteration</a> ()</td></tr>
<tr class="memdesc:a5e457b3608c6fbd71767cd6eed07b2f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calulate the nodal displacemetns at the kth iteration of NR dolver.  <a href="#a5e457b3608c6fbd71767cd6eed07b2f7">More...</a><br /></td></tr>
<tr class="separator:a5e457b3608c6fbd71767cd6eed07b2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f873749f4a94498ddbc5d3648c5c404"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f873749f4a94498ddbc5d3648c5c404"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>displayMatrix</b> (gsl_matrix *mat, std::string matname)</td></tr>
<tr class="separator:a3f873749f4a94498ddbc5d3648c5c404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e33c406f4e366b2d3c2e4b5d650a1ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e33c406f4e366b2d3c2e4b5d650a1ba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>displayMatrix</b> (gsl_vector *mat, std::string matname)</td></tr>
<tr class="separator:a7e33c406f4e366b2d3c2e4b5d650a1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cdedabbc023ac182c924b1ec6c3804d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9cdedabbc023ac182c924b1ec6c3804d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>checkIfCombinationExists</b> (int dofSlave, int dofMaster)</td></tr>
<tr class="separator:a9cdedabbc023ac182c924b1ec6c3804d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc04a2a1d6132eb01437f318bcb5103"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNewtonRaphsonSolver.html#a1cc04a2a1d6132eb01437f318bcb5103">checkMasterUpdate</a> (int &amp;dofMaster, int &amp;masterId)</td></tr>
<tr class="memdesc:a1cc04a2a1d6132eb01437f318bcb5103"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes a degree of freedom number as input. This DOF is supposed to be a master. If, the dof is already a slave to another dof, then update the masetr dof. Anything that would be bound to the input dof can be bound to the already existing master of the input dof.  <a href="#a1cc04a2a1d6132eb01437f318bcb5103">More...</a><br /></td></tr>
<tr class="separator:a1cc04a2a1d6132eb01437f318bcb5103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4dd0fae0f0d56355521fbd22875bda8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNewtonRaphsonSolver.html#ab4dd0fae0f0d56355521fbd22875bda8">checkIfSlaveIsAlreadyMasterOfOthers</a> (int dofSlave, int dofMaster)</td></tr>
<tr class="memdesc:ab4dd0fae0f0d56355521fbd22875bda8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if the slave DOF is already master of others, if so, updates the master of said slave to the new master the current slave will be bound to.  <a href="#ab4dd0fae0f0d56355521fbd22875bda8">More...</a><br /></td></tr>
<tr class="separator:ab4dd0fae0f0d56355521fbd22875bda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7065afed801c6edf31a76c9578b325ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7065afed801c6edf31a76c9578b325ea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateElementPositions</b> (const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt; &gt; &amp;Nodes, const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classShapeBase.html">ShapeBase</a> &gt;&gt; &amp;Elements)</td></tr>
<tr class="separator:a7065afed801c6edf31a76c9578b325ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a89a6e2f583c785b77b967e6f0e9f5893"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89a6e2f583c785b77b967e6f0e9f5893"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNewtonRaphsonSolver.html#a89a6e2f583c785b77b967e6f0e9f5893">un</a></td></tr>
<tr class="memdesc:a89a6e2f583c785b77b967e6f0e9f5893"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initial positions of the nodes, as calculated at the end of previous step "n". <br /></td></tr>
<tr class="separator:a89a6e2f583c785b77b967e6f0e9f5893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2a215e49d3c1d6d12eb7c8c73e9ff6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b2a215e49d3c1d6d12eb7c8c73e9ff6"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNewtonRaphsonSolver.html#a3b2a215e49d3c1d6d12eb7c8c73e9ff6">ge</a></td></tr>
<tr class="memdesc:a3b2a215e49d3c1d6d12eb7c8c73e9ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matrix containing elastic forces on each node, size (nDim*nNodes,1). Organisation is [Node0,x ; Node0,y ; Node0,z; ... ; Noden,x ; Noden,y ; Noden,z]. <br /></td></tr>
<tr class="separator:a3b2a215e49d3c1d6d12eb7c8c73e9ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fd12919ceb329bc177f16f3ce897b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79fd12919ceb329bc177f16f3ce897b6"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNewtonRaphsonSolver.html#a79fd12919ceb329bc177f16f3ce897b6">gvInternal</a></td></tr>
<tr class="memdesc:a79fd12919ceb329bc177f16f3ce897b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matrix containing internal viscous forces on each node, size (nDim*nNodes,1). Organisation is [Node0,x ; Node0,y ; Node0,z; ... ; Noden,x ; Noden,y ; Noden,z]. <br /></td></tr>
<tr class="separator:a79fd12919ceb329bc177f16f3ce897b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80160d7bfb04a39e3b8910b68f66aa6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80160d7bfb04a39e3b8910b68f66aa6d"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNewtonRaphsonSolver.html#a80160d7bfb04a39e3b8910b68f66aa6d">gvExternal</a></td></tr>
<tr class="memdesc:a80160d7bfb04a39e3b8910b68f66aa6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matrix containing external viscous forces on each node, size (nDim*nNodes,1). Organisation is [Node0,x ; Node0,y ; Node0,z; ... ; Noden,x ; Noden,y ; Noden,z]. <br /></td></tr>
<tr class="separator:a80160d7bfb04a39e3b8910b68f66aa6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee5ceb54c8d439c1044ad3997d079ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afee5ceb54c8d439c1044ad3997d079ea"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNewtonRaphsonSolver.html#afee5ceb54c8d439c1044ad3997d079ea">gExt</a></td></tr>
<tr class="memdesc:afee5ceb54c8d439c1044ad3997d079ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matrix containing external forces on each node (currently includes packing forces), size (nDim*nNodes,1). Organisation is [Node0,x ; Node0,y ; Node0,z; ... ; Noden,x ; Noden,y ; Noden,z]. <br /></td></tr>
<tr class="separator:afee5ceb54c8d439c1044ad3997d079ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843bd105e92dfa1c9205e4efa134a406"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a843bd105e92dfa1c9205e4efa134a406"></a>
gsl_vector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNewtonRaphsonSolver.html#a843bd105e92dfa1c9205e4efa134a406">gSum</a></td></tr>
<tr class="memdesc:a843bd105e92dfa1c9205e4efa134a406"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matrix containing sum of <a class="el" href="classNewtonRaphsonSolver.html#a3b2a215e49d3c1d6d12eb7c8c73e9ff6" title="The matrix containing elastic forces on each node, size (nDim*nNodes,1). Organisation is [Node0...">NewtonRaphsonSolver::ge</a>, <a class="el" href="classNewtonRaphsonSolver.html#a79fd12919ceb329bc177f16f3ce897b6" title="The matrix containing internal viscous forces on each node, size (nDim*nNodes,1). Organisation is [No...">NewtonRaphsonSolver::gvInternal</a>, <a class="el" href="classNewtonRaphsonSolver.html#a80160d7bfb04a39e3b8910b68f66aa6d" title="The matrix containing external viscous forces on each node, size (nDim*nNodes,1). Organisation is [No...">NewtonRaphsonSolver::gvExternal</a>, <a class="el" href="classNewtonRaphsonSolver.html#afee5ceb54c8d439c1044ad3997d079ea" title="The matrix containing external forces on each node (currently includes packing forces), size (nDim*nNodes,1). Organisation is [Node0,x ; Node0,y ; Node0,z; ... ; Noden,x ; Noden,y ; Noden,z]. ">NewtonRaphsonSolver::gExt</a>. Organisation is [Node0,x ; Node0,y ; Node0,z; ... ; Noden,x ; Noden,y ; Noden,z]. <br /></td></tr>
<tr class="separator:a843bd105e92dfa1c9205e4efa134a406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad217268afdeb4838d3b58f075762de95"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad217268afdeb4838d3b58f075762de95"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNewtonRaphsonSolver.html#ad217268afdeb4838d3b58f075762de95">uk</a></td></tr>
<tr class="memdesc:ad217268afdeb4838d3b58f075762de95"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matrix storing the position of each node at iteration "k". Initiated in function <a class="el" href="classNewtonRaphsonSolver.html#a48b7753542f36889cd030104937d76a3" title="This function initiates NewtonRaphsonSolver::uk matrix at the beginning of the iterations, it is initiated to be equal to NewtonRaphsonSolver::un. ">NewtonRaphsonSolver::initialteUkMatrix</a> at the beginning of each step, and updated by function <a class="el" href="classNewtonRaphsonSolver.html#a5e457b3608c6fbd71767cd6eed07b2f7" title="Calulate the nodal displacemetns at the kth iteration of NR dolver. ">NewtonRaphsonSolver::updateUkInIteration</a> during the iteartions. <br /></td></tr>
<tr class="separator:ad217268afdeb4838d3b58f075762de95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c25883f25c52190ea88893ede622e6b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c25883f25c52190ea88893ede622e6b"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNewtonRaphsonSolver.html#a5c25883f25c52190ea88893ede622e6b">displacementPerDt</a></td></tr>
<tr class="memdesc:a5c25883f25c52190ea88893ede622e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The displacement per time step of each node in current iteration "k", from its position at the end of the last time step "n". <br /></td></tr>
<tr class="separator:a5c25883f25c52190ea88893ede622e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064de5e752631defb9dc1b33d5c115f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a064de5e752631defb9dc1b33d5c115f2"></a>
gsl_vector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNewtonRaphsonSolver.html#a064de5e752631defb9dc1b33d5c115f2">deltaU</a></td></tr>
<tr class="memdesc:a064de5e752631defb9dc1b33d5c115f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The incremental change in positions as calculated in current iteration, resulting from the imbalance of elastic, viscous and any other external forces acting on each nodes. The solver minimises this value, convergence occurs when all incremental movements for all nodes sufficiently close to zero. <br /></td></tr>
<tr class="separator:a064de5e752631defb9dc1b33d5c115f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9ffc424dd37c6c00f9de3d7ac455ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e9ffc424dd37c6c00f9de3d7ac455ed"></a>
gsl_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNewtonRaphsonSolver.html#a4e9ffc424dd37c6c00f9de3d7ac455ed">K</a></td></tr>
<tr class="memdesc:a4e9ffc424dd37c6c00f9de3d7ac455ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Jacobian matrix, derivative of sum of forces acting on each node with respect to displacements. <br /></td></tr>
<tr class="separator:a4e9ffc424dd37c6c00f9de3d7ac455ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00970bee6f2c4e1ed503e9c8df65e6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac00970bee6f2c4e1ed503e9c8df65e6d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNewtonRaphsonSolver.html#ac00970bee6f2c4e1ed503e9c8df65e6d">boundNodesWithSlaveMasterDefinition</a></td></tr>
<tr class="memdesc:ac00970bee6f2c4e1ed503e9c8df65e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boolean stating if there are degrees of freedom slave to other nodes (masters). <br /></td></tr>
<tr class="separator:ac00970bee6f2c4e1ed503e9c8df65e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e76823173b89fe71fac26ba4edc191"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08e76823173b89fe71fac26ba4edc191"></a>
std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNewtonRaphsonSolver.html#a08e76823173b89fe71fac26ba4edc191">slaveMasterList</a></td></tr>
<tr class="memdesc:a08e76823173b89fe71fac26ba4edc191"><td class="mdescLeft">&#160;</td><td class="mdescRight">The 2D integer vector storing the slave-master degrees of freedom couples, such that array [i][0] = slave to array[i][1], each i representing one dim of node position ( z of node 2 is DoF i=8);. <br /></td></tr>
<tr class="separator:a08e76823173b89fe71fac26ba4edc191"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Newton-Raphson solver class </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a3cd02ecd63a37d6b621ece7f781aeefd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NewtonRaphsonSolver::NewtonRaphsonSolver </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructer of the N-R solver. </p>
<p>The function initiates (memory allocates) the necessary matrices for the numerical solver.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a24f8fb47b9c29dd9856228ba0602f69e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NewtonRaphsonSolver::addExernalForces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function adds the external forces on the system sum of forces, <a class="el" href="classNewtonRaphsonSolver.html#a843bd105e92dfa1c9205e4efa134a406" title="The matrix containing sum of NewtonRaphsonSolver::ge, NewtonRaphsonSolver::gvInternal, NewtonRaphsonSolver::gvExternal, NewtonRaphsonSolver::gExt. Organisation is [Node0,x ; Node0,y ; Node0,z; ... ; Noden,x ; Noden,y ; Noden,z]. ">NewtonRaphsonSolver::gSum</a>)</p>

</div>
</div>
<a class="anchor" id="a78759a96ed41bf35e8401b7c63180ea2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NewtonRaphsonSolver::addImplicitKViscousExternalToJacobian </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>Nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function adds the external related terms of the Jacobian to the system Jacobian <a class="el" href="classNewtonRaphsonSolver.html#a4e9ffc424dd37c6c00f9de3d7ac455ed" title="The Jacobian matrix, derivative of sum of forces acting on each node with respect to displacements...">NewtonRaphsonSolver::K</a>. </p>
<p>This function will add the derivatives of external viscous drag forces with respect to nodal displacement onto the system Jacobian.</p>

</div>
</div>
<a class="anchor" id="aa1e2ec4519853c9acfaf120c4b513651"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NewtonRaphsonSolver::calculateBoundKWithSlavesMasterDoF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function updates the Jacobian of the system, <a class="el" href="classNewtonRaphsonSolver.html#a4e9ffc424dd37c6c00f9de3d7ac455ed" title="The Jacobian matrix, derivative of sum of forces acting on each node with respect to displacements...">NewtonRaphsonSolver::K</a>, to reflect degrees of freedom binding. </p>
<p>The matrix calculation for node binding is in the form: <br />
 </p><p class="formulaDsp">
\begin{eqnarray*} \boldsymbol{K}_{bound} &amp; = &amp; \boldsymbol{N^{T}} \boldsymbol{K} \boldsymbol{N} + \boldsymbol{\bar{I}}\\ \boldsymbol{g}_{bound} &amp; = &amp; \boldsymbol{N^{T}} \boldsymbol{g} \\ \boldsymbol{N_{ij}} &amp;= &amp; \left\{ \begin{matrix} 1 &amp; if &amp; i = j \text{ and } i \text{ is not a slave}\\ 1 &amp; if &amp; i \text{ is slave to } j \\ 0 &amp; &amp; \text{elsewhere} \end{matrix} \right. \\ \boldsymbol{\bar{I}_{ij}} &amp; = &amp; \left\{ \begin{matrix} 1 &amp; if &amp; i = j \text{ and } i \text{ is a slave}\\ 0 &amp; &amp; \text{elsewhere} \end{matrix} \right. \\ \end{eqnarray*}
</p>
<p> <br />
 As this actual matrix calculation requires a significant memory allocation, these operations are carried out on a row/column basis, rather than using full matrices. <br />
</p>
<p>First all forces on slave to master, set slave forces to zero on <a class="el" href="classNewtonRaphsonSolver.html#a843bd105e92dfa1c9205e4efa134a406" title="The matrix containing sum of NewtonRaphsonSolver::ge, NewtonRaphsonSolver::gvInternal, NewtonRaphsonSolver::gvExternal, NewtonRaphsonSolver::gExt. Organisation is [Node0,x ; Node0,y ; Node0,z; ... ; Noden,x ; Noden,y ; Noden,z]. ">NewtonRaphsonSolver::gSum</a>, equivalent of \( \boldsymbol{g}_{bound} = \boldsymbol{N^{T}} \boldsymbol{g} \).</p>
<p>Then start the manipulation of the Jacobian, by adding all elements of the slave degrees of freedom row to master degrees of freedom row on <a class="el" href="classNewtonRaphsonSolver.html#a4e9ffc424dd37c6c00f9de3d7ac455ed" title="The Jacobian matrix, derivative of sum of forces acting on each node with respect to displacements...">NewtonRaphsonSolver::K</a>, equivalent of operation \( \boldsymbol{N^{T}} \boldsymbol{K} \).</p>
<p>Followed by adding all elements of the slave degrees of freedom column to master degrees of freedom columno n <a class="el" href="classNewtonRaphsonSolver.html#a4e9ffc424dd37c6c00f9de3d7ac455ed" title="The Jacobian matrix, derivative of sum of forces acting on each node with respect to displacements...">NewtonRaphsonSolver::K</a>, equivalent of operation (cumulatively) \( \boldsymbol{N^{T}} \boldsymbol{K} \boldsymbol{N} \).</p>
<p>Finally, make the diagonal element of <a class="el" href="classNewtonRaphsonSolver.html#a4e9ffc424dd37c6c00f9de3d7ac455ed" title="The Jacobian matrix, derivative of sum of forces acting on each node with respect to displacements...">NewtonRaphsonSolver::K</a>, \( \boldsymbol{K}_{DOFslave,DOFslave} \) to unity, equivalent of operation (cumulatively) \( \boldsymbol{N^{T}} \boldsymbol{K} \boldsymbol{N} + \boldsymbol{\bar{I}}\).</p>

</div>
</div>
<a class="anchor" id="aa0ce333a40397fd113f9b9fc47bcb6ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NewtonRaphsonSolver::calculateDisplacementMatrix </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates the displacement of each node in current iteration "k", from their positions at the end of the previous step "n" (<a class="el" href="classNewtonRaphsonSolver.html#ad217268afdeb4838d3b58f075762de95" title="The matrix storing the position of each node at iteration &quot;k&quot;. Initiated in function NewtonRaphsonSol...">NewtonRaphsonSolver::uk</a> - <a class="el" href="classNewtonRaphsonSolver.html#a89a6e2f583c785b77b967e6f0e9f5893" title="The initial positions of the nodes, as calculated at the end of previous step &quot;n&quot;. ">NewtonRaphsonSolver::un</a>) </p>
<p>The displacement of nodes per <a class="el" href="classSimulation.html#a0ee381efb3458d02bf78487cbb4dc42a" title="The time step increment in seconds, such that Simulation::currSimTimeSec = Simulation::dt * Simulatio...">Simulation::dt</a>, for each iteration defined as \( \frac{\boldsymbol{u_k} - \boldsymbol{u_n}}{dt} \)</p>

</div>
</div>
<a class="anchor" id="ad39200f7babf1a3761a010c1a43f7c22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NewtonRaphsonSolver::calculateExternalViscousForcesForNR </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>Nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates the external viscous forces acting on each node, the values are sotred in <a class="el" href="classNewtonRaphsonSolver.html#a80160d7bfb04a39e3b8910b68f66aa6d" title="The matrix containing external viscous forces on each node, size (nDim*nNodes,1). Organisation is [No...">NewtonRaphsonSolver::gvExternal</a>. </p>
<p>For all nodes of the system, the external viscous forces will depend on the exposed surface associated with each node (<a class="el" href="classNode.html#a7a585da74654d80d5f94805e39c1e2ad" title="The surface of the node, calculated for application of external viscosity via surface. It is positive for a surface that is to feel external viscosity, zero otherwise. ">Node::viscositySurface</a>), calculated through <a class="el" href="classShapeBase.html#aa91f3d3cddf8cc01ce06562185c291ba" title="This function distributes elemenbt&#39;s exposed surfaces to nodes. ">ShapeBase::assignViscositySurfaceAreaToNodes</a>. This surface will be muliplied by the local viscosity <a class="el" href="classNode.html#a6377f135c12aae0dd776107c2628516e" title="External viscosity of the node, defined by its placement within the tissue. This can be defined as an...">Node::externalViscosity</a> and the displacement of the node in current iteration k, from its position at the end of previous time step n.</p>
<p>Once all the viscous forces are calculated, the force direction will be inverted, as I am interested in the visouc drag applied by the meida to the node.</p>

</div>
</div>
<a class="anchor" id="a5793ee41a3a4d97c0c944347f1f6da8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NewtonRaphsonSolver::calculateForcesAndJacobianMatrixNR </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>Nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classShapeBase.html">ShapeBase</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>Elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates elemental forces and Jacobians, later to be combined in <a class="el" href="classNewtonRaphsonSolver.html#a4e9ffc424dd37c6c00f9de3d7ac455ed" title="The Jacobian matrix, derivative of sum of forces acting on each node with respect to displacements...">NewtonRaphsonSolver::K</a> and <a class="el" href="classNewtonRaphsonSolver.html#a843bd105e92dfa1c9205e4efa134a406" title="The matrix containing sum of NewtonRaphsonSolver::ge, NewtonRaphsonSolver::gvInternal, NewtonRaphsonSolver::gvExternal, NewtonRaphsonSolver::gExt. Organisation is [Node0,x ; Node0,y ; Node0,z; ... ; Noden,x ; Noden,y ; Noden,z]. ">NewtonRaphsonSolver::gSum</a>. </p>
<p>The calculation of foces and their derivatives in each element starts with calculation of forces via ShapeBase::calculateForces. A series of calculations necessary for Jacobian calculation are obtained at this stage. Then the Elastic and Viscous parts of the elemetnal Jacobian are calculates through <a class="el" href="classShapeBase.html#a922c41864d4826725cc72089046f818c" title="This function calculates the elemental elastic component of the Jacobian for implicit NR itaration...">ShapeBase::calculateImplicitKElastic</a> and <a class="el" href="classShapeBase.html#a20c23d30b7f9f3bc7ed2fde542401aeb" title="This function calculates the elemental viscous component of the Jacobian for implicit NR itaration...">ShapeBase::calculateImplicitKViscous</a> ,respectively</p>

</div>
</div>
<a class="anchor" id="acfaaed8f038167756f352b566b8455d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NewtonRaphsonSolver::calcutateFixedK </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classNode.html">Node</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>Nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function updates the Jacobian to account for nodes that are fixed in certain dimensions in space, as part of boundary conditions. </p>
<p>Some degrees of freedom are fixed for some nodes, as defined by the user input boundary conditions. this will be recorded in the 3 dimensional boolean array of each node <a class="el" href="classNode.html#a8f3a763935fb67e34784d060c0ea76f8" title="The boolean array stating if the node&#39;s position is fixed in any direction, format: [x y z]...">Node::FixedPos</a> for x,y and z coordinates. In the node has a fixed degree of freedom, then the sum of elastic and viscous forces recorded on <a class="el" href="classNewtonRaphsonSolver.html#a843bd105e92dfa1c9205e4efa134a406" title="The matrix containing sum of NewtonRaphsonSolver::ge, NewtonRaphsonSolver::gvInternal, NewtonRaphsonSolver::gvExternal, NewtonRaphsonSolver::gExt. Organisation is [Node0,x ; Node0,y ; Node0,z; ... ; Noden,x ; Noden,y ; Noden,z]. ">NewtonRaphsonSolver::gSum</a> is made zero. Then in the Jacobian, the diagonal term for the degree of freedom is set to unity, all remaining terms of the column and row of the degree of freedom is set to zero.</p>

</div>
</div>
<a class="anchor" id="a3653a563e32649e0c90407aa089a995b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NewtonRaphsonSolver::checkConvergenceViaDeltaU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for cenvergence with the norm of displacements vector,against the threshold NewtonRaphsonSolver::threshold. </p>
<p>This function checks the norm of <a class="el" href="classNewtonRaphsonSolver.html#a064de5e752631defb9dc1b33d5c115f2" title="The incremental change in positions as calculated in current iteration, resulting from the imbalance ...">NewtonRaphsonSolver::deltaU</a>, the change in nodal positions from previous iteration to this one. If the norm is below the threshold of convergence NewtonRaphsonSolver::threshold, then the solution has been achieved for the current time step.</p>

</div>
</div>
<a class="anchor" id="a16edb5206c079476a0d6c2c956c65f25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NewtonRaphsonSolver::checkConvergenceViaForce </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for cenvergence with the norm of forces vector,against the threshold NewtonRaphsonSolver::threshold. </p>
<p>The system can converge with zero forces as well. This function checks the norm of the sum of all nodal forces against the threshold.</p>

</div>
</div>
<a class="anchor" id="ab4dd0fae0f0d56355521fbd22875bda8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NewtonRaphsonSolver::checkIfSlaveIsAlreadyMasterOfOthers </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dofSlave</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dofMaster</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks if the slave DOF is already master of others, if so, updates the master of said slave to the new master the current slave will be bound to. </p>
<p>The function takes in the addresses for potential master and slave degrees of freedom indices. If the proposed slave DoF is already on the <a class="el" href="classNewtonRaphsonSolver.html#a08e76823173b89fe71fac26ba4edc191" title="The 2D integer vector storing the slave-master degrees of freedom couples, such that array [i][0] = s...">NewtonRaphsonSolver::slaveMasterList</a> as a master, then transfer all DoF that are its slave to the new proposed master.</p>

</div>
</div>
<a class="anchor" id="a40dee8332c648b53cb9b1c8f2f2861ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NewtonRaphsonSolver::checkJacobianForAblatedNodes </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>AblatedNodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions checks the Jacobian to ensure the diagonal terms are non-zero for ablated nodes. </p>
<p>The function clears the system Jacobian for ablated nodes, which should not have any forces acting on them.</p>

</div>
</div>
<a class="anchor" id="a1cc04a2a1d6132eb01437f318bcb5103"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NewtonRaphsonSolver::checkMasterUpdate </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>dofMaster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>masterId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes a degree of freedom number as input. This DOF is supposed to be a master. If, the dof is already a slave to another dof, then update the masetr dof. Anything that would be bound to the input dof can be bound to the already existing master of the input dof. </p>
<p>The function takes in the addresses for potential master and slave degrees of freedom indices. If the proposed master DoF is already on the <a class="el" href="classNewtonRaphsonSolver.html#a08e76823173b89fe71fac26ba4edc191" title="The 2D integer vector storing the slave-master degrees of freedom couples, such that array [i][0] = s...">NewtonRaphsonSolver::slaveMasterList</a> as a slave, then the its master DoF should become the master of the proposed slave DoF. The order of <a class="el" href="classNewtonRaphsonSolver.html#a08e76823173b89fe71fac26ba4edc191" title="The 2D integer vector storing the slave-master degrees of freedom couples, such that array [i][0] = s...">NewtonRaphsonSolver::slaveMasterList</a> is [slave][master].</p>

</div>
</div>
<a class="anchor" id="a8efb09b253b7d19bd978296314d65c24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NewtonRaphsonSolver::solveForDeltaU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function solves for the displacements within the N-R step. </p>
<p>This funciton will solve for new displacements from the system forces and the Jacobian. This requires solving a sparse system of linear equatons, and the operation is handled by Pardiso solver. Please refer to the manual of Pardiso to follow the necessary steps in this function/</p>

</div>
</div>
<a class="anchor" id="a5e457b3608c6fbd71767cd6eed07b2f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NewtonRaphsonSolver::updateUkInIteration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calulate the nodal displacemetns at the kth iteration of NR dolver. </p>
<p>This funciton updates the positions of nodes for next iteration $  {u}_{k+1} $  from the positions of current iteration the $  {u}_{k} $  and $  { u}_{k} $ .</p>

</div>
</div>
<a class="anchor" id="a0d6e3a4d0cf1c6e4fdf2753c7f08df13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NewtonRaphsonSolver::writeImplicitElementalKToJacobian </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classShapeBase.html">ShapeBase</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>Elements</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes the elemental values for elastic part of the Jacobian - stiffness matrix - (<a class="el" href="classShapeBase.html#ace20710f27099833509c474b221c25df" title="Current elastic part of the Jacobian (stiffness matrix) of the system, averaged over all Gauss Points...">ShapeBase::TriPointKe</a>) and for viscous part of Jacobian (<a class="el" href="classShapeBase.html#a7fa5b1338e405a2c75c8d010f4153b05" title="Current viscous part of the Jacobian of the system, averaged over all Gauss Points. ">ShapeBase::TriPointKv</a>) into the system Jacobian <a class="el" href="classNewtonRaphsonSolver.html#a4e9ffc424dd37c6c00f9de3d7ac455ed" title="The Jacobian matrix, derivative of sum of forces acting on each node with respect to displacements...">NewtonRaphsonSolver::K</a>. </p>
<p>All elemental elastic (ShapeBase::Ke) and internal viscous (ShapeBase::Kv) jacobians are added onto the system Jacobian (<a class="el" href="classNewtonRaphsonSolver.html#a4e9ffc424dd37c6c00f9de3d7ac455ed" title="The Jacobian matrix, derivative of sum of forces acting on each node with respect to displacements...">NewtonRaphsonSolver::K</a>) in this function.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/melda/Documents/nonAcademic/TissueFoldingFefractor/TissueFoldingRefractor/TissueFoldingLinux/TissueFolding/SourceCode/<a class="el" href="NewtonRaphsonSolver_8h_source.html">NewtonRaphsonSolver.h</a></li>
<li>/home/melda/Documents/nonAcademic/TissueFoldingFefractor/TissueFoldingRefractor/TissueFoldingLinux/TissueFolding/SourceCode/NewtonRaphsonSolver.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classNewtonRaphsonSolver.html">NewtonRaphsonSolver</a></li>
    <li class="footer">Generated on Wed May 29 2019 16:14:29 for Tissue Origami by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
